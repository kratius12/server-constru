
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model categoria
 * 
 */
export type categoria = $Result.DefaultSelection<Prisma.$categoriaPayload>
/**
 * Model cliente
 * 
 */
export type cliente = $Result.DefaultSelection<Prisma.$clientePayload>
/**
 * Model compras
 * 
 */
export type compras = $Result.DefaultSelection<Prisma.$comprasPayload>
/**
 * Model compras_detalle
 * 
 */
export type compras_detalle = $Result.DefaultSelection<Prisma.$compras_detallePayload>
/**
 * Model empleado
 * 
 */
export type empleado = $Result.DefaultSelection<Prisma.$empleadoPayload>
/**
 * Model empleado_especialidad
 * 
 */
export type empleado_especialidad = $Result.DefaultSelection<Prisma.$empleado_especialidadPayload>
/**
 * Model especialidad
 * 
 */
export type especialidad = $Result.DefaultSelection<Prisma.$especialidadPayload>
/**
 * Model materiales
 * 
 */
export type materiales = $Result.DefaultSelection<Prisma.$materialesPayload>
/**
 * Model obras
 * 
 */
export type obras = $Result.DefaultSelection<Prisma.$obrasPayload>
/**
 * Model permiso
 * 
 */
export type permiso = $Result.DefaultSelection<Prisma.$permisoPayload>
/**
 * Model proveedor
 * 
 */
export type proveedor = $Result.DefaultSelection<Prisma.$proveedorPayload>
/**
 * Model rol
 * 
 */
export type rol = $Result.DefaultSelection<Prisma.$rolPayload>
/**
 * Model detalle_obra
 * 
 */
export type detalle_obra = $Result.DefaultSelection<Prisma.$detalle_obraPayload>
/**
 * Model rolpermisoempleado
 * 
 */
export type rolpermisoempleado = $Result.DefaultSelection<Prisma.$rolpermisoempleadoPayload>
/**
 * Model codigos
 * 
 */
export type codigos = $Result.DefaultSelection<Prisma.$codigosPayload>
/**
 * Model actividades_empleados
 * 
 */
export type actividades_empleados = $Result.DefaultSelection<Prisma.$actividades_empleadosPayload>
/**
 * Model actividades_materiales
 * 
 */
export type actividades_materiales = $Result.DefaultSelection<Prisma.$actividades_materialesPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Categorias
 * const categorias = await prisma.categoria.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Categorias
   * const categorias = await prisma.categoria.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.categoria`: Exposes CRUD operations for the **categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categorias
    * const categorias = await prisma.categoria.findMany()
    * ```
    */
  get categoria(): Prisma.categoriaDelegate<ExtArgs>;

  /**
   * `prisma.cliente`: Exposes CRUD operations for the **cliente** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.cliente.findMany()
    * ```
    */
  get cliente(): Prisma.clienteDelegate<ExtArgs>;

  /**
   * `prisma.compras`: Exposes CRUD operations for the **compras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras
    * const compras = await prisma.compras.findMany()
    * ```
    */
  get compras(): Prisma.comprasDelegate<ExtArgs>;

  /**
   * `prisma.compras_detalle`: Exposes CRUD operations for the **compras_detalle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compras_detalles
    * const compras_detalles = await prisma.compras_detalle.findMany()
    * ```
    */
  get compras_detalle(): Prisma.compras_detalleDelegate<ExtArgs>;

  /**
   * `prisma.empleado`: Exposes CRUD operations for the **empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleado.findMany()
    * ```
    */
  get empleado(): Prisma.empleadoDelegate<ExtArgs>;

  /**
   * `prisma.empleado_especialidad`: Exposes CRUD operations for the **empleado_especialidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleado_especialidads
    * const empleado_especialidads = await prisma.empleado_especialidad.findMany()
    * ```
    */
  get empleado_especialidad(): Prisma.empleado_especialidadDelegate<ExtArgs>;

  /**
   * `prisma.especialidad`: Exposes CRUD operations for the **especialidad** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Especialidads
    * const especialidads = await prisma.especialidad.findMany()
    * ```
    */
  get especialidad(): Prisma.especialidadDelegate<ExtArgs>;

  /**
   * `prisma.materiales`: Exposes CRUD operations for the **materiales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materiales
    * const materiales = await prisma.materiales.findMany()
    * ```
    */
  get materiales(): Prisma.materialesDelegate<ExtArgs>;

  /**
   * `prisma.obras`: Exposes CRUD operations for the **obras** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obras
    * const obras = await prisma.obras.findMany()
    * ```
    */
  get obras(): Prisma.obrasDelegate<ExtArgs>;

  /**
   * `prisma.permiso`: Exposes CRUD operations for the **permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisos
    * const permisos = await prisma.permiso.findMany()
    * ```
    */
  get permiso(): Prisma.permisoDelegate<ExtArgs>;

  /**
   * `prisma.proveedor`: Exposes CRUD operations for the **proveedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proveedors
    * const proveedors = await prisma.proveedor.findMany()
    * ```
    */
  get proveedor(): Prisma.proveedorDelegate<ExtArgs>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.rolDelegate<ExtArgs>;

  /**
   * `prisma.detalle_obra`: Exposes CRUD operations for the **detalle_obra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Detalle_obras
    * const detalle_obras = await prisma.detalle_obra.findMany()
    * ```
    */
  get detalle_obra(): Prisma.detalle_obraDelegate<ExtArgs>;

  /**
   * `prisma.rolpermisoempleado`: Exposes CRUD operations for the **rolpermisoempleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rolpermisoempleados
    * const rolpermisoempleados = await prisma.rolpermisoempleado.findMany()
    * ```
    */
  get rolpermisoempleado(): Prisma.rolpermisoempleadoDelegate<ExtArgs>;

  /**
   * `prisma.codigos`: Exposes CRUD operations for the **codigos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Codigos
    * const codigos = await prisma.codigos.findMany()
    * ```
    */
  get codigos(): Prisma.codigosDelegate<ExtArgs>;

  /**
   * `prisma.actividades_empleados`: Exposes CRUD operations for the **actividades_empleados** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividades_empleados
    * const actividades_empleados = await prisma.actividades_empleados.findMany()
    * ```
    */
  get actividades_empleados(): Prisma.actividades_empleadosDelegate<ExtArgs>;

  /**
   * `prisma.actividades_materiales`: Exposes CRUD operations for the **actividades_materiales** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Actividades_materiales
    * const actividades_materiales = await prisma.actividades_materiales.findMany()
    * ```
    */
  get actividades_materiales(): Prisma.actividades_materialesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: 78caf6feeaed953168c64e15a249c3e9a033ebe2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    categoria: 'categoria',
    cliente: 'cliente',
    compras: 'compras',
    compras_detalle: 'compras_detalle',
    empleado: 'empleado',
    empleado_especialidad: 'empleado_especialidad',
    especialidad: 'especialidad',
    materiales: 'materiales',
    obras: 'obras',
    permiso: 'permiso',
    proveedor: 'proveedor',
    rol: 'rol',
    detalle_obra: 'detalle_obra',
    rolpermisoempleado: 'rolpermisoempleado',
    codigos: 'codigos',
    actividades_empleados: 'actividades_empleados',
    actividades_materiales: 'actividades_materiales'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'categoria' | 'cliente' | 'compras' | 'compras_detalle' | 'empleado' | 'empleado_especialidad' | 'especialidad' | 'materiales' | 'obras' | 'permiso' | 'proveedor' | 'rol' | 'detalle_obra' | 'rolpermisoempleado' | 'codigos' | 'actividades_empleados' | 'actividades_materiales'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      categoria: {
        payload: Prisma.$categoriaPayload<ExtArgs>
        fields: Prisma.categoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findFirst: {
            args: Prisma.categoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          findMany: {
            args: Prisma.categoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>[]
          }
          create: {
            args: Prisma.categoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          createMany: {
            args: Prisma.categoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.categoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          update: {
            args: Prisma.categoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          deleteMany: {
            args: Prisma.categoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.categoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.categoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$categoriaPayload>
          }
          aggregate: {
            args: Prisma.CategoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategoria>
          }
          groupBy: {
            args: Prisma.categoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoriaCountAggregateOutputType> | number
          }
        }
      }
      cliente: {
        payload: Prisma.$clientePayload<ExtArgs>
        fields: Prisma.clienteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.clienteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.clienteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findFirst: {
            args: Prisma.clienteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.clienteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          findMany: {
            args: Prisma.clienteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>[]
          }
          create: {
            args: Prisma.clienteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          createMany: {
            args: Prisma.clienteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.clienteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          update: {
            args: Prisma.clienteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          deleteMany: {
            args: Prisma.clienteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.clienteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.clienteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$clientePayload>
          }
          aggregate: {
            args: Prisma.ClienteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCliente>
          }
          groupBy: {
            args: Prisma.clienteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClienteGroupByOutputType>[]
          }
          count: {
            args: Prisma.clienteCountArgs<ExtArgs>,
            result: $Utils.Optional<ClienteCountAggregateOutputType> | number
          }
        }
      }
      compras: {
        payload: Prisma.$comprasPayload<ExtArgs>
        fields: Prisma.comprasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comprasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comprasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findFirst: {
            args: Prisma.comprasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comprasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          findMany: {
            args: Prisma.comprasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>[]
          }
          create: {
            args: Prisma.comprasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          createMany: {
            args: Prisma.comprasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.comprasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          update: {
            args: Prisma.comprasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          deleteMany: {
            args: Prisma.comprasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.comprasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.comprasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$comprasPayload>
          }
          aggregate: {
            args: Prisma.ComprasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompras>
          }
          groupBy: {
            args: Prisma.comprasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComprasGroupByOutputType>[]
          }
          count: {
            args: Prisma.comprasCountArgs<ExtArgs>,
            result: $Utils.Optional<ComprasCountAggregateOutputType> | number
          }
        }
      }
      compras_detalle: {
        payload: Prisma.$compras_detallePayload<ExtArgs>
        fields: Prisma.compras_detalleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.compras_detalleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.compras_detalleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          findFirst: {
            args: Prisma.compras_detalleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.compras_detalleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          findMany: {
            args: Prisma.compras_detalleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>[]
          }
          create: {
            args: Prisma.compras_detalleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          createMany: {
            args: Prisma.compras_detalleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.compras_detalleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          update: {
            args: Prisma.compras_detalleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          deleteMany: {
            args: Prisma.compras_detalleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.compras_detalleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.compras_detalleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$compras_detallePayload>
          }
          aggregate: {
            args: Prisma.Compras_detalleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCompras_detalle>
          }
          groupBy: {
            args: Prisma.compras_detalleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Compras_detalleGroupByOutputType>[]
          }
          count: {
            args: Prisma.compras_detalleCountArgs<ExtArgs>,
            result: $Utils.Optional<Compras_detalleCountAggregateOutputType> | number
          }
        }
      }
      empleado: {
        payload: Prisma.$empleadoPayload<ExtArgs>
        fields: Prisma.empleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empleadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empleadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          findFirst: {
            args: Prisma.empleadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empleadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          findMany: {
            args: Prisma.empleadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>[]
          }
          create: {
            args: Prisma.empleadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          createMany: {
            args: Prisma.empleadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.empleadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          update: {
            args: Prisma.empleadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          deleteMany: {
            args: Prisma.empleadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.empleadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.empleadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleadoPayload>
          }
          aggregate: {
            args: Prisma.EmpleadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmpleado>
          }
          groupBy: {
            args: Prisma.empleadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmpleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.empleadoCountArgs<ExtArgs>,
            result: $Utils.Optional<EmpleadoCountAggregateOutputType> | number
          }
        }
      }
      empleado_especialidad: {
        payload: Prisma.$empleado_especialidadPayload<ExtArgs>
        fields: Prisma.empleado_especialidadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.empleado_especialidadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.empleado_especialidadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          findFirst: {
            args: Prisma.empleado_especialidadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.empleado_especialidadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          findMany: {
            args: Prisma.empleado_especialidadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>[]
          }
          create: {
            args: Prisma.empleado_especialidadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          createMany: {
            args: Prisma.empleado_especialidadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.empleado_especialidadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          update: {
            args: Prisma.empleado_especialidadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          deleteMany: {
            args: Prisma.empleado_especialidadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.empleado_especialidadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.empleado_especialidadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$empleado_especialidadPayload>
          }
          aggregate: {
            args: Prisma.Empleado_especialidadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmpleado_especialidad>
          }
          groupBy: {
            args: Prisma.empleado_especialidadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Empleado_especialidadGroupByOutputType>[]
          }
          count: {
            args: Prisma.empleado_especialidadCountArgs<ExtArgs>,
            result: $Utils.Optional<Empleado_especialidadCountAggregateOutputType> | number
          }
        }
      }
      especialidad: {
        payload: Prisma.$especialidadPayload<ExtArgs>
        fields: Prisma.especialidadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.especialidadFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.especialidadFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          findFirst: {
            args: Prisma.especialidadFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.especialidadFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          findMany: {
            args: Prisma.especialidadFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>[]
          }
          create: {
            args: Prisma.especialidadCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          createMany: {
            args: Prisma.especialidadCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.especialidadDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          update: {
            args: Prisma.especialidadUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          deleteMany: {
            args: Prisma.especialidadDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.especialidadUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.especialidadUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$especialidadPayload>
          }
          aggregate: {
            args: Prisma.EspecialidadAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEspecialidad>
          }
          groupBy: {
            args: Prisma.especialidadGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EspecialidadGroupByOutputType>[]
          }
          count: {
            args: Prisma.especialidadCountArgs<ExtArgs>,
            result: $Utils.Optional<EspecialidadCountAggregateOutputType> | number
          }
        }
      }
      materiales: {
        payload: Prisma.$materialesPayload<ExtArgs>
        fields: Prisma.materialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.materialesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.materialesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findFirst: {
            args: Prisma.materialesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.materialesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          findMany: {
            args: Prisma.materialesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>[]
          }
          create: {
            args: Prisma.materialesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          createMany: {
            args: Prisma.materialesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.materialesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          update: {
            args: Prisma.materialesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          deleteMany: {
            args: Prisma.materialesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.materialesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.materialesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$materialesPayload>
          }
          aggregate: {
            args: Prisma.MaterialesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMateriales>
          }
          groupBy: {
            args: Prisma.materialesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MaterialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.materialesCountArgs<ExtArgs>,
            result: $Utils.Optional<MaterialesCountAggregateOutputType> | number
          }
        }
      }
      obras: {
        payload: Prisma.$obrasPayload<ExtArgs>
        fields: Prisma.obrasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.obrasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.obrasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          findFirst: {
            args: Prisma.obrasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.obrasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          findMany: {
            args: Prisma.obrasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>[]
          }
          create: {
            args: Prisma.obrasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          createMany: {
            args: Prisma.obrasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.obrasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          update: {
            args: Prisma.obrasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          deleteMany: {
            args: Prisma.obrasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.obrasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.obrasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$obrasPayload>
          }
          aggregate: {
            args: Prisma.ObrasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObras>
          }
          groupBy: {
            args: Prisma.obrasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObrasGroupByOutputType>[]
          }
          count: {
            args: Prisma.obrasCountArgs<ExtArgs>,
            result: $Utils.Optional<ObrasCountAggregateOutputType> | number
          }
        }
      }
      permiso: {
        payload: Prisma.$permisoPayload<ExtArgs>
        fields: Prisma.permisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permisoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permisoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          findFirst: {
            args: Prisma.permisoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permisoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          findMany: {
            args: Prisma.permisoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>[]
          }
          create: {
            args: Prisma.permisoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          createMany: {
            args: Prisma.permisoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.permisoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          update: {
            args: Prisma.permisoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          deleteMany: {
            args: Prisma.permisoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.permisoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.permisoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$permisoPayload>
          }
          aggregate: {
            args: Prisma.PermisoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermiso>
          }
          groupBy: {
            args: Prisma.permisoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.permisoCountArgs<ExtArgs>,
            result: $Utils.Optional<PermisoCountAggregateOutputType> | number
          }
        }
      }
      proveedor: {
        payload: Prisma.$proveedorPayload<ExtArgs>
        fields: Prisma.proveedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.proveedorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.proveedorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findFirst: {
            args: Prisma.proveedorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.proveedorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          findMany: {
            args: Prisma.proveedorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>[]
          }
          create: {
            args: Prisma.proveedorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          createMany: {
            args: Prisma.proveedorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.proveedorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          update: {
            args: Prisma.proveedorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          deleteMany: {
            args: Prisma.proveedorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.proveedorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.proveedorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$proveedorPayload>
          }
          aggregate: {
            args: Prisma.ProveedorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProveedor>
          }
          groupBy: {
            args: Prisma.proveedorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.proveedorCountArgs<ExtArgs>,
            result: $Utils.Optional<ProveedorCountAggregateOutputType> | number
          }
        }
      }
      rol: {
        payload: Prisma.$rolPayload<ExtArgs>
        fields: Prisma.rolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          findFirst: {
            args: Prisma.rolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          findMany: {
            args: Prisma.rolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>[]
          }
          create: {
            args: Prisma.rolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          createMany: {
            args: Prisma.rolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          update: {
            args: Prisma.rolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          deleteMany: {
            args: Prisma.rolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.rolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolCountArgs<ExtArgs>,
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      detalle_obra: {
        payload: Prisma.$detalle_obraPayload<ExtArgs>
        fields: Prisma.detalle_obraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.detalle_obraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.detalle_obraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          findFirst: {
            args: Prisma.detalle_obraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.detalle_obraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          findMany: {
            args: Prisma.detalle_obraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>[]
          }
          create: {
            args: Prisma.detalle_obraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          createMany: {
            args: Prisma.detalle_obraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.detalle_obraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          update: {
            args: Prisma.detalle_obraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          deleteMany: {
            args: Prisma.detalle_obraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.detalle_obraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.detalle_obraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$detalle_obraPayload>
          }
          aggregate: {
            args: Prisma.Detalle_obraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDetalle_obra>
          }
          groupBy: {
            args: Prisma.detalle_obraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Detalle_obraGroupByOutputType>[]
          }
          count: {
            args: Prisma.detalle_obraCountArgs<ExtArgs>,
            result: $Utils.Optional<Detalle_obraCountAggregateOutputType> | number
          }
        }
      }
      rolpermisoempleado: {
        payload: Prisma.$rolpermisoempleadoPayload<ExtArgs>
        fields: Prisma.rolpermisoempleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolpermisoempleadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolpermisoempleadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          findFirst: {
            args: Prisma.rolpermisoempleadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolpermisoempleadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          findMany: {
            args: Prisma.rolpermisoempleadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>[]
          }
          create: {
            args: Prisma.rolpermisoempleadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          createMany: {
            args: Prisma.rolpermisoempleadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.rolpermisoempleadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          update: {
            args: Prisma.rolpermisoempleadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          deleteMany: {
            args: Prisma.rolpermisoempleadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.rolpermisoempleadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.rolpermisoempleadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$rolpermisoempleadoPayload>
          }
          aggregate: {
            args: Prisma.RolpermisoempleadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRolpermisoempleado>
          }
          groupBy: {
            args: Prisma.rolpermisoempleadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolpermisoempleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolpermisoempleadoCountArgs<ExtArgs>,
            result: $Utils.Optional<RolpermisoempleadoCountAggregateOutputType> | number
          }
        }
      }
      codigos: {
        payload: Prisma.$codigosPayload<ExtArgs>
        fields: Prisma.codigosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.codigosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.codigosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          findFirst: {
            args: Prisma.codigosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.codigosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          findMany: {
            args: Prisma.codigosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>[]
          }
          create: {
            args: Prisma.codigosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          createMany: {
            args: Prisma.codigosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.codigosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          update: {
            args: Prisma.codigosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          deleteMany: {
            args: Prisma.codigosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.codigosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.codigosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$codigosPayload>
          }
          aggregate: {
            args: Prisma.CodigosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCodigos>
          }
          groupBy: {
            args: Prisma.codigosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CodigosGroupByOutputType>[]
          }
          count: {
            args: Prisma.codigosCountArgs<ExtArgs>,
            result: $Utils.Optional<CodigosCountAggregateOutputType> | number
          }
        }
      }
      actividades_empleados: {
        payload: Prisma.$actividades_empleadosPayload<ExtArgs>
        fields: Prisma.actividades_empleadosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.actividades_empleadosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.actividades_empleadosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          findFirst: {
            args: Prisma.actividades_empleadosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.actividades_empleadosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          findMany: {
            args: Prisma.actividades_empleadosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>[]
          }
          create: {
            args: Prisma.actividades_empleadosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          createMany: {
            args: Prisma.actividades_empleadosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.actividades_empleadosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          update: {
            args: Prisma.actividades_empleadosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          deleteMany: {
            args: Prisma.actividades_empleadosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.actividades_empleadosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.actividades_empleadosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_empleadosPayload>
          }
          aggregate: {
            args: Prisma.Actividades_empleadosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActividades_empleados>
          }
          groupBy: {
            args: Prisma.actividades_empleadosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Actividades_empleadosGroupByOutputType>[]
          }
          count: {
            args: Prisma.actividades_empleadosCountArgs<ExtArgs>,
            result: $Utils.Optional<Actividades_empleadosCountAggregateOutputType> | number
          }
        }
      }
      actividades_materiales: {
        payload: Prisma.$actividades_materialesPayload<ExtArgs>
        fields: Prisma.actividades_materialesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.actividades_materialesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.actividades_materialesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          findFirst: {
            args: Prisma.actividades_materialesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.actividades_materialesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          findMany: {
            args: Prisma.actividades_materialesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>[]
          }
          create: {
            args: Prisma.actividades_materialesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          createMany: {
            args: Prisma.actividades_materialesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.actividades_materialesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          update: {
            args: Prisma.actividades_materialesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          deleteMany: {
            args: Prisma.actividades_materialesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.actividades_materialesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.actividades_materialesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$actividades_materialesPayload>
          }
          aggregate: {
            args: Prisma.Actividades_materialesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateActividades_materiales>
          }
          groupBy: {
            args: Prisma.actividades_materialesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Actividades_materialesGroupByOutputType>[]
          }
          count: {
            args: Prisma.actividades_materialesCountArgs<ExtArgs>,
            result: $Utils.Optional<Actividades_materialesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriaCountOutputType
   */

  export type CategoriaCountOutputType = {
    materiales: number
  }

  export type CategoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiales?: boolean | CategoriaCountOutputTypeCountMaterialesArgs
  }

  // Custom InputTypes

  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriaCountOutputType
     */
    select?: CategoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoriaCountOutputType without action
   */
  export type CategoriaCountOutputTypeCountMaterialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
  }



  /**
   * Count Type ClienteCountOutputType
   */

  export type ClienteCountOutputType = {
    obras: number
  }

  export type ClienteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obras?: boolean | ClienteCountOutputTypeCountObrasArgs
  }

  // Custom InputTypes

  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClienteCountOutputType
     */
    select?: ClienteCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClienteCountOutputType without action
   */
  export type ClienteCountOutputTypeCountObrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: obrasWhereInput
  }



  /**
   * Count Type ComprasCountOutputType
   */

  export type ComprasCountOutputType = {
    compras_detalle: number
  }

  export type ComprasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras_detalle?: boolean | ComprasCountOutputTypeCountCompras_detalleArgs
  }

  // Custom InputTypes

  /**
   * ComprasCountOutputType without action
   */
  export type ComprasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComprasCountOutputType
     */
    select?: ComprasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ComprasCountOutputType without action
   */
  export type ComprasCountOutputTypeCountCompras_detalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compras_detalleWhereInput
  }



  /**
   * Count Type EmpleadoCountOutputType
   */

  export type EmpleadoCountOutputType = {
    actividades_empleados: number
    empleado_especialidad: number
    obras: number
    rolpermisoempleado: number
  }

  export type EmpleadoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_empleados?: boolean | EmpleadoCountOutputTypeCountActividades_empleadosArgs
    empleado_especialidad?: boolean | EmpleadoCountOutputTypeCountEmpleado_especialidadArgs
    obras?: boolean | EmpleadoCountOutputTypeCountObrasArgs
    rolpermisoempleado?: boolean | EmpleadoCountOutputTypeCountRolpermisoempleadoArgs
  }

  // Custom InputTypes

  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmpleadoCountOutputType
     */
    select?: EmpleadoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountActividades_empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_empleadosWhereInput
  }


  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountEmpleado_especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleado_especialidadWhereInput
  }


  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountObrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: obrasWhereInput
  }


  /**
   * EmpleadoCountOutputType without action
   */
  export type EmpleadoCountOutputTypeCountRolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolpermisoempleadoWhereInput
  }



  /**
   * Count Type EspecialidadCountOutputType
   */

  export type EspecialidadCountOutputType = {
    empleado_especialidad: number
  }

  export type EspecialidadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado_especialidad?: boolean | EspecialidadCountOutputTypeCountEmpleado_especialidadArgs
  }

  // Custom InputTypes

  /**
   * EspecialidadCountOutputType without action
   */
  export type EspecialidadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EspecialidadCountOutputType
     */
    select?: EspecialidadCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * EspecialidadCountOutputType without action
   */
  export type EspecialidadCountOutputTypeCountEmpleado_especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleado_especialidadWhereInput
  }



  /**
   * Count Type MaterialesCountOutputType
   */

  export type MaterialesCountOutputType = {
    actividades_materiales: number
    compras_detalle: number
  }

  export type MaterialesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_materiales?: boolean | MaterialesCountOutputTypeCountActividades_materialesArgs
    compras_detalle?: boolean | MaterialesCountOutputTypeCountCompras_detalleArgs
  }

  // Custom InputTypes

  /**
   * MaterialesCountOutputType without action
   */
  export type MaterialesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaterialesCountOutputType
     */
    select?: MaterialesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * MaterialesCountOutputType without action
   */
  export type MaterialesCountOutputTypeCountActividades_materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_materialesWhereInput
  }


  /**
   * MaterialesCountOutputType without action
   */
  export type MaterialesCountOutputTypeCountCompras_detalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compras_detalleWhereInput
  }



  /**
   * Count Type ObrasCountOutputType
   */

  export type ObrasCountOutputType = {
    actividades_empleados: number
    actividades_materiales: number
    detalle_obra: number
  }

  export type ObrasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_empleados?: boolean | ObrasCountOutputTypeCountActividades_empleadosArgs
    actividades_materiales?: boolean | ObrasCountOutputTypeCountActividades_materialesArgs
    detalle_obra?: boolean | ObrasCountOutputTypeCountDetalle_obraArgs
  }

  // Custom InputTypes

  /**
   * ObrasCountOutputType without action
   */
  export type ObrasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObrasCountOutputType
     */
    select?: ObrasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ObrasCountOutputType without action
   */
  export type ObrasCountOutputTypeCountActividades_empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_empleadosWhereInput
  }


  /**
   * ObrasCountOutputType without action
   */
  export type ObrasCountOutputTypeCountActividades_materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_materialesWhereInput
  }


  /**
   * ObrasCountOutputType without action
   */
  export type ObrasCountOutputTypeCountDetalle_obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_obraWhereInput
  }



  /**
   * Count Type PermisoCountOutputType
   */

  export type PermisoCountOutputType = {
    rolpermisoempleado: number
  }

  export type PermisoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolpermisoempleado?: boolean | PermisoCountOutputTypeCountRolpermisoempleadoArgs
  }

  // Custom InputTypes

  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermisoCountOutputType
     */
    select?: PermisoCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PermisoCountOutputType without action
   */
  export type PermisoCountOutputTypeCountRolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolpermisoempleadoWhereInput
  }



  /**
   * Count Type ProveedorCountOutputType
   */

  export type ProveedorCountOutputType = {
    compras: number
  }

  export type ProveedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | ProveedorCountOutputTypeCountComprasArgs
  }

  // Custom InputTypes

  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProveedorCountOutputType
     */
    select?: ProveedorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProveedorCountOutputType without action
   */
  export type ProveedorCountOutputTypeCountComprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
  }



  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    rolpermisoempleado: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolpermisoempleado?: boolean | RolCountOutputTypeCountRolpermisoempleadoArgs
  }

  // Custom InputTypes

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountRolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolpermisoempleadoWhereInput
  }



  /**
   * Models
   */

  /**
   * Model categoria
   */

  export type AggregateCategoria = {
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  export type CategoriaAvgAggregateOutputType = {
    idcat: number | null
    estado: number | null
  }

  export type CategoriaSumAggregateOutputType = {
    idcat: number | null
    estado: number | null
  }

  export type CategoriaMinAggregateOutputType = {
    idcat: number | null
    nombre: string | null
    estado: number | null
    medida: string | null
  }

  export type CategoriaMaxAggregateOutputType = {
    idcat: number | null
    nombre: string | null
    estado: number | null
    medida: string | null
  }

  export type CategoriaCountAggregateOutputType = {
    idcat: number
    nombre: number
    estado: number
    medida: number
    _all: number
  }


  export type CategoriaAvgAggregateInputType = {
    idcat?: true
    estado?: true
  }

  export type CategoriaSumAggregateInputType = {
    idcat?: true
    estado?: true
  }

  export type CategoriaMinAggregateInputType = {
    idcat?: true
    nombre?: true
    estado?: true
    medida?: true
  }

  export type CategoriaMaxAggregateInputType = {
    idcat?: true
    nombre?: true
    estado?: true
    medida?: true
  }

  export type CategoriaCountAggregateInputType = {
    idcat?: true
    nombre?: true
    estado?: true
    medida?: true
    _all?: true
  }

  export type CategoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categoria to aggregate.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categorias
    **/
    _count?: true | CategoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriaMaxAggregateInputType
  }

  export type GetCategoriaAggregateType<T extends CategoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateCategoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategoria[P]>
      : GetScalarType<T[P], AggregateCategoria[P]>
  }




  export type categoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriaWhereInput
    orderBy?: categoriaOrderByWithAggregationInput | categoriaOrderByWithAggregationInput[]
    by: CategoriaScalarFieldEnum[] | CategoriaScalarFieldEnum
    having?: categoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriaCountAggregateInputType | true
    _avg?: CategoriaAvgAggregateInputType
    _sum?: CategoriaSumAggregateInputType
    _min?: CategoriaMinAggregateInputType
    _max?: CategoriaMaxAggregateInputType
  }

  export type CategoriaGroupByOutputType = {
    idcat: number
    nombre: string | null
    estado: number | null
    medida: string | null
    _count: CategoriaCountAggregateOutputType | null
    _avg: CategoriaAvgAggregateOutputType | null
    _sum: CategoriaSumAggregateOutputType | null
    _min: CategoriaMinAggregateOutputType | null
    _max: CategoriaMaxAggregateOutputType | null
  }

  type GetCategoriaGroupByPayload<T extends categoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriaGroupByOutputType[P]>
        }
      >
    >


  export type categoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idcat?: boolean
    nombre?: boolean
    estado?: boolean
    medida?: boolean
    materiales?: boolean | categoria$materialesArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categoria"]>

  export type categoriaSelectScalar = {
    idcat?: boolean
    nombre?: boolean
    estado?: boolean
    medida?: boolean
  }

  export type categoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiales?: boolean | categoria$materialesArgs<ExtArgs>
    _count?: boolean | CategoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $categoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categoria"
    objects: {
      materiales: Prisma.$materialesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idcat: number
      nombre: string | null
      estado: number | null
      medida: string | null
    }, ExtArgs["result"]["categoria"]>
    composites: {}
  }


  type categoriaGetPayload<S extends boolean | null | undefined | categoriaDefaultArgs> = $Result.GetResult<Prisma.$categoriaPayload, S>

  type categoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<categoriaFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CategoriaCountAggregateInputType | true
    }

  export interface categoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categoria'], meta: { name: 'categoria' } }
    /**
     * Find zero or one Categoria that matches the filter.
     * @param {categoriaFindUniqueArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends categoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {categoriaFindUniqueOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends categoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends categoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaFindFirstArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindFirstOrThrowArgs} args - Arguments to find a Categoria
     * @example
     * // Get one Categoria
     * const categoria = await prisma.categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends categoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categorias
     * const categorias = await prisma.categoria.findMany()
     * 
     * // Get first 10 Categorias
     * const categorias = await prisma.categoria.findMany({ take: 10 })
     * 
     * // Only select the `idcat`
     * const categoriaWithIdcatOnly = await prisma.categoria.findMany({ select: { idcat: true } })
     * 
    **/
    findMany<T extends categoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Categoria.
     * @param {categoriaCreateArgs} args - Arguments to create a Categoria.
     * @example
     * // Create one Categoria
     * const Categoria = await prisma.categoria.create({
     *   data: {
     *     // ... data to create a Categoria
     *   }
     * })
     * 
    **/
    create<T extends categoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaCreateArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categorias.
     *     @param {categoriaCreateManyArgs} args - Arguments to create many Categorias.
     *     @example
     *     // Create many Categorias
     *     const categoria = await prisma.categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends categoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categoria.
     * @param {categoriaDeleteArgs} args - Arguments to delete one Categoria.
     * @example
     * // Delete one Categoria
     * const Categoria = await prisma.categoria.delete({
     *   where: {
     *     // ... filter to delete one Categoria
     *   }
     * })
     * 
    **/
    delete<T extends categoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaDeleteArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Categoria.
     * @param {categoriaUpdateArgs} args - Arguments to update one Categoria.
     * @example
     * // Update one Categoria
     * const categoria = await prisma.categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends categoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaUpdateArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categorias.
     * @param {categoriaDeleteManyArgs} args - Arguments to filter Categorias to delete.
     * @example
     * // Delete a few Categorias
     * const { count } = await prisma.categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends categoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, categoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categorias
     * const categoria = await prisma.categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends categoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categoria.
     * @param {categoriaUpsertArgs} args - Arguments to update or create a Categoria.
     * @example
     * // Update or create a Categoria
     * const categoria = await prisma.categoria.upsert({
     *   create: {
     *     // ... data to create a Categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categoria we want to update
     *   }
     * })
    **/
    upsert<T extends categoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, categoriaUpsertArgs<ExtArgs>>
    ): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaCountArgs} args - Arguments to filter Categorias to count.
     * @example
     * // Count the number of Categorias
     * const count = await prisma.categoria.count({
     *   where: {
     *     // ... the filter for the Categorias we want to count
     *   }
     * })
    **/
    count<T extends categoriaCountArgs>(
      args?: Subset<T, categoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriaAggregateArgs>(args: Subset<T, CategoriaAggregateArgs>): Prisma.PrismaPromise<GetCategoriaAggregateType<T>>

    /**
     * Group by Categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriaGroupByArgs['orderBy'] }
        : { orderBy?: categoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categoria model
   */
  readonly fields: categoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    materiales<T extends categoria$materialesArgs<ExtArgs> = {}>(args?: Subset<T, categoria$materialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the categoria model
   */ 
  interface categoriaFieldRefs {
    readonly idcat: FieldRef<"categoria", 'Int'>
    readonly nombre: FieldRef<"categoria", 'String'>
    readonly estado: FieldRef<"categoria", 'Int'>
    readonly medida: FieldRef<"categoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * categoria findUnique
   */
  export type categoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }


  /**
   * categoria findUniqueOrThrow
   */
  export type categoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where: categoriaWhereUniqueInput
  }


  /**
   * categoria findFirst
   */
  export type categoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * categoria findFirstOrThrow
   */
  export type categoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categoria to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categorias.
     */
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * categoria findMany
   */
  export type categoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter, which categorias to fetch.
     */
    where?: categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categorias to fetch.
     */
    orderBy?: categoriaOrderByWithRelationInput | categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categorias.
     */
    cursor?: categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categorias.
     */
    skip?: number
    distinct?: CategoriaScalarFieldEnum | CategoriaScalarFieldEnum[]
  }


  /**
   * categoria create
   */
  export type categoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a categoria.
     */
    data?: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
  }


  /**
   * categoria createMany
   */
  export type categoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categorias.
     */
    data: categoriaCreateManyInput | categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * categoria update
   */
  export type categoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a categoria.
     */
    data: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
    /**
     * Choose, which categoria to update.
     */
    where: categoriaWhereUniqueInput
  }


  /**
   * categoria updateMany
   */
  export type categoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categorias.
     */
    data: XOR<categoriaUpdateManyMutationInput, categoriaUncheckedUpdateManyInput>
    /**
     * Filter which categorias to update
     */
    where?: categoriaWhereInput
  }


  /**
   * categoria upsert
   */
  export type categoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the categoria to update in case it exists.
     */
    where: categoriaWhereUniqueInput
    /**
     * In case the categoria found by the `where` argument doesn't exist, create a new categoria with this data.
     */
    create: XOR<categoriaCreateInput, categoriaUncheckedCreateInput>
    /**
     * In case the categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriaUpdateInput, categoriaUncheckedUpdateInput>
  }


  /**
   * categoria delete
   */
  export type categoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    /**
     * Filter which categoria to delete.
     */
    where: categoriaWhereUniqueInput
  }


  /**
   * categoria deleteMany
   */
  export type categoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categorias to delete
     */
    where?: categoriaWhereInput
  }


  /**
   * categoria.materiales
   */
  export type categoria$materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    cursor?: materialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }


  /**
   * categoria without action
   */
  export type categoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
  }



  /**
   * Model cliente
   */

  export type AggregateCliente = {
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  export type ClienteAvgAggregateOutputType = {
    idCli: number | null
    estado: number | null
  }

  export type ClienteSumAggregateOutputType = {
    idCli: number | null
    estado: number | null
  }

  export type ClienteMinAggregateOutputType = {
    idCli: number | null
    nombre: string | null
    apellidos: string | null
    email: string | null
    direccion: string | null
    telefono: string | null
    tipoDoc: string | null
    cedula: string | null
    fecha_nac: string | null
    estado: number | null
    constrasena: string | null
    createdAt: Date | null
  }

  export type ClienteMaxAggregateOutputType = {
    idCli: number | null
    nombre: string | null
    apellidos: string | null
    email: string | null
    direccion: string | null
    telefono: string | null
    tipoDoc: string | null
    cedula: string | null
    fecha_nac: string | null
    estado: number | null
    constrasena: string | null
    createdAt: Date | null
  }

  export type ClienteCountAggregateOutputType = {
    idCli: number
    nombre: number
    apellidos: number
    email: number
    direccion: number
    telefono: number
    tipoDoc: number
    cedula: number
    fecha_nac: number
    estado: number
    constrasena: number
    createdAt: number
    _all: number
  }


  export type ClienteAvgAggregateInputType = {
    idCli?: true
    estado?: true
  }

  export type ClienteSumAggregateInputType = {
    idCli?: true
    estado?: true
  }

  export type ClienteMinAggregateInputType = {
    idCli?: true
    nombre?: true
    apellidos?: true
    email?: true
    direccion?: true
    telefono?: true
    tipoDoc?: true
    cedula?: true
    fecha_nac?: true
    estado?: true
    constrasena?: true
    createdAt?: true
  }

  export type ClienteMaxAggregateInputType = {
    idCli?: true
    nombre?: true
    apellidos?: true
    email?: true
    direccion?: true
    telefono?: true
    tipoDoc?: true
    cedula?: true
    fecha_nac?: true
    estado?: true
    constrasena?: true
    createdAt?: true
  }

  export type ClienteCountAggregateInputType = {
    idCli?: true
    nombre?: true
    apellidos?: true
    email?: true
    direccion?: true
    telefono?: true
    tipoDoc?: true
    cedula?: true
    fecha_nac?: true
    estado?: true
    constrasena?: true
    createdAt?: true
    _all?: true
  }

  export type ClienteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cliente to aggregate.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned clientes
    **/
    _count?: true | ClienteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClienteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClienteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClienteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClienteMaxAggregateInputType
  }

  export type GetClienteAggregateType<T extends ClienteAggregateArgs> = {
        [P in keyof T & keyof AggregateCliente]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCliente[P]>
      : GetScalarType<T[P], AggregateCliente[P]>
  }




  export type clienteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: clienteWhereInput
    orderBy?: clienteOrderByWithAggregationInput | clienteOrderByWithAggregationInput[]
    by: ClienteScalarFieldEnum[] | ClienteScalarFieldEnum
    having?: clienteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClienteCountAggregateInputType | true
    _avg?: ClienteAvgAggregateInputType
    _sum?: ClienteSumAggregateInputType
    _min?: ClienteMinAggregateInputType
    _max?: ClienteMaxAggregateInputType
  }

  export type ClienteGroupByOutputType = {
    idCli: number
    nombre: string | null
    apellidos: string | null
    email: string | null
    direccion: string | null
    telefono: string | null
    tipoDoc: string | null
    cedula: string | null
    fecha_nac: string | null
    estado: number | null
    constrasena: string | null
    createdAt: Date
    _count: ClienteCountAggregateOutputType | null
    _avg: ClienteAvgAggregateOutputType | null
    _sum: ClienteSumAggregateOutputType | null
    _min: ClienteMinAggregateOutputType | null
    _max: ClienteMaxAggregateOutputType | null
  }

  type GetClienteGroupByPayload<T extends clienteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClienteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClienteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClienteGroupByOutputType[P]>
            : GetScalarType<T[P], ClienteGroupByOutputType[P]>
        }
      >
    >


  export type clienteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCli?: boolean
    nombre?: boolean
    apellidos?: boolean
    email?: boolean
    direccion?: boolean
    telefono?: boolean
    tipoDoc?: boolean
    cedula?: boolean
    fecha_nac?: boolean
    estado?: boolean
    constrasena?: boolean
    createdAt?: boolean
    obras?: boolean | cliente$obrasArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cliente"]>

  export type clienteSelectScalar = {
    idCli?: boolean
    nombre?: boolean
    apellidos?: boolean
    email?: boolean
    direccion?: boolean
    telefono?: boolean
    tipoDoc?: boolean
    cedula?: boolean
    fecha_nac?: boolean
    estado?: boolean
    constrasena?: boolean
    createdAt?: boolean
  }

  export type clienteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obras?: boolean | cliente$obrasArgs<ExtArgs>
    _count?: boolean | ClienteCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $clientePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cliente"
    objects: {
      obras: Prisma.$obrasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCli: number
      nombre: string | null
      apellidos: string | null
      email: string | null
      direccion: string | null
      telefono: string | null
      tipoDoc: string | null
      cedula: string | null
      fecha_nac: string | null
      estado: number | null
      constrasena: string | null
      createdAt: Date
    }, ExtArgs["result"]["cliente"]>
    composites: {}
  }


  type clienteGetPayload<S extends boolean | null | undefined | clienteDefaultArgs> = $Result.GetResult<Prisma.$clientePayload, S>

  type clienteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<clienteFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ClienteCountAggregateInputType | true
    }

  export interface clienteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cliente'], meta: { name: 'cliente' } }
    /**
     * Find zero or one Cliente that matches the filter.
     * @param {clienteFindUniqueArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends clienteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, clienteFindUniqueArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cliente that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {clienteFindUniqueOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends clienteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cliente that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends clienteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindFirstArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cliente that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindFirstOrThrowArgs} args - Arguments to find a Cliente
     * @example
     * // Get one Cliente
     * const cliente = await prisma.cliente.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends clienteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.cliente.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.cliente.findMany({ take: 10 })
     * 
     * // Only select the `idCli`
     * const clienteWithIdCliOnly = await prisma.cliente.findMany({ select: { idCli: true } })
     * 
    **/
    findMany<T extends clienteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cliente.
     * @param {clienteCreateArgs} args - Arguments to create a Cliente.
     * @example
     * // Create one Cliente
     * const Cliente = await prisma.cliente.create({
     *   data: {
     *     // ... data to create a Cliente
     *   }
     * })
     * 
    **/
    create<T extends clienteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, clienteCreateArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clientes.
     *     @param {clienteCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const cliente = await prisma.cliente.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends clienteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cliente.
     * @param {clienteDeleteArgs} args - Arguments to delete one Cliente.
     * @example
     * // Delete one Cliente
     * const Cliente = await prisma.cliente.delete({
     *   where: {
     *     // ... filter to delete one Cliente
     *   }
     * })
     * 
    **/
    delete<T extends clienteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, clienteDeleteArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cliente.
     * @param {clienteUpdateArgs} args - Arguments to update one Cliente.
     * @example
     * // Update one Cliente
     * const cliente = await prisma.cliente.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends clienteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpdateArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {clienteDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.cliente.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends clienteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, clienteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const cliente = await prisma.cliente.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends clienteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cliente.
     * @param {clienteUpsertArgs} args - Arguments to update or create a Cliente.
     * @example
     * // Update or create a Cliente
     * const cliente = await prisma.cliente.upsert({
     *   create: {
     *     // ... data to create a Cliente
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cliente we want to update
     *   }
     * })
    **/
    upsert<T extends clienteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, clienteUpsertArgs<ExtArgs>>
    ): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.cliente.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends clienteCountArgs>(
      args?: Subset<T, clienteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClienteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClienteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClienteAggregateArgs>(args: Subset<T, ClienteAggregateArgs>): Prisma.PrismaPromise<GetClienteAggregateType<T>>

    /**
     * Group by Cliente.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {clienteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends clienteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: clienteGroupByArgs['orderBy'] }
        : { orderBy?: clienteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, clienteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClienteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cliente model
   */
  readonly fields: clienteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cliente.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__clienteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    obras<T extends cliente$obrasArgs<ExtArgs> = {}>(args?: Subset<T, cliente$obrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cliente model
   */ 
  interface clienteFieldRefs {
    readonly idCli: FieldRef<"cliente", 'Int'>
    readonly nombre: FieldRef<"cliente", 'String'>
    readonly apellidos: FieldRef<"cliente", 'String'>
    readonly email: FieldRef<"cliente", 'String'>
    readonly direccion: FieldRef<"cliente", 'String'>
    readonly telefono: FieldRef<"cliente", 'String'>
    readonly tipoDoc: FieldRef<"cliente", 'String'>
    readonly cedula: FieldRef<"cliente", 'String'>
    readonly fecha_nac: FieldRef<"cliente", 'String'>
    readonly estado: FieldRef<"cliente", 'Int'>
    readonly constrasena: FieldRef<"cliente", 'String'>
    readonly createdAt: FieldRef<"cliente", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * cliente findUnique
   */
  export type clienteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente findUniqueOrThrow
   */
  export type clienteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente findFirst
   */
  export type clienteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente findFirstOrThrow
   */
  export type clienteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which cliente to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of clientes.
     */
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente findMany
   */
  export type clienteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter, which clientes to fetch.
     */
    where?: clienteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of clientes to fetch.
     */
    orderBy?: clienteOrderByWithRelationInput | clienteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing clientes.
     */
    cursor?: clienteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` clientes.
     */
    skip?: number
    distinct?: ClienteScalarFieldEnum | ClienteScalarFieldEnum[]
  }


  /**
   * cliente create
   */
  export type clienteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to create a cliente.
     */
    data?: XOR<clienteCreateInput, clienteUncheckedCreateInput>
  }


  /**
   * cliente createMany
   */
  export type clienteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many clientes.
     */
    data: clienteCreateManyInput | clienteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cliente update
   */
  export type clienteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The data needed to update a cliente.
     */
    data: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
    /**
     * Choose, which cliente to update.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente updateMany
   */
  export type clienteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update clientes.
     */
    data: XOR<clienteUpdateManyMutationInput, clienteUncheckedUpdateManyInput>
    /**
     * Filter which clientes to update
     */
    where?: clienteWhereInput
  }


  /**
   * cliente upsert
   */
  export type clienteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * The filter to search for the cliente to update in case it exists.
     */
    where: clienteWhereUniqueInput
    /**
     * In case the cliente found by the `where` argument doesn't exist, create a new cliente with this data.
     */
    create: XOR<clienteCreateInput, clienteUncheckedCreateInput>
    /**
     * In case the cliente was found with the provided `where` argument, update it with this data.
     */
    update: XOR<clienteUpdateInput, clienteUncheckedUpdateInput>
  }


  /**
   * cliente delete
   */
  export type clienteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    /**
     * Filter which cliente to delete.
     */
    where: clienteWhereUniqueInput
  }


  /**
   * cliente deleteMany
   */
  export type clienteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which clientes to delete
     */
    where?: clienteWhereInput
  }


  /**
   * cliente.obras
   */
  export type cliente$obrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    where?: obrasWhereInput
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    cursor?: obrasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObrasScalarFieldEnum | ObrasScalarFieldEnum[]
  }


  /**
   * cliente without action
   */
  export type clienteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
  }



  /**
   * Model compras
   */

  export type AggregateCompras = {
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  export type ComprasAvgAggregateOutputType = {
    idCom: number | null
    total_compra: number | null
    idProv: number | null
  }

  export type ComprasSumAggregateOutputType = {
    idCom: number | null
    total_compra: number | null
    idProv: number | null
  }

  export type ComprasMinAggregateOutputType = {
    idCom: number | null
    fecha: string | null
    imagen: string | null
    total_compra: number | null
    codigoFactura: string | null
    idProv: number | null
  }

  export type ComprasMaxAggregateOutputType = {
    idCom: number | null
    fecha: string | null
    imagen: string | null
    total_compra: number | null
    codigoFactura: string | null
    idProv: number | null
  }

  export type ComprasCountAggregateOutputType = {
    idCom: number
    fecha: number
    imagen: number
    total_compra: number
    codigoFactura: number
    idProv: number
    _all: number
  }


  export type ComprasAvgAggregateInputType = {
    idCom?: true
    total_compra?: true
    idProv?: true
  }

  export type ComprasSumAggregateInputType = {
    idCom?: true
    total_compra?: true
    idProv?: true
  }

  export type ComprasMinAggregateInputType = {
    idCom?: true
    fecha?: true
    imagen?: true
    total_compra?: true
    codigoFactura?: true
    idProv?: true
  }

  export type ComprasMaxAggregateInputType = {
    idCom?: true
    fecha?: true
    imagen?: true
    total_compra?: true
    codigoFactura?: true
    idProv?: true
  }

  export type ComprasCountAggregateInputType = {
    idCom?: true
    fecha?: true
    imagen?: true
    total_compra?: true
    codigoFactura?: true
    idProv?: true
    _all?: true
  }

  export type ComprasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to aggregate.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned compras
    **/
    _count?: true | ComprasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComprasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComprasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComprasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComprasMaxAggregateInputType
  }

  export type GetComprasAggregateType<T extends ComprasAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras[P]>
      : GetScalarType<T[P], AggregateCompras[P]>
  }




  export type comprasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithAggregationInput | comprasOrderByWithAggregationInput[]
    by: ComprasScalarFieldEnum[] | ComprasScalarFieldEnum
    having?: comprasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComprasCountAggregateInputType | true
    _avg?: ComprasAvgAggregateInputType
    _sum?: ComprasSumAggregateInputType
    _min?: ComprasMinAggregateInputType
    _max?: ComprasMaxAggregateInputType
  }

  export type ComprasGroupByOutputType = {
    idCom: number
    fecha: string | null
    imagen: string | null
    total_compra: number | null
    codigoFactura: string | null
    idProv: number
    _count: ComprasCountAggregateOutputType | null
    _avg: ComprasAvgAggregateOutputType | null
    _sum: ComprasSumAggregateOutputType | null
    _min: ComprasMinAggregateOutputType | null
    _max: ComprasMaxAggregateOutputType | null
  }

  type GetComprasGroupByPayload<T extends comprasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComprasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComprasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComprasGroupByOutputType[P]>
            : GetScalarType<T[P], ComprasGroupByOutputType[P]>
        }
      >
    >


  export type comprasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCom?: boolean
    fecha?: boolean
    imagen?: boolean
    total_compra?: boolean
    codigoFactura?: boolean
    idProv?: boolean
    proveedor?: boolean | proveedorDefaultArgs<ExtArgs>
    compras_detalle?: boolean | compras$compras_detalleArgs<ExtArgs>
    _count?: boolean | ComprasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["compras"]>

  export type comprasSelectScalar = {
    idCom?: boolean
    fecha?: boolean
    imagen?: boolean
    total_compra?: boolean
    codigoFactura?: boolean
    idProv?: boolean
  }

  export type comprasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proveedor?: boolean | proveedorDefaultArgs<ExtArgs>
    compras_detalle?: boolean | compras$compras_detalleArgs<ExtArgs>
    _count?: boolean | ComprasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $comprasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compras"
    objects: {
      proveedor: Prisma.$proveedorPayload<ExtArgs>
      compras_detalle: Prisma.$compras_detallePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCom: number
      fecha: string | null
      imagen: string | null
      total_compra: number | null
      codigoFactura: string | null
      idProv: number
    }, ExtArgs["result"]["compras"]>
    composites: {}
  }


  type comprasGetPayload<S extends boolean | null | undefined | comprasDefaultArgs> = $Result.GetResult<Prisma.$comprasPayload, S>

  type comprasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<comprasFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ComprasCountAggregateInputType | true
    }

  export interface comprasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compras'], meta: { name: 'compras' } }
    /**
     * Find zero or one Compras that matches the filter.
     * @param {comprasFindUniqueArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends comprasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, comprasFindUniqueArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Compras that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {comprasFindUniqueOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends comprasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends comprasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasFindFirstArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Compras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindFirstOrThrowArgs} args - Arguments to find a Compras
     * @example
     * // Get one Compras
     * const compras = await prisma.compras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends comprasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Compras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras
     * const compras = await prisma.compras.findMany()
     * 
     * // Get first 10 Compras
     * const compras = await prisma.compras.findMany({ take: 10 })
     * 
     * // Only select the `idCom`
     * const comprasWithIdComOnly = await prisma.compras.findMany({ select: { idCom: true } })
     * 
    **/
    findMany<T extends comprasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Compras.
     * @param {comprasCreateArgs} args - Arguments to create a Compras.
     * @example
     * // Create one Compras
     * const Compras = await prisma.compras.create({
     *   data: {
     *     // ... data to create a Compras
     *   }
     * })
     * 
    **/
    create<T extends comprasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, comprasCreateArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Compras.
     *     @param {comprasCreateManyArgs} args - Arguments to create many Compras.
     *     @example
     *     // Create many Compras
     *     const compras = await prisma.compras.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends comprasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compras.
     * @param {comprasDeleteArgs} args - Arguments to delete one Compras.
     * @example
     * // Delete one Compras
     * const Compras = await prisma.compras.delete({
     *   where: {
     *     // ... filter to delete one Compras
     *   }
     * })
     * 
    **/
    delete<T extends comprasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, comprasDeleteArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Compras.
     * @param {comprasUpdateArgs} args - Arguments to update one Compras.
     * @example
     * // Update one Compras
     * const compras = await prisma.compras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends comprasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, comprasUpdateArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Compras.
     * @param {comprasDeleteManyArgs} args - Arguments to filter Compras to delete.
     * @example
     * // Delete a few Compras
     * const { count } = await prisma.compras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends comprasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, comprasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras
     * const compras = await prisma.compras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends comprasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, comprasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compras.
     * @param {comprasUpsertArgs} args - Arguments to update or create a Compras.
     * @example
     * // Update or create a Compras
     * const compras = await prisma.compras.upsert({
     *   create: {
     *     // ... data to create a Compras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras we want to update
     *   }
     * })
    **/
    upsert<T extends comprasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, comprasUpsertArgs<ExtArgs>>
    ): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasCountArgs} args - Arguments to filter Compras to count.
     * @example
     * // Count the number of Compras
     * const count = await prisma.compras.count({
     *   where: {
     *     // ... the filter for the Compras we want to count
     *   }
     * })
    **/
    count<T extends comprasCountArgs>(
      args?: Subset<T, comprasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComprasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComprasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComprasAggregateArgs>(args: Subset<T, ComprasAggregateArgs>): Prisma.PrismaPromise<GetComprasAggregateType<T>>

    /**
     * Group by Compras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comprasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comprasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comprasGroupByArgs['orderBy'] }
        : { orderBy?: comprasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comprasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComprasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compras model
   */
  readonly fields: comprasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comprasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    proveedor<T extends proveedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, proveedorDefaultArgs<ExtArgs>>): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    compras_detalle<T extends compras$compras_detalleArgs<ExtArgs> = {}>(args?: Subset<T, compras$compras_detalleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the compras model
   */ 
  interface comprasFieldRefs {
    readonly idCom: FieldRef<"compras", 'Int'>
    readonly fecha: FieldRef<"compras", 'String'>
    readonly imagen: FieldRef<"compras", 'String'>
    readonly total_compra: FieldRef<"compras", 'Int'>
    readonly codigoFactura: FieldRef<"compras", 'String'>
    readonly idProv: FieldRef<"compras", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * compras findUnique
   */
  export type comprasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }


  /**
   * compras findUniqueOrThrow
   */
  export type comprasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where: comprasWhereUniqueInput
  }


  /**
   * compras findFirst
   */
  export type comprasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }


  /**
   * compras findFirstOrThrow
   */
  export type comprasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras.
     */
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }


  /**
   * compras findMany
   */
  export type comprasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter, which compras to fetch.
     */
    where?: comprasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras to fetch.
     */
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing compras.
     */
    cursor?: comprasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras.
     */
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }


  /**
   * compras create
   */
  export type comprasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to create a compras.
     */
    data: XOR<comprasCreateInput, comprasUncheckedCreateInput>
  }


  /**
   * compras createMany
   */
  export type comprasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many compras.
     */
    data: comprasCreateManyInput | comprasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * compras update
   */
  export type comprasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The data needed to update a compras.
     */
    data: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
    /**
     * Choose, which compras to update.
     */
    where: comprasWhereUniqueInput
  }


  /**
   * compras updateMany
   */
  export type comprasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update compras.
     */
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyInput>
    /**
     * Filter which compras to update
     */
    where?: comprasWhereInput
  }


  /**
   * compras upsert
   */
  export type comprasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * The filter to search for the compras to update in case it exists.
     */
    where: comprasWhereUniqueInput
    /**
     * In case the compras found by the `where` argument doesn't exist, create a new compras with this data.
     */
    create: XOR<comprasCreateInput, comprasUncheckedCreateInput>
    /**
     * In case the compras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comprasUpdateInput, comprasUncheckedUpdateInput>
  }


  /**
   * compras delete
   */
  export type comprasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    /**
     * Filter which compras to delete.
     */
    where: comprasWhereUniqueInput
  }


  /**
   * compras deleteMany
   */
  export type comprasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras to delete
     */
    where?: comprasWhereInput
  }


  /**
   * compras.compras_detalle
   */
  export type compras$compras_detalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    where?: compras_detalleWhereInput
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    cursor?: compras_detalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Compras_detalleScalarFieldEnum | Compras_detalleScalarFieldEnum[]
  }


  /**
   * compras without action
   */
  export type comprasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
  }



  /**
   * Model compras_detalle
   */

  export type AggregateCompras_detalle = {
    _count: Compras_detalleCountAggregateOutputType | null
    _avg: Compras_detalleAvgAggregateOutputType | null
    _sum: Compras_detalleSumAggregateOutputType | null
    _min: Compras_detalleMinAggregateOutputType | null
    _max: Compras_detalleMaxAggregateOutputType | null
  }

  export type Compras_detalleAvgAggregateOutputType = {
    id: number | null
    idCompra: number | null
    idMat: number | null
    cantidad: number | null
    precio: number | null
    subtotal: number | null
  }

  export type Compras_detalleSumAggregateOutputType = {
    id: number | null
    idCompra: number | null
    idMat: number | null
    cantidad: number | null
    precio: number | null
    subtotal: number | null
  }

  export type Compras_detalleMinAggregateOutputType = {
    id: number | null
    idCompra: number | null
    idMat: number | null
    cantidad: number | null
    precio: number | null
    subtotal: number | null
  }

  export type Compras_detalleMaxAggregateOutputType = {
    id: number | null
    idCompra: number | null
    idMat: number | null
    cantidad: number | null
    precio: number | null
    subtotal: number | null
  }

  export type Compras_detalleCountAggregateOutputType = {
    id: number
    idCompra: number
    idMat: number
    cantidad: number
    precio: number
    subtotal: number
    _all: number
  }


  export type Compras_detalleAvgAggregateInputType = {
    id?: true
    idCompra?: true
    idMat?: true
    cantidad?: true
    precio?: true
    subtotal?: true
  }

  export type Compras_detalleSumAggregateInputType = {
    id?: true
    idCompra?: true
    idMat?: true
    cantidad?: true
    precio?: true
    subtotal?: true
  }

  export type Compras_detalleMinAggregateInputType = {
    id?: true
    idCompra?: true
    idMat?: true
    cantidad?: true
    precio?: true
    subtotal?: true
  }

  export type Compras_detalleMaxAggregateInputType = {
    id?: true
    idCompra?: true
    idMat?: true
    cantidad?: true
    precio?: true
    subtotal?: true
  }

  export type Compras_detalleCountAggregateInputType = {
    id?: true
    idCompra?: true
    idMat?: true
    cantidad?: true
    precio?: true
    subtotal?: true
    _all?: true
  }

  export type Compras_detalleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras_detalle to aggregate.
     */
    where?: compras_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras_detalles to fetch.
     */
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: compras_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned compras_detalles
    **/
    _count?: true | Compras_detalleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Compras_detalleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Compras_detalleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Compras_detalleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Compras_detalleMaxAggregateInputType
  }

  export type GetCompras_detalleAggregateType<T extends Compras_detalleAggregateArgs> = {
        [P in keyof T & keyof AggregateCompras_detalle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompras_detalle[P]>
      : GetScalarType<T[P], AggregateCompras_detalle[P]>
  }




  export type compras_detalleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: compras_detalleWhereInput
    orderBy?: compras_detalleOrderByWithAggregationInput | compras_detalleOrderByWithAggregationInput[]
    by: Compras_detalleScalarFieldEnum[] | Compras_detalleScalarFieldEnum
    having?: compras_detalleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Compras_detalleCountAggregateInputType | true
    _avg?: Compras_detalleAvgAggregateInputType
    _sum?: Compras_detalleSumAggregateInputType
    _min?: Compras_detalleMinAggregateInputType
    _max?: Compras_detalleMaxAggregateInputType
  }

  export type Compras_detalleGroupByOutputType = {
    id: number
    idCompra: number
    idMat: number | null
    cantidad: number | null
    precio: number | null
    subtotal: number | null
    _count: Compras_detalleCountAggregateOutputType | null
    _avg: Compras_detalleAvgAggregateOutputType | null
    _sum: Compras_detalleSumAggregateOutputType | null
    _min: Compras_detalleMinAggregateOutputType | null
    _max: Compras_detalleMaxAggregateOutputType | null
  }

  type GetCompras_detalleGroupByPayload<T extends compras_detalleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Compras_detalleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Compras_detalleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Compras_detalleGroupByOutputType[P]>
            : GetScalarType<T[P], Compras_detalleGroupByOutputType[P]>
        }
      >
    >


  export type compras_detalleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idCompra?: boolean
    idMat?: boolean
    cantidad?: boolean
    precio?: boolean
    subtotal?: boolean
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    materiales?: boolean | compras_detalle$materialesArgs<ExtArgs>
  }, ExtArgs["result"]["compras_detalle"]>

  export type compras_detalleSelectScalar = {
    id?: boolean
    idCompra?: boolean
    idMat?: boolean
    cantidad?: boolean
    precio?: boolean
    subtotal?: boolean
  }

  export type compras_detalleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | comprasDefaultArgs<ExtArgs>
    materiales?: boolean | compras_detalle$materialesArgs<ExtArgs>
  }


  export type $compras_detallePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "compras_detalle"
    objects: {
      compras: Prisma.$comprasPayload<ExtArgs>
      materiales: Prisma.$materialesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idCompra: number
      idMat: number | null
      cantidad: number | null
      precio: number | null
      subtotal: number | null
    }, ExtArgs["result"]["compras_detalle"]>
    composites: {}
  }


  type compras_detalleGetPayload<S extends boolean | null | undefined | compras_detalleDefaultArgs> = $Result.GetResult<Prisma.$compras_detallePayload, S>

  type compras_detalleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<compras_detalleFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Compras_detalleCountAggregateInputType | true
    }

  export interface compras_detalleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['compras_detalle'], meta: { name: 'compras_detalle' } }
    /**
     * Find zero or one Compras_detalle that matches the filter.
     * @param {compras_detalleFindUniqueArgs} args - Arguments to find a Compras_detalle
     * @example
     * // Get one Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends compras_detalleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleFindUniqueArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Compras_detalle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {compras_detalleFindUniqueOrThrowArgs} args - Arguments to find a Compras_detalle
     * @example
     * // Get one Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends compras_detalleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Compras_detalle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleFindFirstArgs} args - Arguments to find a Compras_detalle
     * @example
     * // Get one Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends compras_detalleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleFindFirstArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Compras_detalle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleFindFirstOrThrowArgs} args - Arguments to find a Compras_detalle
     * @example
     * // Get one Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends compras_detalleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Compras_detalles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compras_detalles
     * const compras_detalles = await prisma.compras_detalle.findMany()
     * 
     * // Get first 10 Compras_detalles
     * const compras_detalles = await prisma.compras_detalle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const compras_detalleWithIdOnly = await prisma.compras_detalle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends compras_detalleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Compras_detalle.
     * @param {compras_detalleCreateArgs} args - Arguments to create a Compras_detalle.
     * @example
     * // Create one Compras_detalle
     * const Compras_detalle = await prisma.compras_detalle.create({
     *   data: {
     *     // ... data to create a Compras_detalle
     *   }
     * })
     * 
    **/
    create<T extends compras_detalleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleCreateArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Compras_detalles.
     *     @param {compras_detalleCreateManyArgs} args - Arguments to create many Compras_detalles.
     *     @example
     *     // Create many Compras_detalles
     *     const compras_detalle = await prisma.compras_detalle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends compras_detalleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compras_detalle.
     * @param {compras_detalleDeleteArgs} args - Arguments to delete one Compras_detalle.
     * @example
     * // Delete one Compras_detalle
     * const Compras_detalle = await prisma.compras_detalle.delete({
     *   where: {
     *     // ... filter to delete one Compras_detalle
     *   }
     * })
     * 
    **/
    delete<T extends compras_detalleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleDeleteArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Compras_detalle.
     * @param {compras_detalleUpdateArgs} args - Arguments to update one Compras_detalle.
     * @example
     * // Update one Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends compras_detalleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleUpdateArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Compras_detalles.
     * @param {compras_detalleDeleteManyArgs} args - Arguments to filter Compras_detalles to delete.
     * @example
     * // Delete a few Compras_detalles
     * const { count } = await prisma.compras_detalle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends compras_detalleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, compras_detalleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compras_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compras_detalles
     * const compras_detalle = await prisma.compras_detalle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends compras_detalleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compras_detalle.
     * @param {compras_detalleUpsertArgs} args - Arguments to update or create a Compras_detalle.
     * @example
     * // Update or create a Compras_detalle
     * const compras_detalle = await prisma.compras_detalle.upsert({
     *   create: {
     *     // ... data to create a Compras_detalle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compras_detalle we want to update
     *   }
     * })
    **/
    upsert<T extends compras_detalleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, compras_detalleUpsertArgs<ExtArgs>>
    ): Prisma__compras_detalleClient<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Compras_detalles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleCountArgs} args - Arguments to filter Compras_detalles to count.
     * @example
     * // Count the number of Compras_detalles
     * const count = await prisma.compras_detalle.count({
     *   where: {
     *     // ... the filter for the Compras_detalles we want to count
     *   }
     * })
    **/
    count<T extends compras_detalleCountArgs>(
      args?: Subset<T, compras_detalleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Compras_detalleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compras_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Compras_detalleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Compras_detalleAggregateArgs>(args: Subset<T, Compras_detalleAggregateArgs>): Prisma.PrismaPromise<GetCompras_detalleAggregateType<T>>

    /**
     * Group by Compras_detalle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {compras_detalleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends compras_detalleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: compras_detalleGroupByArgs['orderBy'] }
        : { orderBy?: compras_detalleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, compras_detalleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompras_detalleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the compras_detalle model
   */
  readonly fields: compras_detalleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for compras_detalle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__compras_detalleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    compras<T extends comprasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, comprasDefaultArgs<ExtArgs>>): Prisma__comprasClient<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    materiales<T extends compras_detalle$materialesArgs<ExtArgs> = {}>(args?: Subset<T, compras_detalle$materialesArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the compras_detalle model
   */ 
  interface compras_detalleFieldRefs {
    readonly id: FieldRef<"compras_detalle", 'Int'>
    readonly idCompra: FieldRef<"compras_detalle", 'Int'>
    readonly idMat: FieldRef<"compras_detalle", 'Int'>
    readonly cantidad: FieldRef<"compras_detalle", 'Int'>
    readonly precio: FieldRef<"compras_detalle", 'Int'>
    readonly subtotal: FieldRef<"compras_detalle", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * compras_detalle findUnique
   */
  export type compras_detalleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter, which compras_detalle to fetch.
     */
    where: compras_detalleWhereUniqueInput
  }


  /**
   * compras_detalle findUniqueOrThrow
   */
  export type compras_detalleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter, which compras_detalle to fetch.
     */
    where: compras_detalleWhereUniqueInput
  }


  /**
   * compras_detalle findFirst
   */
  export type compras_detalleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter, which compras_detalle to fetch.
     */
    where?: compras_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras_detalles to fetch.
     */
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras_detalles.
     */
    cursor?: compras_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras_detalles.
     */
    distinct?: Compras_detalleScalarFieldEnum | Compras_detalleScalarFieldEnum[]
  }


  /**
   * compras_detalle findFirstOrThrow
   */
  export type compras_detalleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter, which compras_detalle to fetch.
     */
    where?: compras_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras_detalles to fetch.
     */
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for compras_detalles.
     */
    cursor?: compras_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras_detalles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of compras_detalles.
     */
    distinct?: Compras_detalleScalarFieldEnum | Compras_detalleScalarFieldEnum[]
  }


  /**
   * compras_detalle findMany
   */
  export type compras_detalleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter, which compras_detalles to fetch.
     */
    where?: compras_detalleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of compras_detalles to fetch.
     */
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing compras_detalles.
     */
    cursor?: compras_detalleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` compras_detalles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` compras_detalles.
     */
    skip?: number
    distinct?: Compras_detalleScalarFieldEnum | Compras_detalleScalarFieldEnum[]
  }


  /**
   * compras_detalle create
   */
  export type compras_detalleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * The data needed to create a compras_detalle.
     */
    data: XOR<compras_detalleCreateInput, compras_detalleUncheckedCreateInput>
  }


  /**
   * compras_detalle createMany
   */
  export type compras_detalleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many compras_detalles.
     */
    data: compras_detalleCreateManyInput | compras_detalleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * compras_detalle update
   */
  export type compras_detalleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * The data needed to update a compras_detalle.
     */
    data: XOR<compras_detalleUpdateInput, compras_detalleUncheckedUpdateInput>
    /**
     * Choose, which compras_detalle to update.
     */
    where: compras_detalleWhereUniqueInput
  }


  /**
   * compras_detalle updateMany
   */
  export type compras_detalleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update compras_detalles.
     */
    data: XOR<compras_detalleUpdateManyMutationInput, compras_detalleUncheckedUpdateManyInput>
    /**
     * Filter which compras_detalles to update
     */
    where?: compras_detalleWhereInput
  }


  /**
   * compras_detalle upsert
   */
  export type compras_detalleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * The filter to search for the compras_detalle to update in case it exists.
     */
    where: compras_detalleWhereUniqueInput
    /**
     * In case the compras_detalle found by the `where` argument doesn't exist, create a new compras_detalle with this data.
     */
    create: XOR<compras_detalleCreateInput, compras_detalleUncheckedCreateInput>
    /**
     * In case the compras_detalle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<compras_detalleUpdateInput, compras_detalleUncheckedUpdateInput>
  }


  /**
   * compras_detalle delete
   */
  export type compras_detalleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    /**
     * Filter which compras_detalle to delete.
     */
    where: compras_detalleWhereUniqueInput
  }


  /**
   * compras_detalle deleteMany
   */
  export type compras_detalleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which compras_detalles to delete
     */
    where?: compras_detalleWhereInput
  }


  /**
   * compras_detalle.materiales
   */
  export type compras_detalle$materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    where?: materialesWhereInput
  }


  /**
   * compras_detalle without action
   */
  export type compras_detalleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
  }



  /**
   * Model empleado
   */

  export type AggregateEmpleado = {
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  export type EmpleadoAvgAggregateOutputType = {
    idEmp: number | null
    estado: number | null
  }

  export type EmpleadoSumAggregateOutputType = {
    idEmp: number | null
    estado: number | null
  }

  export type EmpleadoMinAggregateOutputType = {
    idEmp: number | null
    nombre: string | null
    direccion: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    cedula: string | null
    tipoDoc: string | null
    apellidos: string | null
    contrasena: string | null
    createdAt: Date | null
  }

  export type EmpleadoMaxAggregateOutputType = {
    idEmp: number | null
    nombre: string | null
    direccion: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    cedula: string | null
    tipoDoc: string | null
    apellidos: string | null
    contrasena: string | null
    createdAt: Date | null
  }

  export type EmpleadoCountAggregateOutputType = {
    idEmp: number
    nombre: number
    direccion: number
    estado: number
    email: number
    telefono: number
    cedula: number
    tipoDoc: number
    apellidos: number
    contrasena: number
    createdAt: number
    _all: number
  }


  export type EmpleadoAvgAggregateInputType = {
    idEmp?: true
    estado?: true
  }

  export type EmpleadoSumAggregateInputType = {
    idEmp?: true
    estado?: true
  }

  export type EmpleadoMinAggregateInputType = {
    idEmp?: true
    nombre?: true
    direccion?: true
    estado?: true
    email?: true
    telefono?: true
    cedula?: true
    tipoDoc?: true
    apellidos?: true
    contrasena?: true
    createdAt?: true
  }

  export type EmpleadoMaxAggregateInputType = {
    idEmp?: true
    nombre?: true
    direccion?: true
    estado?: true
    email?: true
    telefono?: true
    cedula?: true
    tipoDoc?: true
    apellidos?: true
    contrasena?: true
    createdAt?: true
  }

  export type EmpleadoCountAggregateInputType = {
    idEmp?: true
    nombre?: true
    direccion?: true
    estado?: true
    email?: true
    telefono?: true
    cedula?: true
    tipoDoc?: true
    apellidos?: true
    contrasena?: true
    createdAt?: true
    _all?: true
  }

  export type EmpleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleado to aggregate.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleados
    **/
    _count?: true | EmpleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadoMaxAggregateInputType
  }

  export type GetEmpleadoAggregateType<T extends EmpleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado[P]>
      : GetScalarType<T[P], AggregateEmpleado[P]>
  }




  export type empleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleadoWhereInput
    orderBy?: empleadoOrderByWithAggregationInput | empleadoOrderByWithAggregationInput[]
    by: EmpleadoScalarFieldEnum[] | EmpleadoScalarFieldEnum
    having?: empleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadoCountAggregateInputType | true
    _avg?: EmpleadoAvgAggregateInputType
    _sum?: EmpleadoSumAggregateInputType
    _min?: EmpleadoMinAggregateInputType
    _max?: EmpleadoMaxAggregateInputType
  }

  export type EmpleadoGroupByOutputType = {
    idEmp: number
    nombre: string | null
    direccion: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    cedula: string | null
    tipoDoc: string | null
    apellidos: string | null
    contrasena: string | null
    createdAt: Date
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  type GetEmpleadoGroupByPayload<T extends empleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
        }
      >
    >


  export type empleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idEmp?: boolean
    nombre?: boolean
    direccion?: boolean
    estado?: boolean
    email?: boolean
    telefono?: boolean
    cedula?: boolean
    tipoDoc?: boolean
    apellidos?: boolean
    contrasena?: boolean
    createdAt?: boolean
    actividades_empleados?: boolean | empleado$actividades_empleadosArgs<ExtArgs>
    empleado_especialidad?: boolean | empleado$empleado_especialidadArgs<ExtArgs>
    obras?: boolean | empleado$obrasArgs<ExtArgs>
    rolpermisoempleado?: boolean | empleado$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | EmpleadoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleado"]>

  export type empleadoSelectScalar = {
    idEmp?: boolean
    nombre?: boolean
    direccion?: boolean
    estado?: boolean
    email?: boolean
    telefono?: boolean
    cedula?: boolean
    tipoDoc?: boolean
    apellidos?: boolean
    contrasena?: boolean
    createdAt?: boolean
  }

  export type empleadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_empleados?: boolean | empleado$actividades_empleadosArgs<ExtArgs>
    empleado_especialidad?: boolean | empleado$empleado_especialidadArgs<ExtArgs>
    obras?: boolean | empleado$obrasArgs<ExtArgs>
    rolpermisoempleado?: boolean | empleado$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | EmpleadoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $empleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empleado"
    objects: {
      actividades_empleados: Prisma.$actividades_empleadosPayload<ExtArgs>[]
      empleado_especialidad: Prisma.$empleado_especialidadPayload<ExtArgs>[]
      obras: Prisma.$obrasPayload<ExtArgs>[]
      rolpermisoempleado: Prisma.$rolpermisoempleadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idEmp: number
      nombre: string | null
      direccion: string | null
      estado: number | null
      email: string | null
      telefono: string | null
      cedula: string | null
      tipoDoc: string | null
      apellidos: string | null
      contrasena: string | null
      createdAt: Date
    }, ExtArgs["result"]["empleado"]>
    composites: {}
  }


  type empleadoGetPayload<S extends boolean | null | undefined | empleadoDefaultArgs> = $Result.GetResult<Prisma.$empleadoPayload, S>

  type empleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<empleadoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EmpleadoCountAggregateInputType | true
    }

  export interface empleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empleado'], meta: { name: 'empleado' } }
    /**
     * Find zero or one Empleado that matches the filter.
     * @param {empleadoFindUniqueArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empleadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoFindUniqueArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Empleado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {empleadoFindUniqueOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends empleadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindFirstArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empleadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoFindFirstArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Empleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindFirstOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends empleadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleado.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleado.findMany({ take: 10 })
     * 
     * // Only select the `idEmp`
     * const empleadoWithIdEmpOnly = await prisma.empleado.findMany({ select: { idEmp: true } })
     * 
    **/
    findMany<T extends empleadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Empleado.
     * @param {empleadoCreateArgs} args - Arguments to create a Empleado.
     * @example
     * // Create one Empleado
     * const Empleado = await prisma.empleado.create({
     *   data: {
     *     // ... data to create a Empleado
     *   }
     * })
     * 
    **/
    create<T extends empleadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoCreateArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Empleados.
     *     @param {empleadoCreateManyArgs} args - Arguments to create many Empleados.
     *     @example
     *     // Create many Empleados
     *     const empleado = await prisma.empleado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empleadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empleado.
     * @param {empleadoDeleteArgs} args - Arguments to delete one Empleado.
     * @example
     * // Delete one Empleado
     * const Empleado = await prisma.empleado.delete({
     *   where: {
     *     // ... filter to delete one Empleado
     *   }
     * })
     * 
    **/
    delete<T extends empleadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoDeleteArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Empleado.
     * @param {empleadoUpdateArgs} args - Arguments to update one Empleado.
     * @example
     * // Update one Empleado
     * const empleado = await prisma.empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empleadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoUpdateArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Empleados.
     * @param {empleadoDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empleadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empleadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleado.
     * @param {empleadoUpsertArgs} args - Arguments to update or create a Empleado.
     * @example
     * // Update or create a Empleado
     * const empleado = await prisma.empleado.upsert({
     *   create: {
     *     // ... data to create a Empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado we want to update
     *   }
     * })
    **/
    upsert<T extends empleadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, empleadoUpsertArgs<ExtArgs>>
    ): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleado.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends empleadoCountArgs>(
      args?: Subset<T, empleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadoAggregateArgs>(args: Subset<T, EmpleadoAggregateArgs>): Prisma.PrismaPromise<GetEmpleadoAggregateType<T>>

    /**
     * Group by Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empleadoGroupByArgs['orderBy'] }
        : { orderBy?: empleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empleado model
   */
  readonly fields: empleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    actividades_empleados<T extends empleado$actividades_empleadosArgs<ExtArgs> = {}>(args?: Subset<T, empleado$actividades_empleadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findMany'> | Null>;

    empleado_especialidad<T extends empleado$empleado_especialidadArgs<ExtArgs> = {}>(args?: Subset<T, empleado$empleado_especialidadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findMany'> | Null>;

    obras<T extends empleado$obrasArgs<ExtArgs> = {}>(args?: Subset<T, empleado$obrasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findMany'> | Null>;

    rolpermisoempleado<T extends empleado$rolpermisoempleadoArgs<ExtArgs> = {}>(args?: Subset<T, empleado$rolpermisoempleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the empleado model
   */ 
  interface empleadoFieldRefs {
    readonly idEmp: FieldRef<"empleado", 'Int'>
    readonly nombre: FieldRef<"empleado", 'String'>
    readonly direccion: FieldRef<"empleado", 'String'>
    readonly estado: FieldRef<"empleado", 'Int'>
    readonly email: FieldRef<"empleado", 'String'>
    readonly telefono: FieldRef<"empleado", 'String'>
    readonly cedula: FieldRef<"empleado", 'String'>
    readonly tipoDoc: FieldRef<"empleado", 'String'>
    readonly apellidos: FieldRef<"empleado", 'String'>
    readonly contrasena: FieldRef<"empleado", 'String'>
    readonly createdAt: FieldRef<"empleado", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * empleado findUnique
   */
  export type empleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado findUniqueOrThrow
   */
  export type empleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado findFirst
   */
  export type empleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * empleado findFirstOrThrow
   */
  export type empleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleado to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * empleado findMany
   */
  export type empleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter, which empleados to fetch.
     */
    where?: empleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleados to fetch.
     */
    orderBy?: empleadoOrderByWithRelationInput | empleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleados.
     */
    cursor?: empleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleados.
     */
    skip?: number
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * empleado create
   */
  export type empleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The data needed to create a empleado.
     */
    data?: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
  }


  /**
   * empleado createMany
   */
  export type empleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empleados.
     */
    data: empleadoCreateManyInput | empleadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * empleado update
   */
  export type empleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The data needed to update a empleado.
     */
    data: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
    /**
     * Choose, which empleado to update.
     */
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado updateMany
   */
  export type empleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empleados.
     */
    data: XOR<empleadoUpdateManyMutationInput, empleadoUncheckedUpdateManyInput>
    /**
     * Filter which empleados to update
     */
    where?: empleadoWhereInput
  }


  /**
   * empleado upsert
   */
  export type empleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * The filter to search for the empleado to update in case it exists.
     */
    where: empleadoWhereUniqueInput
    /**
     * In case the empleado found by the `where` argument doesn't exist, create a new empleado with this data.
     */
    create: XOR<empleadoCreateInput, empleadoUncheckedCreateInput>
    /**
     * In case the empleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empleadoUpdateInput, empleadoUncheckedUpdateInput>
  }


  /**
   * empleado delete
   */
  export type empleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    /**
     * Filter which empleado to delete.
     */
    where: empleadoWhereUniqueInput
  }


  /**
   * empleado deleteMany
   */
  export type empleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleados to delete
     */
    where?: empleadoWhereInput
  }


  /**
   * empleado.actividades_empleados
   */
  export type empleado$actividades_empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    where?: actividades_empleadosWhereInput
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    cursor?: actividades_empleadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Actividades_empleadosScalarFieldEnum | Actividades_empleadosScalarFieldEnum[]
  }


  /**
   * empleado.empleado_especialidad
   */
  export type empleado$empleado_especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    where?: empleado_especialidadWhereInput
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    cursor?: empleado_especialidadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Empleado_especialidadScalarFieldEnum | Empleado_especialidadScalarFieldEnum[]
  }


  /**
   * empleado.obras
   */
  export type empleado$obrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    where?: obrasWhereInput
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    cursor?: obrasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObrasScalarFieldEnum | ObrasScalarFieldEnum[]
  }


  /**
   * empleado.rolpermisoempleado
   */
  export type empleado$rolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    where?: rolpermisoempleadoWhereInput
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    cursor?: rolpermisoempleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * empleado without action
   */
  export type empleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
  }



  /**
   * Model empleado_especialidad
   */

  export type AggregateEmpleado_especialidad = {
    _count: Empleado_especialidadCountAggregateOutputType | null
    _avg: Empleado_especialidadAvgAggregateOutputType | null
    _sum: Empleado_especialidadSumAggregateOutputType | null
    _min: Empleado_especialidadMinAggregateOutputType | null
    _max: Empleado_especialidadMaxAggregateOutputType | null
  }

  export type Empleado_especialidadAvgAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idEsp: number | null
  }

  export type Empleado_especialidadSumAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idEsp: number | null
  }

  export type Empleado_especialidadMinAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idEsp: number | null
  }

  export type Empleado_especialidadMaxAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idEsp: number | null
  }

  export type Empleado_especialidadCountAggregateOutputType = {
    id: number
    idEmp: number
    idEsp: number
    _all: number
  }


  export type Empleado_especialidadAvgAggregateInputType = {
    id?: true
    idEmp?: true
    idEsp?: true
  }

  export type Empleado_especialidadSumAggregateInputType = {
    id?: true
    idEmp?: true
    idEsp?: true
  }

  export type Empleado_especialidadMinAggregateInputType = {
    id?: true
    idEmp?: true
    idEsp?: true
  }

  export type Empleado_especialidadMaxAggregateInputType = {
    id?: true
    idEmp?: true
    idEsp?: true
  }

  export type Empleado_especialidadCountAggregateInputType = {
    id?: true
    idEmp?: true
    idEsp?: true
    _all?: true
  }

  export type Empleado_especialidadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleado_especialidad to aggregate.
     */
    where?: empleado_especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleado_especialidads to fetch.
     */
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: empleado_especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleado_especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleado_especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned empleado_especialidads
    **/
    _count?: true | Empleado_especialidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Empleado_especialidadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Empleado_especialidadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Empleado_especialidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Empleado_especialidadMaxAggregateInputType
  }

  export type GetEmpleado_especialidadAggregateType<T extends Empleado_especialidadAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado_especialidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado_especialidad[P]>
      : GetScalarType<T[P], AggregateEmpleado_especialidad[P]>
  }




  export type empleado_especialidadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: empleado_especialidadWhereInput
    orderBy?: empleado_especialidadOrderByWithAggregationInput | empleado_especialidadOrderByWithAggregationInput[]
    by: Empleado_especialidadScalarFieldEnum[] | Empleado_especialidadScalarFieldEnum
    having?: empleado_especialidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Empleado_especialidadCountAggregateInputType | true
    _avg?: Empleado_especialidadAvgAggregateInputType
    _sum?: Empleado_especialidadSumAggregateInputType
    _min?: Empleado_especialidadMinAggregateInputType
    _max?: Empleado_especialidadMaxAggregateInputType
  }

  export type Empleado_especialidadGroupByOutputType = {
    id: number
    idEmp: number
    idEsp: number
    _count: Empleado_especialidadCountAggregateOutputType | null
    _avg: Empleado_especialidadAvgAggregateOutputType | null
    _sum: Empleado_especialidadSumAggregateOutputType | null
    _min: Empleado_especialidadMinAggregateOutputType | null
    _max: Empleado_especialidadMaxAggregateOutputType | null
  }

  type GetEmpleado_especialidadGroupByPayload<T extends empleado_especialidadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Empleado_especialidadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Empleado_especialidadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Empleado_especialidadGroupByOutputType[P]>
            : GetScalarType<T[P], Empleado_especialidadGroupByOutputType[P]>
        }
      >
    >


  export type empleado_especialidadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idEmp?: boolean
    idEsp?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    especialidad?: boolean | especialidadDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["empleado_especialidad"]>

  export type empleado_especialidadSelectScalar = {
    id?: boolean
    idEmp?: boolean
    idEsp?: boolean
  }

  export type empleado_especialidadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    especialidad?: boolean | especialidadDefaultArgs<ExtArgs>
  }


  export type $empleado_especialidadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "empleado_especialidad"
    objects: {
      empleado: Prisma.$empleadoPayload<ExtArgs>
      especialidad: Prisma.$especialidadPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idEmp: number
      idEsp: number
    }, ExtArgs["result"]["empleado_especialidad"]>
    composites: {}
  }


  type empleado_especialidadGetPayload<S extends boolean | null | undefined | empleado_especialidadDefaultArgs> = $Result.GetResult<Prisma.$empleado_especialidadPayload, S>

  type empleado_especialidadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<empleado_especialidadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Empleado_especialidadCountAggregateInputType | true
    }

  export interface empleado_especialidadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['empleado_especialidad'], meta: { name: 'empleado_especialidad' } }
    /**
     * Find zero or one Empleado_especialidad that matches the filter.
     * @param {empleado_especialidadFindUniqueArgs} args - Arguments to find a Empleado_especialidad
     * @example
     * // Get one Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends empleado_especialidadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadFindUniqueArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Empleado_especialidad that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {empleado_especialidadFindUniqueOrThrowArgs} args - Arguments to find a Empleado_especialidad
     * @example
     * // Get one Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends empleado_especialidadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Empleado_especialidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadFindFirstArgs} args - Arguments to find a Empleado_especialidad
     * @example
     * // Get one Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends empleado_especialidadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadFindFirstArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Empleado_especialidad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadFindFirstOrThrowArgs} args - Arguments to find a Empleado_especialidad
     * @example
     * // Get one Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends empleado_especialidadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Empleado_especialidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleado_especialidads
     * const empleado_especialidads = await prisma.empleado_especialidad.findMany()
     * 
     * // Get first 10 Empleado_especialidads
     * const empleado_especialidads = await prisma.empleado_especialidad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empleado_especialidadWithIdOnly = await prisma.empleado_especialidad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends empleado_especialidadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Empleado_especialidad.
     * @param {empleado_especialidadCreateArgs} args - Arguments to create a Empleado_especialidad.
     * @example
     * // Create one Empleado_especialidad
     * const Empleado_especialidad = await prisma.empleado_especialidad.create({
     *   data: {
     *     // ... data to create a Empleado_especialidad
     *   }
     * })
     * 
    **/
    create<T extends empleado_especialidadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadCreateArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Empleado_especialidads.
     *     @param {empleado_especialidadCreateManyArgs} args - Arguments to create many Empleado_especialidads.
     *     @example
     *     // Create many Empleado_especialidads
     *     const empleado_especialidad = await prisma.empleado_especialidad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends empleado_especialidadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empleado_especialidad.
     * @param {empleado_especialidadDeleteArgs} args - Arguments to delete one Empleado_especialidad.
     * @example
     * // Delete one Empleado_especialidad
     * const Empleado_especialidad = await prisma.empleado_especialidad.delete({
     *   where: {
     *     // ... filter to delete one Empleado_especialidad
     *   }
     * })
     * 
    **/
    delete<T extends empleado_especialidadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadDeleteArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Empleado_especialidad.
     * @param {empleado_especialidadUpdateArgs} args - Arguments to update one Empleado_especialidad.
     * @example
     * // Update one Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends empleado_especialidadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadUpdateArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Empleado_especialidads.
     * @param {empleado_especialidadDeleteManyArgs} args - Arguments to filter Empleado_especialidads to delete.
     * @example
     * // Delete a few Empleado_especialidads
     * const { count } = await prisma.empleado_especialidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends empleado_especialidadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, empleado_especialidadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleado_especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleado_especialidads
     * const empleado_especialidad = await prisma.empleado_especialidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends empleado_especialidadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleado_especialidad.
     * @param {empleado_especialidadUpsertArgs} args - Arguments to update or create a Empleado_especialidad.
     * @example
     * // Update or create a Empleado_especialidad
     * const empleado_especialidad = await prisma.empleado_especialidad.upsert({
     *   create: {
     *     // ... data to create a Empleado_especialidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado_especialidad we want to update
     *   }
     * })
    **/
    upsert<T extends empleado_especialidadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, empleado_especialidadUpsertArgs<ExtArgs>>
    ): Prisma__empleado_especialidadClient<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Empleado_especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadCountArgs} args - Arguments to filter Empleado_especialidads to count.
     * @example
     * // Count the number of Empleado_especialidads
     * const count = await prisma.empleado_especialidad.count({
     *   where: {
     *     // ... the filter for the Empleado_especialidads we want to count
     *   }
     * })
    **/
    count<T extends empleado_especialidadCountArgs>(
      args?: Subset<T, empleado_especialidadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Empleado_especialidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado_especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Empleado_especialidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Empleado_especialidadAggregateArgs>(args: Subset<T, Empleado_especialidadAggregateArgs>): Prisma.PrismaPromise<GetEmpleado_especialidadAggregateType<T>>

    /**
     * Group by Empleado_especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {empleado_especialidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends empleado_especialidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: empleado_especialidadGroupByArgs['orderBy'] }
        : { orderBy?: empleado_especialidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, empleado_especialidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleado_especialidadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the empleado_especialidad model
   */
  readonly fields: empleado_especialidadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for empleado_especialidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__empleado_especialidadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    especialidad<T extends especialidadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, especialidadDefaultArgs<ExtArgs>>): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the empleado_especialidad model
   */ 
  interface empleado_especialidadFieldRefs {
    readonly id: FieldRef<"empleado_especialidad", 'Int'>
    readonly idEmp: FieldRef<"empleado_especialidad", 'Int'>
    readonly idEsp: FieldRef<"empleado_especialidad", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * empleado_especialidad findUnique
   */
  export type empleado_especialidadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter, which empleado_especialidad to fetch.
     */
    where: empleado_especialidadWhereUniqueInput
  }


  /**
   * empleado_especialidad findUniqueOrThrow
   */
  export type empleado_especialidadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter, which empleado_especialidad to fetch.
     */
    where: empleado_especialidadWhereUniqueInput
  }


  /**
   * empleado_especialidad findFirst
   */
  export type empleado_especialidadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter, which empleado_especialidad to fetch.
     */
    where?: empleado_especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleado_especialidads to fetch.
     */
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleado_especialidads.
     */
    cursor?: empleado_especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleado_especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleado_especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleado_especialidads.
     */
    distinct?: Empleado_especialidadScalarFieldEnum | Empleado_especialidadScalarFieldEnum[]
  }


  /**
   * empleado_especialidad findFirstOrThrow
   */
  export type empleado_especialidadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter, which empleado_especialidad to fetch.
     */
    where?: empleado_especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleado_especialidads to fetch.
     */
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for empleado_especialidads.
     */
    cursor?: empleado_especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleado_especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleado_especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of empleado_especialidads.
     */
    distinct?: Empleado_especialidadScalarFieldEnum | Empleado_especialidadScalarFieldEnum[]
  }


  /**
   * empleado_especialidad findMany
   */
  export type empleado_especialidadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter, which empleado_especialidads to fetch.
     */
    where?: empleado_especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of empleado_especialidads to fetch.
     */
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing empleado_especialidads.
     */
    cursor?: empleado_especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` empleado_especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` empleado_especialidads.
     */
    skip?: number
    distinct?: Empleado_especialidadScalarFieldEnum | Empleado_especialidadScalarFieldEnum[]
  }


  /**
   * empleado_especialidad create
   */
  export type empleado_especialidadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * The data needed to create a empleado_especialidad.
     */
    data: XOR<empleado_especialidadCreateInput, empleado_especialidadUncheckedCreateInput>
  }


  /**
   * empleado_especialidad createMany
   */
  export type empleado_especialidadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many empleado_especialidads.
     */
    data: empleado_especialidadCreateManyInput | empleado_especialidadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * empleado_especialidad update
   */
  export type empleado_especialidadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * The data needed to update a empleado_especialidad.
     */
    data: XOR<empleado_especialidadUpdateInput, empleado_especialidadUncheckedUpdateInput>
    /**
     * Choose, which empleado_especialidad to update.
     */
    where: empleado_especialidadWhereUniqueInput
  }


  /**
   * empleado_especialidad updateMany
   */
  export type empleado_especialidadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update empleado_especialidads.
     */
    data: XOR<empleado_especialidadUpdateManyMutationInput, empleado_especialidadUncheckedUpdateManyInput>
    /**
     * Filter which empleado_especialidads to update
     */
    where?: empleado_especialidadWhereInput
  }


  /**
   * empleado_especialidad upsert
   */
  export type empleado_especialidadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * The filter to search for the empleado_especialidad to update in case it exists.
     */
    where: empleado_especialidadWhereUniqueInput
    /**
     * In case the empleado_especialidad found by the `where` argument doesn't exist, create a new empleado_especialidad with this data.
     */
    create: XOR<empleado_especialidadCreateInput, empleado_especialidadUncheckedCreateInput>
    /**
     * In case the empleado_especialidad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<empleado_especialidadUpdateInput, empleado_especialidadUncheckedUpdateInput>
  }


  /**
   * empleado_especialidad delete
   */
  export type empleado_especialidadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    /**
     * Filter which empleado_especialidad to delete.
     */
    where: empleado_especialidadWhereUniqueInput
  }


  /**
   * empleado_especialidad deleteMany
   */
  export type empleado_especialidadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which empleado_especialidads to delete
     */
    where?: empleado_especialidadWhereInput
  }


  /**
   * empleado_especialidad without action
   */
  export type empleado_especialidadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
  }



  /**
   * Model especialidad
   */

  export type AggregateEspecialidad = {
    _count: EspecialidadCountAggregateOutputType | null
    _avg: EspecialidadAvgAggregateOutputType | null
    _sum: EspecialidadSumAggregateOutputType | null
    _min: EspecialidadMinAggregateOutputType | null
    _max: EspecialidadMaxAggregateOutputType | null
  }

  export type EspecialidadAvgAggregateOutputType = {
    id: number | null
    estado: number | null
  }

  export type EspecialidadSumAggregateOutputType = {
    id: number | null
    estado: number | null
  }

  export type EspecialidadMinAggregateOutputType = {
    id: number | null
    especialidad: string | null
    estado: number | null
  }

  export type EspecialidadMaxAggregateOutputType = {
    id: number | null
    especialidad: string | null
    estado: number | null
  }

  export type EspecialidadCountAggregateOutputType = {
    id: number
    especialidad: number
    estado: number
    _all: number
  }


  export type EspecialidadAvgAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EspecialidadSumAggregateInputType = {
    id?: true
    estado?: true
  }

  export type EspecialidadMinAggregateInputType = {
    id?: true
    especialidad?: true
    estado?: true
  }

  export type EspecialidadMaxAggregateInputType = {
    id?: true
    especialidad?: true
    estado?: true
  }

  export type EspecialidadCountAggregateInputType = {
    id?: true
    especialidad?: true
    estado?: true
    _all?: true
  }

  export type EspecialidadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidad to aggregate.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned especialidads
    **/
    _count?: true | EspecialidadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EspecialidadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EspecialidadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EspecialidadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EspecialidadMaxAggregateInputType
  }

  export type GetEspecialidadAggregateType<T extends EspecialidadAggregateArgs> = {
        [P in keyof T & keyof AggregateEspecialidad]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEspecialidad[P]>
      : GetScalarType<T[P], AggregateEspecialidad[P]>
  }




  export type especialidadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: especialidadWhereInput
    orderBy?: especialidadOrderByWithAggregationInput | especialidadOrderByWithAggregationInput[]
    by: EspecialidadScalarFieldEnum[] | EspecialidadScalarFieldEnum
    having?: especialidadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EspecialidadCountAggregateInputType | true
    _avg?: EspecialidadAvgAggregateInputType
    _sum?: EspecialidadSumAggregateInputType
    _min?: EspecialidadMinAggregateInputType
    _max?: EspecialidadMaxAggregateInputType
  }

  export type EspecialidadGroupByOutputType = {
    id: number
    especialidad: string | null
    estado: number | null
    _count: EspecialidadCountAggregateOutputType | null
    _avg: EspecialidadAvgAggregateOutputType | null
    _sum: EspecialidadSumAggregateOutputType | null
    _min: EspecialidadMinAggregateOutputType | null
    _max: EspecialidadMaxAggregateOutputType | null
  }

  type GetEspecialidadGroupByPayload<T extends especialidadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EspecialidadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EspecialidadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EspecialidadGroupByOutputType[P]>
            : GetScalarType<T[P], EspecialidadGroupByOutputType[P]>
        }
      >
    >


  export type especialidadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    especialidad?: boolean
    estado?: boolean
    empleado_especialidad?: boolean | especialidad$empleado_especialidadArgs<ExtArgs>
    _count?: boolean | EspecialidadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["especialidad"]>

  export type especialidadSelectScalar = {
    id?: boolean
    especialidad?: boolean
    estado?: boolean
  }

  export type especialidadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado_especialidad?: boolean | especialidad$empleado_especialidadArgs<ExtArgs>
    _count?: boolean | EspecialidadCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $especialidadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "especialidad"
    objects: {
      empleado_especialidad: Prisma.$empleado_especialidadPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      especialidad: string | null
      estado: number | null
    }, ExtArgs["result"]["especialidad"]>
    composites: {}
  }


  type especialidadGetPayload<S extends boolean | null | undefined | especialidadDefaultArgs> = $Result.GetResult<Prisma.$especialidadPayload, S>

  type especialidadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<especialidadFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: EspecialidadCountAggregateInputType | true
    }

  export interface especialidadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['especialidad'], meta: { name: 'especialidad' } }
    /**
     * Find zero or one Especialidad that matches the filter.
     * @param {especialidadFindUniqueArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends especialidadFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadFindUniqueArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Especialidad that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {especialidadFindUniqueOrThrowArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends especialidadFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Especialidad that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindFirstArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends especialidadFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadFindFirstArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Especialidad that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindFirstOrThrowArgs} args - Arguments to find a Especialidad
     * @example
     * // Get one Especialidad
     * const especialidad = await prisma.especialidad.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends especialidadFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Especialidads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Especialidads
     * const especialidads = await prisma.especialidad.findMany()
     * 
     * // Get first 10 Especialidads
     * const especialidads = await prisma.especialidad.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const especialidadWithIdOnly = await prisma.especialidad.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends especialidadFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Especialidad.
     * @param {especialidadCreateArgs} args - Arguments to create a Especialidad.
     * @example
     * // Create one Especialidad
     * const Especialidad = await prisma.especialidad.create({
     *   data: {
     *     // ... data to create a Especialidad
     *   }
     * })
     * 
    **/
    create<T extends especialidadCreateArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadCreateArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Especialidads.
     *     @param {especialidadCreateManyArgs} args - Arguments to create many Especialidads.
     *     @example
     *     // Create many Especialidads
     *     const especialidad = await prisma.especialidad.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends especialidadCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Especialidad.
     * @param {especialidadDeleteArgs} args - Arguments to delete one Especialidad.
     * @example
     * // Delete one Especialidad
     * const Especialidad = await prisma.especialidad.delete({
     *   where: {
     *     // ... filter to delete one Especialidad
     *   }
     * })
     * 
    **/
    delete<T extends especialidadDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadDeleteArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Especialidad.
     * @param {especialidadUpdateArgs} args - Arguments to update one Especialidad.
     * @example
     * // Update one Especialidad
     * const especialidad = await prisma.especialidad.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends especialidadUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadUpdateArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Especialidads.
     * @param {especialidadDeleteManyArgs} args - Arguments to filter Especialidads to delete.
     * @example
     * // Delete a few Especialidads
     * const { count } = await prisma.especialidad.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends especialidadDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, especialidadDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Especialidads
     * const especialidad = await prisma.especialidad.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends especialidadUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Especialidad.
     * @param {especialidadUpsertArgs} args - Arguments to update or create a Especialidad.
     * @example
     * // Update or create a Especialidad
     * const especialidad = await prisma.especialidad.upsert({
     *   create: {
     *     // ... data to create a Especialidad
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Especialidad we want to update
     *   }
     * })
    **/
    upsert<T extends especialidadUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, especialidadUpsertArgs<ExtArgs>>
    ): Prisma__especialidadClient<$Result.GetResult<Prisma.$especialidadPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Especialidads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadCountArgs} args - Arguments to filter Especialidads to count.
     * @example
     * // Count the number of Especialidads
     * const count = await prisma.especialidad.count({
     *   where: {
     *     // ... the filter for the Especialidads we want to count
     *   }
     * })
    **/
    count<T extends especialidadCountArgs>(
      args?: Subset<T, especialidadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EspecialidadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EspecialidadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EspecialidadAggregateArgs>(args: Subset<T, EspecialidadAggregateArgs>): Prisma.PrismaPromise<GetEspecialidadAggregateType<T>>

    /**
     * Group by Especialidad.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {especialidadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends especialidadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: especialidadGroupByArgs['orderBy'] }
        : { orderBy?: especialidadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, especialidadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEspecialidadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the especialidad model
   */
  readonly fields: especialidadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for especialidad.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__especialidadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    empleado_especialidad<T extends especialidad$empleado_especialidadArgs<ExtArgs> = {}>(args?: Subset<T, especialidad$empleado_especialidadArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$empleado_especialidadPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the especialidad model
   */ 
  interface especialidadFieldRefs {
    readonly id: FieldRef<"especialidad", 'Int'>
    readonly especialidad: FieldRef<"especialidad", 'String'>
    readonly estado: FieldRef<"especialidad", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * especialidad findUnique
   */
  export type especialidadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where: especialidadWhereUniqueInput
  }


  /**
   * especialidad findUniqueOrThrow
   */
  export type especialidadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where: especialidadWhereUniqueInput
  }


  /**
   * especialidad findFirst
   */
  export type especialidadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidads.
     */
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }


  /**
   * especialidad findFirstOrThrow
   */
  export type especialidadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidad to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of especialidads.
     */
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }


  /**
   * especialidad findMany
   */
  export type especialidadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter, which especialidads to fetch.
     */
    where?: especialidadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of especialidads to fetch.
     */
    orderBy?: especialidadOrderByWithRelationInput | especialidadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing especialidads.
     */
    cursor?: especialidadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` especialidads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` especialidads.
     */
    skip?: number
    distinct?: EspecialidadScalarFieldEnum | EspecialidadScalarFieldEnum[]
  }


  /**
   * especialidad create
   */
  export type especialidadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The data needed to create a especialidad.
     */
    data?: XOR<especialidadCreateInput, especialidadUncheckedCreateInput>
  }


  /**
   * especialidad createMany
   */
  export type especialidadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many especialidads.
     */
    data: especialidadCreateManyInput | especialidadCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * especialidad update
   */
  export type especialidadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The data needed to update a especialidad.
     */
    data: XOR<especialidadUpdateInput, especialidadUncheckedUpdateInput>
    /**
     * Choose, which especialidad to update.
     */
    where: especialidadWhereUniqueInput
  }


  /**
   * especialidad updateMany
   */
  export type especialidadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update especialidads.
     */
    data: XOR<especialidadUpdateManyMutationInput, especialidadUncheckedUpdateManyInput>
    /**
     * Filter which especialidads to update
     */
    where?: especialidadWhereInput
  }


  /**
   * especialidad upsert
   */
  export type especialidadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * The filter to search for the especialidad to update in case it exists.
     */
    where: especialidadWhereUniqueInput
    /**
     * In case the especialidad found by the `where` argument doesn't exist, create a new especialidad with this data.
     */
    create: XOR<especialidadCreateInput, especialidadUncheckedCreateInput>
    /**
     * In case the especialidad was found with the provided `where` argument, update it with this data.
     */
    update: XOR<especialidadUpdateInput, especialidadUncheckedUpdateInput>
  }


  /**
   * especialidad delete
   */
  export type especialidadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
    /**
     * Filter which especialidad to delete.
     */
    where: especialidadWhereUniqueInput
  }


  /**
   * especialidad deleteMany
   */
  export type especialidadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which especialidads to delete
     */
    where?: especialidadWhereInput
  }


  /**
   * especialidad.empleado_especialidad
   */
  export type especialidad$empleado_especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado_especialidad
     */
    select?: empleado_especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleado_especialidadInclude<ExtArgs> | null
    where?: empleado_especialidadWhereInput
    orderBy?: empleado_especialidadOrderByWithRelationInput | empleado_especialidadOrderByWithRelationInput[]
    cursor?: empleado_especialidadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Empleado_especialidadScalarFieldEnum | Empleado_especialidadScalarFieldEnum[]
  }


  /**
   * especialidad without action
   */
  export type especialidadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the especialidad
     */
    select?: especialidadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: especialidadInclude<ExtArgs> | null
  }



  /**
   * Model materiales
   */

  export type AggregateMateriales = {
    _count: MaterialesCountAggregateOutputType | null
    _avg: MaterialesAvgAggregateOutputType | null
    _sum: MaterialesSumAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  export type MaterialesAvgAggregateOutputType = {
    idMat: number | null
    estado: number | null
    idCategoria: number | null
    cantidad: number | null
  }

  export type MaterialesSumAggregateOutputType = {
    idMat: number | null
    estado: number | null
    idCategoria: number | null
    cantidad: number | null
  }

  export type MaterialesMinAggregateOutputType = {
    idMat: number | null
    nombre: string | null
    estado: number | null
    idCategoria: number | null
    cantidad: number | null
  }

  export type MaterialesMaxAggregateOutputType = {
    idMat: number | null
    nombre: string | null
    estado: number | null
    idCategoria: number | null
    cantidad: number | null
  }

  export type MaterialesCountAggregateOutputType = {
    idMat: number
    nombre: number
    estado: number
    idCategoria: number
    cantidad: number
    _all: number
  }


  export type MaterialesAvgAggregateInputType = {
    idMat?: true
    estado?: true
    idCategoria?: true
    cantidad?: true
  }

  export type MaterialesSumAggregateInputType = {
    idMat?: true
    estado?: true
    idCategoria?: true
    cantidad?: true
  }

  export type MaterialesMinAggregateInputType = {
    idMat?: true
    nombre?: true
    estado?: true
    idCategoria?: true
    cantidad?: true
  }

  export type MaterialesMaxAggregateInputType = {
    idMat?: true
    nombre?: true
    estado?: true
    idCategoria?: true
    cantidad?: true
  }

  export type MaterialesCountAggregateInputType = {
    idMat?: true
    nombre?: true
    estado?: true
    idCategoria?: true
    cantidad?: true
    _all?: true
  }

  export type MaterialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to aggregate.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned materiales
    **/
    _count?: true | MaterialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaterialesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaterialesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialesMaxAggregateInputType
  }

  export type GetMaterialesAggregateType<T extends MaterialesAggregateArgs> = {
        [P in keyof T & keyof AggregateMateriales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMateriales[P]>
      : GetScalarType<T[P], AggregateMateriales[P]>
  }




  export type materialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: materialesWhereInput
    orderBy?: materialesOrderByWithAggregationInput | materialesOrderByWithAggregationInput[]
    by: MaterialesScalarFieldEnum[] | MaterialesScalarFieldEnum
    having?: materialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialesCountAggregateInputType | true
    _avg?: MaterialesAvgAggregateInputType
    _sum?: MaterialesSumAggregateInputType
    _min?: MaterialesMinAggregateInputType
    _max?: MaterialesMaxAggregateInputType
  }

  export type MaterialesGroupByOutputType = {
    idMat: number
    nombre: string | null
    estado: number | null
    idCategoria: number | null
    cantidad: number
    _count: MaterialesCountAggregateOutputType | null
    _avg: MaterialesAvgAggregateOutputType | null
    _sum: MaterialesSumAggregateOutputType | null
    _min: MaterialesMinAggregateOutputType | null
    _max: MaterialesMaxAggregateOutputType | null
  }

  type GetMaterialesGroupByPayload<T extends materialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialesGroupByOutputType[P]>
        }
      >
    >


  export type materialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idMat?: boolean
    nombre?: boolean
    estado?: boolean
    idCategoria?: boolean
    cantidad?: boolean
    actividades_materiales?: boolean | materiales$actividades_materialesArgs<ExtArgs>
    compras_detalle?: boolean | materiales$compras_detalleArgs<ExtArgs>
    categoria?: boolean | materiales$categoriaArgs<ExtArgs>
    _count?: boolean | MaterialesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["materiales"]>

  export type materialesSelectScalar = {
    idMat?: boolean
    nombre?: boolean
    estado?: boolean
    idCategoria?: boolean
    cantidad?: boolean
  }

  export type materialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_materiales?: boolean | materiales$actividades_materialesArgs<ExtArgs>
    compras_detalle?: boolean | materiales$compras_detalleArgs<ExtArgs>
    categoria?: boolean | materiales$categoriaArgs<ExtArgs>
    _count?: boolean | MaterialesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $materialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "materiales"
    objects: {
      actividades_materiales: Prisma.$actividades_materialesPayload<ExtArgs>[]
      compras_detalle: Prisma.$compras_detallePayload<ExtArgs>[]
      categoria: Prisma.$categoriaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idMat: number
      nombre: string | null
      estado: number | null
      idCategoria: number | null
      cantidad: number
    }, ExtArgs["result"]["materiales"]>
    composites: {}
  }


  type materialesGetPayload<S extends boolean | null | undefined | materialesDefaultArgs> = $Result.GetResult<Prisma.$materialesPayload, S>

  type materialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<materialesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: MaterialesCountAggregateInputType | true
    }

  export interface materialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['materiales'], meta: { name: 'materiales' } }
    /**
     * Find zero or one Materiales that matches the filter.
     * @param {materialesFindUniqueArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends materialesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, materialesFindUniqueArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Materiales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {materialesFindUniqueOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends materialesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends materialesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesFindFirstArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Materiales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindFirstOrThrowArgs} args - Arguments to find a Materiales
     * @example
     * // Get one Materiales
     * const materiales = await prisma.materiales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends materialesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materiales
     * const materiales = await prisma.materiales.findMany()
     * 
     * // Get first 10 Materiales
     * const materiales = await prisma.materiales.findMany({ take: 10 })
     * 
     * // Only select the `idMat`
     * const materialesWithIdMatOnly = await prisma.materiales.findMany({ select: { idMat: true } })
     * 
    **/
    findMany<T extends materialesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Materiales.
     * @param {materialesCreateArgs} args - Arguments to create a Materiales.
     * @example
     * // Create one Materiales
     * const Materiales = await prisma.materiales.create({
     *   data: {
     *     // ... data to create a Materiales
     *   }
     * })
     * 
    **/
    create<T extends materialesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, materialesCreateArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Materiales.
     *     @param {materialesCreateManyArgs} args - Arguments to create many Materiales.
     *     @example
     *     // Create many Materiales
     *     const materiales = await prisma.materiales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends materialesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Materiales.
     * @param {materialesDeleteArgs} args - Arguments to delete one Materiales.
     * @example
     * // Delete one Materiales
     * const Materiales = await prisma.materiales.delete({
     *   where: {
     *     // ... filter to delete one Materiales
     *   }
     * })
     * 
    **/
    delete<T extends materialesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, materialesDeleteArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Materiales.
     * @param {materialesUpdateArgs} args - Arguments to update one Materiales.
     * @example
     * // Update one Materiales
     * const materiales = await prisma.materiales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends materialesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, materialesUpdateArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Materiales.
     * @param {materialesDeleteManyArgs} args - Arguments to filter Materiales to delete.
     * @example
     * // Delete a few Materiales
     * const { count } = await prisma.materiales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends materialesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, materialesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materiales
     * const materiales = await prisma.materiales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends materialesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, materialesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Materiales.
     * @param {materialesUpsertArgs} args - Arguments to update or create a Materiales.
     * @example
     * // Update or create a Materiales
     * const materiales = await prisma.materiales.upsert({
     *   create: {
     *     // ... data to create a Materiales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Materiales we want to update
     *   }
     * })
    **/
    upsert<T extends materialesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, materialesUpsertArgs<ExtArgs>>
    ): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesCountArgs} args - Arguments to filter Materiales to count.
     * @example
     * // Count the number of Materiales
     * const count = await prisma.materiales.count({
     *   where: {
     *     // ... the filter for the Materiales we want to count
     *   }
     * })
    **/
    count<T extends materialesCountArgs>(
      args?: Subset<T, materialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialesAggregateArgs>(args: Subset<T, MaterialesAggregateArgs>): Prisma.PrismaPromise<GetMaterialesAggregateType<T>>

    /**
     * Group by Materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {materialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends materialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: materialesGroupByArgs['orderBy'] }
        : { orderBy?: materialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, materialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the materiales model
   */
  readonly fields: materialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for materiales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__materialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    actividades_materiales<T extends materiales$actividades_materialesArgs<ExtArgs> = {}>(args?: Subset<T, materiales$actividades_materialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findMany'> | Null>;

    compras_detalle<T extends materiales$compras_detalleArgs<ExtArgs> = {}>(args?: Subset<T, materiales$compras_detalleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$compras_detallePayload<ExtArgs>, T, 'findMany'> | Null>;

    categoria<T extends materiales$categoriaArgs<ExtArgs> = {}>(args?: Subset<T, materiales$categoriaArgs<ExtArgs>>): Prisma__categoriaClient<$Result.GetResult<Prisma.$categoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the materiales model
   */ 
  interface materialesFieldRefs {
    readonly idMat: FieldRef<"materiales", 'Int'>
    readonly nombre: FieldRef<"materiales", 'String'>
    readonly estado: FieldRef<"materiales", 'Int'>
    readonly idCategoria: FieldRef<"materiales", 'Int'>
    readonly cantidad: FieldRef<"materiales", 'Float'>
  }
    

  // Custom InputTypes

  /**
   * materiales findUnique
   */
  export type materialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }


  /**
   * materiales findUniqueOrThrow
   */
  export type materialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where: materialesWhereUniqueInput
  }


  /**
   * materiales findFirst
   */
  export type materialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }


  /**
   * materiales findFirstOrThrow
   */
  export type materialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of materiales.
     */
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }


  /**
   * materiales findMany
   */
  export type materialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter, which materiales to fetch.
     */
    where?: materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of materiales to fetch.
     */
    orderBy?: materialesOrderByWithRelationInput | materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing materiales.
     */
    cursor?: materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` materiales.
     */
    skip?: number
    distinct?: MaterialesScalarFieldEnum | MaterialesScalarFieldEnum[]
  }


  /**
   * materiales create
   */
  export type materialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to create a materiales.
     */
    data: XOR<materialesCreateInput, materialesUncheckedCreateInput>
  }


  /**
   * materiales createMany
   */
  export type materialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many materiales.
     */
    data: materialesCreateManyInput | materialesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * materiales update
   */
  export type materialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The data needed to update a materiales.
     */
    data: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
    /**
     * Choose, which materiales to update.
     */
    where: materialesWhereUniqueInput
  }


  /**
   * materiales updateMany
   */
  export type materialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update materiales.
     */
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyInput>
    /**
     * Filter which materiales to update
     */
    where?: materialesWhereInput
  }


  /**
   * materiales upsert
   */
  export type materialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * The filter to search for the materiales to update in case it exists.
     */
    where: materialesWhereUniqueInput
    /**
     * In case the materiales found by the `where` argument doesn't exist, create a new materiales with this data.
     */
    create: XOR<materialesCreateInput, materialesUncheckedCreateInput>
    /**
     * In case the materiales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<materialesUpdateInput, materialesUncheckedUpdateInput>
  }


  /**
   * materiales delete
   */
  export type materialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
    /**
     * Filter which materiales to delete.
     */
    where: materialesWhereUniqueInput
  }


  /**
   * materiales deleteMany
   */
  export type materialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which materiales to delete
     */
    where?: materialesWhereInput
  }


  /**
   * materiales.actividades_materiales
   */
  export type materiales$actividades_materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    where?: actividades_materialesWhereInput
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    cursor?: actividades_materialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Actividades_materialesScalarFieldEnum | Actividades_materialesScalarFieldEnum[]
  }


  /**
   * materiales.compras_detalle
   */
  export type materiales$compras_detalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras_detalle
     */
    select?: compras_detalleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: compras_detalleInclude<ExtArgs> | null
    where?: compras_detalleWhereInput
    orderBy?: compras_detalleOrderByWithRelationInput | compras_detalleOrderByWithRelationInput[]
    cursor?: compras_detalleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Compras_detalleScalarFieldEnum | Compras_detalleScalarFieldEnum[]
  }


  /**
   * materiales.categoria
   */
  export type materiales$categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categoria
     */
    select?: categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: categoriaInclude<ExtArgs> | null
    where?: categoriaWhereInput
  }


  /**
   * materiales without action
   */
  export type materialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the materiales
     */
    select?: materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: materialesInclude<ExtArgs> | null
  }



  /**
   * Model obras
   */

  export type AggregateObras = {
    _count: ObrasCountAggregateOutputType | null
    _avg: ObrasAvgAggregateOutputType | null
    _sum: ObrasSumAggregateOutputType | null
    _min: ObrasMinAggregateOutputType | null
    _max: ObrasMaxAggregateOutputType | null
  }

  export type ObrasAvgAggregateOutputType = {
    idObra: number | null
    idCliente: number | null
    precio: number | null
    idEmp: number | null
  }

  export type ObrasSumAggregateOutputType = {
    idObra: number | null
    idCliente: number | null
    precio: number | null
    idEmp: number | null
  }

  export type ObrasMinAggregateOutputType = {
    idObra: number | null
    descripcion: string | null
    fechaini: string | null
    fechafin: string | null
    area: string | null
    idCliente: number | null
    estado: string | null
    precio: number | null
    createdAt: Date | null
    idEmp: number | null
  }

  export type ObrasMaxAggregateOutputType = {
    idObra: number | null
    descripcion: string | null
    fechaini: string | null
    fechafin: string | null
    area: string | null
    idCliente: number | null
    estado: string | null
    precio: number | null
    createdAt: Date | null
    idEmp: number | null
  }

  export type ObrasCountAggregateOutputType = {
    idObra: number
    descripcion: number
    fechaini: number
    fechafin: number
    area: number
    idCliente: number
    estado: number
    precio: number
    createdAt: number
    idEmp: number
    _all: number
  }


  export type ObrasAvgAggregateInputType = {
    idObra?: true
    idCliente?: true
    precio?: true
    idEmp?: true
  }

  export type ObrasSumAggregateInputType = {
    idObra?: true
    idCliente?: true
    precio?: true
    idEmp?: true
  }

  export type ObrasMinAggregateInputType = {
    idObra?: true
    descripcion?: true
    fechaini?: true
    fechafin?: true
    area?: true
    idCliente?: true
    estado?: true
    precio?: true
    createdAt?: true
    idEmp?: true
  }

  export type ObrasMaxAggregateInputType = {
    idObra?: true
    descripcion?: true
    fechaini?: true
    fechafin?: true
    area?: true
    idCliente?: true
    estado?: true
    precio?: true
    createdAt?: true
    idEmp?: true
  }

  export type ObrasCountAggregateInputType = {
    idObra?: true
    descripcion?: true
    fechaini?: true
    fechafin?: true
    area?: true
    idCliente?: true
    estado?: true
    precio?: true
    createdAt?: true
    idEmp?: true
    _all?: true
  }

  export type ObrasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which obras to aggregate.
     */
    where?: obrasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obras to fetch.
     */
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: obrasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned obras
    **/
    _count?: true | ObrasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObrasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObrasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObrasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObrasMaxAggregateInputType
  }

  export type GetObrasAggregateType<T extends ObrasAggregateArgs> = {
        [P in keyof T & keyof AggregateObras]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObras[P]>
      : GetScalarType<T[P], AggregateObras[P]>
  }




  export type obrasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: obrasWhereInput
    orderBy?: obrasOrderByWithAggregationInput | obrasOrderByWithAggregationInput[]
    by: ObrasScalarFieldEnum[] | ObrasScalarFieldEnum
    having?: obrasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObrasCountAggregateInputType | true
    _avg?: ObrasAvgAggregateInputType
    _sum?: ObrasSumAggregateInputType
    _min?: ObrasMinAggregateInputType
    _max?: ObrasMaxAggregateInputType
  }

  export type ObrasGroupByOutputType = {
    idObra: number
    descripcion: string | null
    fechaini: string | null
    fechafin: string | null
    area: string | null
    idCliente: number | null
    estado: string | null
    precio: number | null
    createdAt: Date
    idEmp: number
    _count: ObrasCountAggregateOutputType | null
    _avg: ObrasAvgAggregateOutputType | null
    _sum: ObrasSumAggregateOutputType | null
    _min: ObrasMinAggregateOutputType | null
    _max: ObrasMaxAggregateOutputType | null
  }

  type GetObrasGroupByPayload<T extends obrasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObrasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObrasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObrasGroupByOutputType[P]>
            : GetScalarType<T[P], ObrasGroupByOutputType[P]>
        }
      >
    >


  export type obrasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idObra?: boolean
    descripcion?: boolean
    fechaini?: boolean
    fechafin?: boolean
    area?: boolean
    idCliente?: boolean
    estado?: boolean
    precio?: boolean
    createdAt?: boolean
    idEmp?: boolean
    actividades_empleados?: boolean | obras$actividades_empleadosArgs<ExtArgs>
    actividades_materiales?: boolean | obras$actividades_materialesArgs<ExtArgs>
    detalle_obra?: boolean | obras$detalle_obraArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    cliente?: boolean | obras$clienteArgs<ExtArgs>
    _count?: boolean | ObrasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["obras"]>

  export type obrasSelectScalar = {
    idObra?: boolean
    descripcion?: boolean
    fechaini?: boolean
    fechafin?: boolean
    area?: boolean
    idCliente?: boolean
    estado?: boolean
    precio?: boolean
    createdAt?: boolean
    idEmp?: boolean
  }

  export type obrasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actividades_empleados?: boolean | obras$actividades_empleadosArgs<ExtArgs>
    actividades_materiales?: boolean | obras$actividades_materialesArgs<ExtArgs>
    detalle_obra?: boolean | obras$detalle_obraArgs<ExtArgs>
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    cliente?: boolean | obras$clienteArgs<ExtArgs>
    _count?: boolean | ObrasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $obrasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "obras"
    objects: {
      actividades_empleados: Prisma.$actividades_empleadosPayload<ExtArgs>[]
      actividades_materiales: Prisma.$actividades_materialesPayload<ExtArgs>[]
      detalle_obra: Prisma.$detalle_obraPayload<ExtArgs>[]
      empleado: Prisma.$empleadoPayload<ExtArgs>
      cliente: Prisma.$clientePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      idObra: number
      descripcion: string | null
      fechaini: string | null
      fechafin: string | null
      area: string | null
      idCliente: number | null
      estado: string | null
      precio: number | null
      createdAt: Date
      idEmp: number
    }, ExtArgs["result"]["obras"]>
    composites: {}
  }


  type obrasGetPayload<S extends boolean | null | undefined | obrasDefaultArgs> = $Result.GetResult<Prisma.$obrasPayload, S>

  type obrasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<obrasFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ObrasCountAggregateInputType | true
    }

  export interface obrasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['obras'], meta: { name: 'obras' } }
    /**
     * Find zero or one Obras that matches the filter.
     * @param {obrasFindUniqueArgs} args - Arguments to find a Obras
     * @example
     * // Get one Obras
     * const obras = await prisma.obras.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends obrasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, obrasFindUniqueArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Obras that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {obrasFindUniqueOrThrowArgs} args - Arguments to find a Obras
     * @example
     * // Get one Obras
     * const obras = await prisma.obras.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends obrasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Obras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasFindFirstArgs} args - Arguments to find a Obras
     * @example
     * // Get one Obras
     * const obras = await prisma.obras.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends obrasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasFindFirstArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Obras that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasFindFirstOrThrowArgs} args - Arguments to find a Obras
     * @example
     * // Get one Obras
     * const obras = await prisma.obras.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends obrasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Obras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obras
     * const obras = await prisma.obras.findMany()
     * 
     * // Get first 10 Obras
     * const obras = await prisma.obras.findMany({ take: 10 })
     * 
     * // Only select the `idObra`
     * const obrasWithIdObraOnly = await prisma.obras.findMany({ select: { idObra: true } })
     * 
    **/
    findMany<T extends obrasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Obras.
     * @param {obrasCreateArgs} args - Arguments to create a Obras.
     * @example
     * // Create one Obras
     * const Obras = await prisma.obras.create({
     *   data: {
     *     // ... data to create a Obras
     *   }
     * })
     * 
    **/
    create<T extends obrasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, obrasCreateArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Obras.
     *     @param {obrasCreateManyArgs} args - Arguments to create many Obras.
     *     @example
     *     // Create many Obras
     *     const obras = await prisma.obras.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends obrasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Obras.
     * @param {obrasDeleteArgs} args - Arguments to delete one Obras.
     * @example
     * // Delete one Obras
     * const Obras = await prisma.obras.delete({
     *   where: {
     *     // ... filter to delete one Obras
     *   }
     * })
     * 
    **/
    delete<T extends obrasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, obrasDeleteArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Obras.
     * @param {obrasUpdateArgs} args - Arguments to update one Obras.
     * @example
     * // Update one Obras
     * const obras = await prisma.obras.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends obrasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, obrasUpdateArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Obras.
     * @param {obrasDeleteManyArgs} args - Arguments to filter Obras to delete.
     * @example
     * // Delete a few Obras
     * const { count } = await prisma.obras.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends obrasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, obrasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obras
     * const obras = await prisma.obras.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends obrasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, obrasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Obras.
     * @param {obrasUpsertArgs} args - Arguments to update or create a Obras.
     * @example
     * // Update or create a Obras
     * const obras = await prisma.obras.upsert({
     *   create: {
     *     // ... data to create a Obras
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obras we want to update
     *   }
     * })
    **/
    upsert<T extends obrasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, obrasUpsertArgs<ExtArgs>>
    ): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasCountArgs} args - Arguments to filter Obras to count.
     * @example
     * // Count the number of Obras
     * const count = await prisma.obras.count({
     *   where: {
     *     // ... the filter for the Obras we want to count
     *   }
     * })
    **/
    count<T extends obrasCountArgs>(
      args?: Subset<T, obrasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObrasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObrasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObrasAggregateArgs>(args: Subset<T, ObrasAggregateArgs>): Prisma.PrismaPromise<GetObrasAggregateType<T>>

    /**
     * Group by Obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {obrasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends obrasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: obrasGroupByArgs['orderBy'] }
        : { orderBy?: obrasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, obrasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObrasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the obras model
   */
  readonly fields: obrasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for obras.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__obrasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    actividades_empleados<T extends obras$actividades_empleadosArgs<ExtArgs> = {}>(args?: Subset<T, obras$actividades_empleadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findMany'> | Null>;

    actividades_materiales<T extends obras$actividades_materialesArgs<ExtArgs> = {}>(args?: Subset<T, obras$actividades_materialesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findMany'> | Null>;

    detalle_obra<T extends obras$detalle_obraArgs<ExtArgs> = {}>(args?: Subset<T, obras$detalle_obraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findMany'> | Null>;

    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    cliente<T extends obras$clienteArgs<ExtArgs> = {}>(args?: Subset<T, obras$clienteArgs<ExtArgs>>): Prisma__clienteClient<$Result.GetResult<Prisma.$clientePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the obras model
   */ 
  interface obrasFieldRefs {
    readonly idObra: FieldRef<"obras", 'Int'>
    readonly descripcion: FieldRef<"obras", 'String'>
    readonly fechaini: FieldRef<"obras", 'String'>
    readonly fechafin: FieldRef<"obras", 'String'>
    readonly area: FieldRef<"obras", 'String'>
    readonly idCliente: FieldRef<"obras", 'Int'>
    readonly estado: FieldRef<"obras", 'String'>
    readonly precio: FieldRef<"obras", 'Int'>
    readonly createdAt: FieldRef<"obras", 'DateTime'>
    readonly idEmp: FieldRef<"obras", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * obras findUnique
   */
  export type obrasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter, which obras to fetch.
     */
    where: obrasWhereUniqueInput
  }


  /**
   * obras findUniqueOrThrow
   */
  export type obrasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter, which obras to fetch.
     */
    where: obrasWhereUniqueInput
  }


  /**
   * obras findFirst
   */
  export type obrasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter, which obras to fetch.
     */
    where?: obrasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obras to fetch.
     */
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for obras.
     */
    cursor?: obrasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of obras.
     */
    distinct?: ObrasScalarFieldEnum | ObrasScalarFieldEnum[]
  }


  /**
   * obras findFirstOrThrow
   */
  export type obrasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter, which obras to fetch.
     */
    where?: obrasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obras to fetch.
     */
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for obras.
     */
    cursor?: obrasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of obras.
     */
    distinct?: ObrasScalarFieldEnum | ObrasScalarFieldEnum[]
  }


  /**
   * obras findMany
   */
  export type obrasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter, which obras to fetch.
     */
    where?: obrasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of obras to fetch.
     */
    orderBy?: obrasOrderByWithRelationInput | obrasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing obras.
     */
    cursor?: obrasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` obras.
     */
    skip?: number
    distinct?: ObrasScalarFieldEnum | ObrasScalarFieldEnum[]
  }


  /**
   * obras create
   */
  export type obrasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * The data needed to create a obras.
     */
    data: XOR<obrasCreateInput, obrasUncheckedCreateInput>
  }


  /**
   * obras createMany
   */
  export type obrasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many obras.
     */
    data: obrasCreateManyInput | obrasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * obras update
   */
  export type obrasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * The data needed to update a obras.
     */
    data: XOR<obrasUpdateInput, obrasUncheckedUpdateInput>
    /**
     * Choose, which obras to update.
     */
    where: obrasWhereUniqueInput
  }


  /**
   * obras updateMany
   */
  export type obrasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update obras.
     */
    data: XOR<obrasUpdateManyMutationInput, obrasUncheckedUpdateManyInput>
    /**
     * Filter which obras to update
     */
    where?: obrasWhereInput
  }


  /**
   * obras upsert
   */
  export type obrasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * The filter to search for the obras to update in case it exists.
     */
    where: obrasWhereUniqueInput
    /**
     * In case the obras found by the `where` argument doesn't exist, create a new obras with this data.
     */
    create: XOR<obrasCreateInput, obrasUncheckedCreateInput>
    /**
     * In case the obras was found with the provided `where` argument, update it with this data.
     */
    update: XOR<obrasUpdateInput, obrasUncheckedUpdateInput>
  }


  /**
   * obras delete
   */
  export type obrasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
    /**
     * Filter which obras to delete.
     */
    where: obrasWhereUniqueInput
  }


  /**
   * obras deleteMany
   */
  export type obrasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which obras to delete
     */
    where?: obrasWhereInput
  }


  /**
   * obras.actividades_empleados
   */
  export type obras$actividades_empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    where?: actividades_empleadosWhereInput
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    cursor?: actividades_empleadosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Actividades_empleadosScalarFieldEnum | Actividades_empleadosScalarFieldEnum[]
  }


  /**
   * obras.actividades_materiales
   */
  export type obras$actividades_materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    where?: actividades_materialesWhereInput
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    cursor?: actividades_materialesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Actividades_materialesScalarFieldEnum | Actividades_materialesScalarFieldEnum[]
  }


  /**
   * obras.detalle_obra
   */
  export type obras$detalle_obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    where?: detalle_obraWhereInput
    orderBy?: detalle_obraOrderByWithRelationInput | detalle_obraOrderByWithRelationInput[]
    cursor?: detalle_obraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Detalle_obraScalarFieldEnum | Detalle_obraScalarFieldEnum[]
  }


  /**
   * obras.cliente
   */
  export type obras$clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cliente
     */
    select?: clienteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: clienteInclude<ExtArgs> | null
    where?: clienteWhereInput
  }


  /**
   * obras without action
   */
  export type obrasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the obras
     */
    select?: obrasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: obrasInclude<ExtArgs> | null
  }



  /**
   * Model permiso
   */

  export type AggregatePermiso = {
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  export type PermisoAvgAggregateOutputType = {
    idPer: number | null
    estado: number | null
  }

  export type PermisoSumAggregateOutputType = {
    idPer: number | null
    estado: number | null
  }

  export type PermisoMinAggregateOutputType = {
    idPer: number | null
    permiso: string | null
    estado: number | null
  }

  export type PermisoMaxAggregateOutputType = {
    idPer: number | null
    permiso: string | null
    estado: number | null
  }

  export type PermisoCountAggregateOutputType = {
    idPer: number
    permiso: number
    estado: number
    _all: number
  }


  export type PermisoAvgAggregateInputType = {
    idPer?: true
    estado?: true
  }

  export type PermisoSumAggregateInputType = {
    idPer?: true
    estado?: true
  }

  export type PermisoMinAggregateInputType = {
    idPer?: true
    permiso?: true
    estado?: true
  }

  export type PermisoMaxAggregateInputType = {
    idPer?: true
    permiso?: true
    estado?: true
  }

  export type PermisoCountAggregateInputType = {
    idPer?: true
    permiso?: true
    estado?: true
    _all?: true
  }

  export type PermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permiso to aggregate.
     */
    where?: permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permisos to fetch.
     */
    orderBy?: permisoOrderByWithRelationInput | permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permisos
    **/
    _count?: true | PermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermisoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermisoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisoMaxAggregateInputType
  }

  export type GetPermisoAggregateType<T extends PermisoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermiso[P]>
      : GetScalarType<T[P], AggregatePermiso[P]>
  }




  export type permisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permisoWhereInput
    orderBy?: permisoOrderByWithAggregationInput | permisoOrderByWithAggregationInput[]
    by: PermisoScalarFieldEnum[] | PermisoScalarFieldEnum
    having?: permisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisoCountAggregateInputType | true
    _avg?: PermisoAvgAggregateInputType
    _sum?: PermisoSumAggregateInputType
    _min?: PermisoMinAggregateInputType
    _max?: PermisoMaxAggregateInputType
  }

  export type PermisoGroupByOutputType = {
    idPer: number
    permiso: string | null
    estado: number | null
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  type GetPermisoGroupByPayload<T extends permisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisoGroupByOutputType[P]>
            : GetScalarType<T[P], PermisoGroupByOutputType[P]>
        }
      >
    >


  export type permisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPer?: boolean
    permiso?: boolean
    estado?: boolean
    rolpermisoempleado?: boolean | permiso$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permiso"]>

  export type permisoSelectScalar = {
    idPer?: boolean
    permiso?: boolean
    estado?: boolean
  }

  export type permisoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolpermisoempleado?: boolean | permiso$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | PermisoCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $permisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permiso"
    objects: {
      rolpermisoempleado: Prisma.$rolpermisoempleadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPer: number
      permiso: string | null
      estado: number | null
    }, ExtArgs["result"]["permiso"]>
    composites: {}
  }


  type permisoGetPayload<S extends boolean | null | undefined | permisoDefaultArgs> = $Result.GetResult<Prisma.$permisoPayload, S>

  type permisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<permisoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PermisoCountAggregateInputType | true
    }

  export interface permisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permiso'], meta: { name: 'permiso' } }
    /**
     * Find zero or one Permiso that matches the filter.
     * @param {permisoFindUniqueArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends permisoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, permisoFindUniqueArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Permiso that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {permisoFindUniqueOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends permisoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoFindFirstArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends permisoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoFindFirstArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoFindFirstOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends permisoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisos
     * const permisos = await prisma.permiso.findMany()
     * 
     * // Get first 10 Permisos
     * const permisos = await prisma.permiso.findMany({ take: 10 })
     * 
     * // Only select the `idPer`
     * const permisoWithIdPerOnly = await prisma.permiso.findMany({ select: { idPer: true } })
     * 
    **/
    findMany<T extends permisoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Permiso.
     * @param {permisoCreateArgs} args - Arguments to create a Permiso.
     * @example
     * // Create one Permiso
     * const Permiso = await prisma.permiso.create({
     *   data: {
     *     // ... data to create a Permiso
     *   }
     * })
     * 
    **/
    create<T extends permisoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, permisoCreateArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Permisos.
     *     @param {permisoCreateManyArgs} args - Arguments to create many Permisos.
     *     @example
     *     // Create many Permisos
     *     const permiso = await prisma.permiso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends permisoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permiso.
     * @param {permisoDeleteArgs} args - Arguments to delete one Permiso.
     * @example
     * // Delete one Permiso
     * const Permiso = await prisma.permiso.delete({
     *   where: {
     *     // ... filter to delete one Permiso
     *   }
     * })
     * 
    **/
    delete<T extends permisoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, permisoDeleteArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Permiso.
     * @param {permisoUpdateArgs} args - Arguments to update one Permiso.
     * @example
     * // Update one Permiso
     * const permiso = await prisma.permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends permisoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, permisoUpdateArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Permisos.
     * @param {permisoDeleteManyArgs} args - Arguments to filter Permisos to delete.
     * @example
     * // Delete a few Permisos
     * const { count } = await prisma.permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends permisoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, permisoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends permisoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, permisoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permiso.
     * @param {permisoUpsertArgs} args - Arguments to update or create a Permiso.
     * @example
     * // Update or create a Permiso
     * const permiso = await prisma.permiso.upsert({
     *   create: {
     *     // ... data to create a Permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permiso we want to update
     *   }
     * })
    **/
    upsert<T extends permisoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, permisoUpsertArgs<ExtArgs>>
    ): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoCountArgs} args - Arguments to filter Permisos to count.
     * @example
     * // Count the number of Permisos
     * const count = await prisma.permiso.count({
     *   where: {
     *     // ... the filter for the Permisos we want to count
     *   }
     * })
    **/
    count<T extends permisoCountArgs>(
      args?: Subset<T, permisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisoAggregateArgs>(args: Subset<T, PermisoAggregateArgs>): Prisma.PrismaPromise<GetPermisoAggregateType<T>>

    /**
     * Group by Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permisoGroupByArgs['orderBy'] }
        : { orderBy?: permisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permiso model
   */
  readonly fields: permisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rolpermisoempleado<T extends permiso$rolpermisoempleadoArgs<ExtArgs> = {}>(args?: Subset<T, permiso$rolpermisoempleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the permiso model
   */ 
  interface permisoFieldRefs {
    readonly idPer: FieldRef<"permiso", 'Int'>
    readonly permiso: FieldRef<"permiso", 'String'>
    readonly estado: FieldRef<"permiso", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * permiso findUnique
   */
  export type permisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter, which permiso to fetch.
     */
    where: permisoWhereUniqueInput
  }


  /**
   * permiso findUniqueOrThrow
   */
  export type permisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter, which permiso to fetch.
     */
    where: permisoWhereUniqueInput
  }


  /**
   * permiso findFirst
   */
  export type permisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter, which permiso to fetch.
     */
    where?: permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permisos to fetch.
     */
    orderBy?: permisoOrderByWithRelationInput | permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permisos.
     */
    cursor?: permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * permiso findFirstOrThrow
   */
  export type permisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter, which permiso to fetch.
     */
    where?: permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permisos to fetch.
     */
    orderBy?: permisoOrderByWithRelationInput | permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permisos.
     */
    cursor?: permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * permiso findMany
   */
  export type permisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter, which permisos to fetch.
     */
    where?: permisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permisos to fetch.
     */
    orderBy?: permisoOrderByWithRelationInput | permisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permisos.
     */
    cursor?: permisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permisos.
     */
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * permiso create
   */
  export type permisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * The data needed to create a permiso.
     */
    data?: XOR<permisoCreateInput, permisoUncheckedCreateInput>
  }


  /**
   * permiso createMany
   */
  export type permisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permisos.
     */
    data: permisoCreateManyInput | permisoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * permiso update
   */
  export type permisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * The data needed to update a permiso.
     */
    data: XOR<permisoUpdateInput, permisoUncheckedUpdateInput>
    /**
     * Choose, which permiso to update.
     */
    where: permisoWhereUniqueInput
  }


  /**
   * permiso updateMany
   */
  export type permisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permisos.
     */
    data: XOR<permisoUpdateManyMutationInput, permisoUncheckedUpdateManyInput>
    /**
     * Filter which permisos to update
     */
    where?: permisoWhereInput
  }


  /**
   * permiso upsert
   */
  export type permisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * The filter to search for the permiso to update in case it exists.
     */
    where: permisoWhereUniqueInput
    /**
     * In case the permiso found by the `where` argument doesn't exist, create a new permiso with this data.
     */
    create: XOR<permisoCreateInput, permisoUncheckedCreateInput>
    /**
     * In case the permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permisoUpdateInput, permisoUncheckedUpdateInput>
  }


  /**
   * permiso delete
   */
  export type permisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
    /**
     * Filter which permiso to delete.
     */
    where: permisoWhereUniqueInput
  }


  /**
   * permiso deleteMany
   */
  export type permisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permisos to delete
     */
    where?: permisoWhereInput
  }


  /**
   * permiso.rolpermisoempleado
   */
  export type permiso$rolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    where?: rolpermisoempleadoWhereInput
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    cursor?: rolpermisoempleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * permiso without action
   */
  export type permisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permiso
     */
    select?: permisoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permisoInclude<ExtArgs> | null
  }



  /**
   * Model proveedor
   */

  export type AggregateProveedor = {
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  export type ProveedorAvgAggregateOutputType = {
    idProv: number | null
    estado: number | null
  }

  export type ProveedorSumAggregateOutputType = {
    idProv: number | null
    estado: number | null
  }

  export type ProveedorMinAggregateOutputType = {
    idProv: number | null
    nombre: string | null
    direccion: string | null
    nit: string | null
    tipo: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    nombreContacto: string | null
    telefonoContacto: string | null
    emailContacto: string | null
  }

  export type ProveedorMaxAggregateOutputType = {
    idProv: number | null
    nombre: string | null
    direccion: string | null
    nit: string | null
    tipo: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    nombreContacto: string | null
    telefonoContacto: string | null
    emailContacto: string | null
  }

  export type ProveedorCountAggregateOutputType = {
    idProv: number
    nombre: number
    direccion: number
    nit: number
    tipo: number
    estado: number
    email: number
    telefono: number
    nombreContacto: number
    telefonoContacto: number
    emailContacto: number
    _all: number
  }


  export type ProveedorAvgAggregateInputType = {
    idProv?: true
    estado?: true
  }

  export type ProveedorSumAggregateInputType = {
    idProv?: true
    estado?: true
  }

  export type ProveedorMinAggregateInputType = {
    idProv?: true
    nombre?: true
    direccion?: true
    nit?: true
    tipo?: true
    estado?: true
    email?: true
    telefono?: true
    nombreContacto?: true
    telefonoContacto?: true
    emailContacto?: true
  }

  export type ProveedorMaxAggregateInputType = {
    idProv?: true
    nombre?: true
    direccion?: true
    nit?: true
    tipo?: true
    estado?: true
    email?: true
    telefono?: true
    nombreContacto?: true
    telefonoContacto?: true
    emailContacto?: true
  }

  export type ProveedorCountAggregateInputType = {
    idProv?: true
    nombre?: true
    direccion?: true
    nit?: true
    tipo?: true
    estado?: true
    email?: true
    telefono?: true
    nombreContacto?: true
    telefonoContacto?: true
    emailContacto?: true
    _all?: true
  }

  export type ProveedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedor to aggregate.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned proveedors
    **/
    _count?: true | ProveedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProveedorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProveedorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProveedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProveedorMaxAggregateInputType
  }

  export type GetProveedorAggregateType<T extends ProveedorAggregateArgs> = {
        [P in keyof T & keyof AggregateProveedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProveedor[P]>
      : GetScalarType<T[P], AggregateProveedor[P]>
  }




  export type proveedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: proveedorWhereInput
    orderBy?: proveedorOrderByWithAggregationInput | proveedorOrderByWithAggregationInput[]
    by: ProveedorScalarFieldEnum[] | ProveedorScalarFieldEnum
    having?: proveedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProveedorCountAggregateInputType | true
    _avg?: ProveedorAvgAggregateInputType
    _sum?: ProveedorSumAggregateInputType
    _min?: ProveedorMinAggregateInputType
    _max?: ProveedorMaxAggregateInputType
  }

  export type ProveedorGroupByOutputType = {
    idProv: number
    nombre: string | null
    direccion: string | null
    nit: string | null
    tipo: string | null
    estado: number | null
    email: string | null
    telefono: string | null
    nombreContacto: string | null
    telefonoContacto: string | null
    emailContacto: string | null
    _count: ProveedorCountAggregateOutputType | null
    _avg: ProveedorAvgAggregateOutputType | null
    _sum: ProveedorSumAggregateOutputType | null
    _min: ProveedorMinAggregateOutputType | null
    _max: ProveedorMaxAggregateOutputType | null
  }

  type GetProveedorGroupByPayload<T extends proveedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProveedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProveedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
            : GetScalarType<T[P], ProveedorGroupByOutputType[P]>
        }
      >
    >


  export type proveedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idProv?: boolean
    nombre?: boolean
    direccion?: boolean
    nit?: boolean
    tipo?: boolean
    estado?: boolean
    email?: boolean
    telefono?: boolean
    nombreContacto?: boolean
    telefonoContacto?: boolean
    emailContacto?: boolean
    compras?: boolean | proveedor$comprasArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proveedor"]>

  export type proveedorSelectScalar = {
    idProv?: boolean
    nombre?: boolean
    direccion?: boolean
    nit?: boolean
    tipo?: boolean
    estado?: boolean
    email?: boolean
    telefono?: boolean
    nombreContacto?: boolean
    telefonoContacto?: boolean
    emailContacto?: boolean
  }

  export type proveedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    compras?: boolean | proveedor$comprasArgs<ExtArgs>
    _count?: boolean | ProveedorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $proveedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "proveedor"
    objects: {
      compras: Prisma.$comprasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idProv: number
      nombre: string | null
      direccion: string | null
      nit: string | null
      tipo: string | null
      estado: number | null
      email: string | null
      telefono: string | null
      nombreContacto: string | null
      telefonoContacto: string | null
      emailContacto: string | null
    }, ExtArgs["result"]["proveedor"]>
    composites: {}
  }


  type proveedorGetPayload<S extends boolean | null | undefined | proveedorDefaultArgs> = $Result.GetResult<Prisma.$proveedorPayload, S>

  type proveedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<proveedorFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProveedorCountAggregateInputType | true
    }

  export interface proveedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['proveedor'], meta: { name: 'proveedor' } }
    /**
     * Find zero or one Proveedor that matches the filter.
     * @param {proveedorFindUniqueArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends proveedorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorFindUniqueArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Proveedor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {proveedorFindUniqueOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends proveedorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends proveedorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindFirstArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Proveedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindFirstOrThrowArgs} args - Arguments to find a Proveedor
     * @example
     * // Get one Proveedor
     * const proveedor = await prisma.proveedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends proveedorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Proveedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proveedors
     * const proveedors = await prisma.proveedor.findMany()
     * 
     * // Get first 10 Proveedors
     * const proveedors = await prisma.proveedor.findMany({ take: 10 })
     * 
     * // Only select the `idProv`
     * const proveedorWithIdProvOnly = await prisma.proveedor.findMany({ select: { idProv: true } })
     * 
    **/
    findMany<T extends proveedorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Proveedor.
     * @param {proveedorCreateArgs} args - Arguments to create a Proveedor.
     * @example
     * // Create one Proveedor
     * const Proveedor = await prisma.proveedor.create({
     *   data: {
     *     // ... data to create a Proveedor
     *   }
     * })
     * 
    **/
    create<T extends proveedorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorCreateArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Proveedors.
     *     @param {proveedorCreateManyArgs} args - Arguments to create many Proveedors.
     *     @example
     *     // Create many Proveedors
     *     const proveedor = await prisma.proveedor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends proveedorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Proveedor.
     * @param {proveedorDeleteArgs} args - Arguments to delete one Proveedor.
     * @example
     * // Delete one Proveedor
     * const Proveedor = await prisma.proveedor.delete({
     *   where: {
     *     // ... filter to delete one Proveedor
     *   }
     * })
     * 
    **/
    delete<T extends proveedorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorDeleteArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Proveedor.
     * @param {proveedorUpdateArgs} args - Arguments to update one Proveedor.
     * @example
     * // Update one Proveedor
     * const proveedor = await prisma.proveedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends proveedorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpdateArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Proveedors.
     * @param {proveedorDeleteManyArgs} args - Arguments to filter Proveedors to delete.
     * @example
     * // Delete a few Proveedors
     * const { count } = await prisma.proveedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends proveedorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, proveedorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proveedors
     * const proveedor = await prisma.proveedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends proveedorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proveedor.
     * @param {proveedorUpsertArgs} args - Arguments to update or create a Proveedor.
     * @example
     * // Update or create a Proveedor
     * const proveedor = await prisma.proveedor.upsert({
     *   create: {
     *     // ... data to create a Proveedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proveedor we want to update
     *   }
     * })
    **/
    upsert<T extends proveedorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, proveedorUpsertArgs<ExtArgs>>
    ): Prisma__proveedorClient<$Result.GetResult<Prisma.$proveedorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Proveedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorCountArgs} args - Arguments to filter Proveedors to count.
     * @example
     * // Count the number of Proveedors
     * const count = await prisma.proveedor.count({
     *   where: {
     *     // ... the filter for the Proveedors we want to count
     *   }
     * })
    **/
    count<T extends proveedorCountArgs>(
      args?: Subset<T, proveedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProveedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProveedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProveedorAggregateArgs>(args: Subset<T, ProveedorAggregateArgs>): Prisma.PrismaPromise<GetProveedorAggregateType<T>>

    /**
     * Group by Proveedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {proveedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends proveedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: proveedorGroupByArgs['orderBy'] }
        : { orderBy?: proveedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, proveedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProveedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the proveedor model
   */
  readonly fields: proveedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for proveedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__proveedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    compras<T extends proveedor$comprasArgs<ExtArgs> = {}>(args?: Subset<T, proveedor$comprasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comprasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the proveedor model
   */ 
  interface proveedorFieldRefs {
    readonly idProv: FieldRef<"proveedor", 'Int'>
    readonly nombre: FieldRef<"proveedor", 'String'>
    readonly direccion: FieldRef<"proveedor", 'String'>
    readonly nit: FieldRef<"proveedor", 'String'>
    readonly tipo: FieldRef<"proveedor", 'String'>
    readonly estado: FieldRef<"proveedor", 'Int'>
    readonly email: FieldRef<"proveedor", 'String'>
    readonly telefono: FieldRef<"proveedor", 'String'>
    readonly nombreContacto: FieldRef<"proveedor", 'String'>
    readonly telefonoContacto: FieldRef<"proveedor", 'String'>
    readonly emailContacto: FieldRef<"proveedor", 'String'>
  }
    

  // Custom InputTypes

  /**
   * proveedor findUnique
   */
  export type proveedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor findUniqueOrThrow
   */
  export type proveedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor findFirst
   */
  export type proveedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor findFirstOrThrow
   */
  export type proveedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedor to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of proveedors.
     */
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor findMany
   */
  export type proveedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter, which proveedors to fetch.
     */
    where?: proveedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of proveedors to fetch.
     */
    orderBy?: proveedorOrderByWithRelationInput | proveedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing proveedors.
     */
    cursor?: proveedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` proveedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` proveedors.
     */
    skip?: number
    distinct?: ProveedorScalarFieldEnum | ProveedorScalarFieldEnum[]
  }


  /**
   * proveedor create
   */
  export type proveedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to create a proveedor.
     */
    data?: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
  }


  /**
   * proveedor createMany
   */
  export type proveedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many proveedors.
     */
    data: proveedorCreateManyInput | proveedorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * proveedor update
   */
  export type proveedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The data needed to update a proveedor.
     */
    data: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
    /**
     * Choose, which proveedor to update.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor updateMany
   */
  export type proveedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update proveedors.
     */
    data: XOR<proveedorUpdateManyMutationInput, proveedorUncheckedUpdateManyInput>
    /**
     * Filter which proveedors to update
     */
    where?: proveedorWhereInput
  }


  /**
   * proveedor upsert
   */
  export type proveedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * The filter to search for the proveedor to update in case it exists.
     */
    where: proveedorWhereUniqueInput
    /**
     * In case the proveedor found by the `where` argument doesn't exist, create a new proveedor with this data.
     */
    create: XOR<proveedorCreateInput, proveedorUncheckedCreateInput>
    /**
     * In case the proveedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<proveedorUpdateInput, proveedorUncheckedUpdateInput>
  }


  /**
   * proveedor delete
   */
  export type proveedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
    /**
     * Filter which proveedor to delete.
     */
    where: proveedorWhereUniqueInput
  }


  /**
   * proveedor deleteMany
   */
  export type proveedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which proveedors to delete
     */
    where?: proveedorWhereInput
  }


  /**
   * proveedor.compras
   */
  export type proveedor$comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the compras
     */
    select?: comprasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: comprasInclude<ExtArgs> | null
    where?: comprasWhereInput
    orderBy?: comprasOrderByWithRelationInput | comprasOrderByWithRelationInput[]
    cursor?: comprasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComprasScalarFieldEnum | ComprasScalarFieldEnum[]
  }


  /**
   * proveedor without action
   */
  export type proveedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the proveedor
     */
    select?: proveedorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: proveedorInclude<ExtArgs> | null
  }



  /**
   * Model rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    idRol: number | null
    estado: number | null
  }

  export type RolSumAggregateOutputType = {
    idRol: number | null
    estado: number | null
  }

  export type RolMinAggregateOutputType = {
    idRol: number | null
    nombre: string | null
    estado: number | null
  }

  export type RolMaxAggregateOutputType = {
    idRol: number | null
    nombre: string | null
    estado: number | null
  }

  export type RolCountAggregateOutputType = {
    idRol: number
    nombre: number
    estado: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    idRol?: true
    estado?: true
  }

  export type RolSumAggregateInputType = {
    idRol?: true
    estado?: true
  }

  export type RolMinAggregateInputType = {
    idRol?: true
    nombre?: true
    estado?: true
  }

  export type RolMaxAggregateInputType = {
    idRol?: true
    nombre?: true
    estado?: true
  }

  export type RolCountAggregateInputType = {
    idRol?: true
    nombre?: true
    estado?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rol to aggregate.
     */
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     */
    orderBy?: rolOrderByWithRelationInput | rolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type rolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolWhereInput
    orderBy?: rolOrderByWithAggregationInput | rolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: rolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    idRol: number
    nombre: string | null
    estado: number | null
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends rolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type rolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRol?: boolean
    nombre?: boolean
    estado?: boolean
    rolpermisoempleado?: boolean | rol$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type rolSelectScalar = {
    idRol?: boolean
    nombre?: boolean
    estado?: boolean
  }

  export type rolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rolpermisoempleado?: boolean | rol$rolpermisoempleadoArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $rolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rol"
    objects: {
      rolpermisoempleado: Prisma.$rolpermisoempleadoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idRol: number
      nombre: string | null
      estado: number | null
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }


  type rolGetPayload<S extends boolean | null | undefined | rolDefaultArgs> = $Result.GetResult<Prisma.$rolPayload, S>

  type rolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolCountAggregateInputType | true
    }

  export interface rolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rol'], meta: { name: 'rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {rolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rolFindUniqueArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rol that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rolFindFirstArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `idRol`
     * const rolWithIdRolOnly = await prisma.rol.findMany({ select: { idRol: true } })
     * 
    **/
    findMany<T extends rolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rol.
     * @param {rolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
    **/
    create<T extends rolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolCreateArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rols.
     *     @param {rolCreateManyArgs} args - Arguments to create many Rols.
     *     @example
     *     // Create many Rols
     *     const rol = await prisma.rol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rol.
     * @param {rolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
    **/
    delete<T extends rolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolDeleteArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rol.
     * @param {rolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolUpdateArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rols.
     * @param {rolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {rolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
    **/
    upsert<T extends rolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolUpsertArgs<ExtArgs>>
    ): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends rolCountArgs>(
      args?: Subset<T, rolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolGroupByArgs['orderBy'] }
        : { orderBy?: rolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rol model
   */
  readonly fields: rolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rolpermisoempleado<T extends rol$rolpermisoempleadoArgs<ExtArgs> = {}>(args?: Subset<T, rol$rolpermisoempleadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rol model
   */ 
  interface rolFieldRefs {
    readonly idRol: FieldRef<"rol", 'Int'>
    readonly nombre: FieldRef<"rol", 'String'>
    readonly estado: FieldRef<"rol", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rol findUnique
   */
  export type rolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter, which rol to fetch.
     */
    where: rolWhereUniqueInput
  }


  /**
   * rol findUniqueOrThrow
   */
  export type rolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter, which rol to fetch.
     */
    where: rolWhereUniqueInput
  }


  /**
   * rol findFirst
   */
  export type rolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter, which rol to fetch.
     */
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     */
    orderBy?: rolOrderByWithRelationInput | rolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rols.
     */
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * rol findFirstOrThrow
   */
  export type rolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter, which rol to fetch.
     */
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     */
    orderBy?: rolOrderByWithRelationInput | rolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rols.
     */
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * rol findMany
   */
  export type rolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter, which rols to fetch.
     */
    where?: rolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rols to fetch.
     */
    orderBy?: rolOrderByWithRelationInput | rolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rols.
     */
    cursor?: rolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * rol create
   */
  export type rolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * The data needed to create a rol.
     */
    data?: XOR<rolCreateInput, rolUncheckedCreateInput>
  }


  /**
   * rol createMany
   */
  export type rolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rols.
     */
    data: rolCreateManyInput | rolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rol update
   */
  export type rolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * The data needed to update a rol.
     */
    data: XOR<rolUpdateInput, rolUncheckedUpdateInput>
    /**
     * Choose, which rol to update.
     */
    where: rolWhereUniqueInput
  }


  /**
   * rol updateMany
   */
  export type rolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rols.
     */
    data: XOR<rolUpdateManyMutationInput, rolUncheckedUpdateManyInput>
    /**
     * Filter which rols to update
     */
    where?: rolWhereInput
  }


  /**
   * rol upsert
   */
  export type rolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * The filter to search for the rol to update in case it exists.
     */
    where: rolWhereUniqueInput
    /**
     * In case the rol found by the `where` argument doesn't exist, create a new rol with this data.
     */
    create: XOR<rolCreateInput, rolUncheckedCreateInput>
    /**
     * In case the rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolUpdateInput, rolUncheckedUpdateInput>
  }


  /**
   * rol delete
   */
  export type rolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
    /**
     * Filter which rol to delete.
     */
    where: rolWhereUniqueInput
  }


  /**
   * rol deleteMany
   */
  export type rolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rols to delete
     */
    where?: rolWhereInput
  }


  /**
   * rol.rolpermisoempleado
   */
  export type rol$rolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    where?: rolpermisoempleadoWhereInput
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    cursor?: rolpermisoempleadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * rol without action
   */
  export type rolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rol
     */
    select?: rolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolInclude<ExtArgs> | null
  }



  /**
   * Model detalle_obra
   */

  export type AggregateDetalle_obra = {
    _count: Detalle_obraCountAggregateOutputType | null
    _avg: Detalle_obraAvgAggregateOutputType | null
    _sum: Detalle_obraSumAggregateOutputType | null
    _min: Detalle_obraMinAggregateOutputType | null
    _max: Detalle_obraMaxAggregateOutputType | null
  }

  export type Detalle_obraAvgAggregateOutputType = {
    id: number | null
    fechafin: number | null
    idObra: number | null
  }

  export type Detalle_obraSumAggregateOutputType = {
    id: number | null
    fechafin: number | null
    idObra: number | null
  }

  export type Detalle_obraMinAggregateOutputType = {
    id: number | null
    actividad: string | null
    fechaini: string | null
    fechafin: number | null
    estado: string | null
    idObra: number | null
  }

  export type Detalle_obraMaxAggregateOutputType = {
    id: number | null
    actividad: string | null
    fechaini: string | null
    fechafin: number | null
    estado: string | null
    idObra: number | null
  }

  export type Detalle_obraCountAggregateOutputType = {
    id: number
    actividad: number
    fechaini: number
    fechafin: number
    estado: number
    idObra: number
    _all: number
  }


  export type Detalle_obraAvgAggregateInputType = {
    id?: true
    fechafin?: true
    idObra?: true
  }

  export type Detalle_obraSumAggregateInputType = {
    id?: true
    fechafin?: true
    idObra?: true
  }

  export type Detalle_obraMinAggregateInputType = {
    id?: true
    actividad?: true
    fechaini?: true
    fechafin?: true
    estado?: true
    idObra?: true
  }

  export type Detalle_obraMaxAggregateInputType = {
    id?: true
    actividad?: true
    fechaini?: true
    fechafin?: true
    estado?: true
    idObra?: true
  }

  export type Detalle_obraCountAggregateInputType = {
    id?: true
    actividad?: true
    fechaini?: true
    fechafin?: true
    estado?: true
    idObra?: true
    _all?: true
  }

  export type Detalle_obraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_obra to aggregate.
     */
    where?: detalle_obraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_obras to fetch.
     */
    orderBy?: detalle_obraOrderByWithRelationInput | detalle_obraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: detalle_obraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned detalle_obras
    **/
    _count?: true | Detalle_obraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Detalle_obraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Detalle_obraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Detalle_obraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Detalle_obraMaxAggregateInputType
  }

  export type GetDetalle_obraAggregateType<T extends Detalle_obraAggregateArgs> = {
        [P in keyof T & keyof AggregateDetalle_obra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDetalle_obra[P]>
      : GetScalarType<T[P], AggregateDetalle_obra[P]>
  }




  export type detalle_obraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: detalle_obraWhereInput
    orderBy?: detalle_obraOrderByWithAggregationInput | detalle_obraOrderByWithAggregationInput[]
    by: Detalle_obraScalarFieldEnum[] | Detalle_obraScalarFieldEnum
    having?: detalle_obraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Detalle_obraCountAggregateInputType | true
    _avg?: Detalle_obraAvgAggregateInputType
    _sum?: Detalle_obraSumAggregateInputType
    _min?: Detalle_obraMinAggregateInputType
    _max?: Detalle_obraMaxAggregateInputType
  }

  export type Detalle_obraGroupByOutputType = {
    id: number
    actividad: string | null
    fechaini: string | null
    fechafin: number | null
    estado: string | null
    idObra: number
    _count: Detalle_obraCountAggregateOutputType | null
    _avg: Detalle_obraAvgAggregateOutputType | null
    _sum: Detalle_obraSumAggregateOutputType | null
    _min: Detalle_obraMinAggregateOutputType | null
    _max: Detalle_obraMaxAggregateOutputType | null
  }

  type GetDetalle_obraGroupByPayload<T extends detalle_obraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Detalle_obraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Detalle_obraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Detalle_obraGroupByOutputType[P]>
            : GetScalarType<T[P], Detalle_obraGroupByOutputType[P]>
        }
      >
    >


  export type detalle_obraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actividad?: boolean
    fechaini?: boolean
    fechafin?: boolean
    estado?: boolean
    idObra?: boolean
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["detalle_obra"]>

  export type detalle_obraSelectScalar = {
    id?: boolean
    actividad?: boolean
    fechaini?: boolean
    fechafin?: boolean
    estado?: boolean
    idObra?: boolean
  }

  export type detalle_obraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }


  export type $detalle_obraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "detalle_obra"
    objects: {
      obras: Prisma.$obrasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actividad: string | null
      fechaini: string | null
      fechafin: number | null
      estado: string | null
      idObra: number
    }, ExtArgs["result"]["detalle_obra"]>
    composites: {}
  }


  type detalle_obraGetPayload<S extends boolean | null | undefined | detalle_obraDefaultArgs> = $Result.GetResult<Prisma.$detalle_obraPayload, S>

  type detalle_obraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<detalle_obraFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Detalle_obraCountAggregateInputType | true
    }

  export interface detalle_obraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['detalle_obra'], meta: { name: 'detalle_obra' } }
    /**
     * Find zero or one Detalle_obra that matches the filter.
     * @param {detalle_obraFindUniqueArgs} args - Arguments to find a Detalle_obra
     * @example
     * // Get one Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends detalle_obraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraFindUniqueArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Detalle_obra that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {detalle_obraFindUniqueOrThrowArgs} args - Arguments to find a Detalle_obra
     * @example
     * // Get one Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends detalle_obraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Detalle_obra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraFindFirstArgs} args - Arguments to find a Detalle_obra
     * @example
     * // Get one Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends detalle_obraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraFindFirstArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Detalle_obra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraFindFirstOrThrowArgs} args - Arguments to find a Detalle_obra
     * @example
     * // Get one Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends detalle_obraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Detalle_obras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Detalle_obras
     * const detalle_obras = await prisma.detalle_obra.findMany()
     * 
     * // Get first 10 Detalle_obras
     * const detalle_obras = await prisma.detalle_obra.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const detalle_obraWithIdOnly = await prisma.detalle_obra.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends detalle_obraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Detalle_obra.
     * @param {detalle_obraCreateArgs} args - Arguments to create a Detalle_obra.
     * @example
     * // Create one Detalle_obra
     * const Detalle_obra = await prisma.detalle_obra.create({
     *   data: {
     *     // ... data to create a Detalle_obra
     *   }
     * })
     * 
    **/
    create<T extends detalle_obraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraCreateArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Detalle_obras.
     *     @param {detalle_obraCreateManyArgs} args - Arguments to create many Detalle_obras.
     *     @example
     *     // Create many Detalle_obras
     *     const detalle_obra = await prisma.detalle_obra.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends detalle_obraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Detalle_obra.
     * @param {detalle_obraDeleteArgs} args - Arguments to delete one Detalle_obra.
     * @example
     * // Delete one Detalle_obra
     * const Detalle_obra = await prisma.detalle_obra.delete({
     *   where: {
     *     // ... filter to delete one Detalle_obra
     *   }
     * })
     * 
    **/
    delete<T extends detalle_obraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraDeleteArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Detalle_obra.
     * @param {detalle_obraUpdateArgs} args - Arguments to update one Detalle_obra.
     * @example
     * // Update one Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends detalle_obraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraUpdateArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Detalle_obras.
     * @param {detalle_obraDeleteManyArgs} args - Arguments to filter Detalle_obras to delete.
     * @example
     * // Delete a few Detalle_obras
     * const { count } = await prisma.detalle_obra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends detalle_obraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, detalle_obraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Detalle_obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Detalle_obras
     * const detalle_obra = await prisma.detalle_obra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends detalle_obraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Detalle_obra.
     * @param {detalle_obraUpsertArgs} args - Arguments to update or create a Detalle_obra.
     * @example
     * // Update or create a Detalle_obra
     * const detalle_obra = await prisma.detalle_obra.upsert({
     *   create: {
     *     // ... data to create a Detalle_obra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Detalle_obra we want to update
     *   }
     * })
    **/
    upsert<T extends detalle_obraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, detalle_obraUpsertArgs<ExtArgs>>
    ): Prisma__detalle_obraClient<$Result.GetResult<Prisma.$detalle_obraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Detalle_obras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraCountArgs} args - Arguments to filter Detalle_obras to count.
     * @example
     * // Count the number of Detalle_obras
     * const count = await prisma.detalle_obra.count({
     *   where: {
     *     // ... the filter for the Detalle_obras we want to count
     *   }
     * })
    **/
    count<T extends detalle_obraCountArgs>(
      args?: Subset<T, detalle_obraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Detalle_obraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Detalle_obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Detalle_obraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Detalle_obraAggregateArgs>(args: Subset<T, Detalle_obraAggregateArgs>): Prisma.PrismaPromise<GetDetalle_obraAggregateType<T>>

    /**
     * Group by Detalle_obra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {detalle_obraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends detalle_obraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: detalle_obraGroupByArgs['orderBy'] }
        : { orderBy?: detalle_obraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, detalle_obraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDetalle_obraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the detalle_obra model
   */
  readonly fields: detalle_obraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for detalle_obra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__detalle_obraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    obras<T extends obrasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, obrasDefaultArgs<ExtArgs>>): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the detalle_obra model
   */ 
  interface detalle_obraFieldRefs {
    readonly id: FieldRef<"detalle_obra", 'Int'>
    readonly actividad: FieldRef<"detalle_obra", 'String'>
    readonly fechaini: FieldRef<"detalle_obra", 'String'>
    readonly fechafin: FieldRef<"detalle_obra", 'Int'>
    readonly estado: FieldRef<"detalle_obra", 'String'>
    readonly idObra: FieldRef<"detalle_obra", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * detalle_obra findUnique
   */
  export type detalle_obraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter, which detalle_obra to fetch.
     */
    where: detalle_obraWhereUniqueInput
  }


  /**
   * detalle_obra findUniqueOrThrow
   */
  export type detalle_obraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter, which detalle_obra to fetch.
     */
    where: detalle_obraWhereUniqueInput
  }


  /**
   * detalle_obra findFirst
   */
  export type detalle_obraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter, which detalle_obra to fetch.
     */
    where?: detalle_obraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_obras to fetch.
     */
    orderBy?: detalle_obraOrderByWithRelationInput | detalle_obraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_obras.
     */
    cursor?: detalle_obraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_obras.
     */
    distinct?: Detalle_obraScalarFieldEnum | Detalle_obraScalarFieldEnum[]
  }


  /**
   * detalle_obra findFirstOrThrow
   */
  export type detalle_obraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter, which detalle_obra to fetch.
     */
    where?: detalle_obraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_obras to fetch.
     */
    orderBy?: detalle_obraOrderByWithRelationInput | detalle_obraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for detalle_obras.
     */
    cursor?: detalle_obraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_obras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of detalle_obras.
     */
    distinct?: Detalle_obraScalarFieldEnum | Detalle_obraScalarFieldEnum[]
  }


  /**
   * detalle_obra findMany
   */
  export type detalle_obraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter, which detalle_obras to fetch.
     */
    where?: detalle_obraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of detalle_obras to fetch.
     */
    orderBy?: detalle_obraOrderByWithRelationInput | detalle_obraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing detalle_obras.
     */
    cursor?: detalle_obraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` detalle_obras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` detalle_obras.
     */
    skip?: number
    distinct?: Detalle_obraScalarFieldEnum | Detalle_obraScalarFieldEnum[]
  }


  /**
   * detalle_obra create
   */
  export type detalle_obraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * The data needed to create a detalle_obra.
     */
    data: XOR<detalle_obraCreateInput, detalle_obraUncheckedCreateInput>
  }


  /**
   * detalle_obra createMany
   */
  export type detalle_obraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many detalle_obras.
     */
    data: detalle_obraCreateManyInput | detalle_obraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * detalle_obra update
   */
  export type detalle_obraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * The data needed to update a detalle_obra.
     */
    data: XOR<detalle_obraUpdateInput, detalle_obraUncheckedUpdateInput>
    /**
     * Choose, which detalle_obra to update.
     */
    where: detalle_obraWhereUniqueInput
  }


  /**
   * detalle_obra updateMany
   */
  export type detalle_obraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update detalle_obras.
     */
    data: XOR<detalle_obraUpdateManyMutationInput, detalle_obraUncheckedUpdateManyInput>
    /**
     * Filter which detalle_obras to update
     */
    where?: detalle_obraWhereInput
  }


  /**
   * detalle_obra upsert
   */
  export type detalle_obraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * The filter to search for the detalle_obra to update in case it exists.
     */
    where: detalle_obraWhereUniqueInput
    /**
     * In case the detalle_obra found by the `where` argument doesn't exist, create a new detalle_obra with this data.
     */
    create: XOR<detalle_obraCreateInput, detalle_obraUncheckedCreateInput>
    /**
     * In case the detalle_obra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<detalle_obraUpdateInput, detalle_obraUncheckedUpdateInput>
  }


  /**
   * detalle_obra delete
   */
  export type detalle_obraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
    /**
     * Filter which detalle_obra to delete.
     */
    where: detalle_obraWhereUniqueInput
  }


  /**
   * detalle_obra deleteMany
   */
  export type detalle_obraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which detalle_obras to delete
     */
    where?: detalle_obraWhereInput
  }


  /**
   * detalle_obra without action
   */
  export type detalle_obraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the detalle_obra
     */
    select?: detalle_obraSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: detalle_obraInclude<ExtArgs> | null
  }



  /**
   * Model rolpermisoempleado
   */

  export type AggregateRolpermisoempleado = {
    _count: RolpermisoempleadoCountAggregateOutputType | null
    _avg: RolpermisoempleadoAvgAggregateOutputType | null
    _sum: RolpermisoempleadoSumAggregateOutputType | null
    _min: RolpermisoempleadoMinAggregateOutputType | null
    _max: RolpermisoempleadoMaxAggregateOutputType | null
  }

  export type RolpermisoempleadoAvgAggregateOutputType = {
    id: number | null
    idRol: number | null
    idPer: number | null
    idEmp: number | null
  }

  export type RolpermisoempleadoSumAggregateOutputType = {
    id: number | null
    idRol: number | null
    idPer: number | null
    idEmp: number | null
  }

  export type RolpermisoempleadoMinAggregateOutputType = {
    id: number | null
    idRol: number | null
    idPer: number | null
    idEmp: number | null
  }

  export type RolpermisoempleadoMaxAggregateOutputType = {
    id: number | null
    idRol: number | null
    idPer: number | null
    idEmp: number | null
  }

  export type RolpermisoempleadoCountAggregateOutputType = {
    id: number
    idRol: number
    idPer: number
    idEmp: number
    _all: number
  }


  export type RolpermisoempleadoAvgAggregateInputType = {
    id?: true
    idRol?: true
    idPer?: true
    idEmp?: true
  }

  export type RolpermisoempleadoSumAggregateInputType = {
    id?: true
    idRol?: true
    idPer?: true
    idEmp?: true
  }

  export type RolpermisoempleadoMinAggregateInputType = {
    id?: true
    idRol?: true
    idPer?: true
    idEmp?: true
  }

  export type RolpermisoempleadoMaxAggregateInputType = {
    id?: true
    idRol?: true
    idPer?: true
    idEmp?: true
  }

  export type RolpermisoempleadoCountAggregateInputType = {
    id?: true
    idRol?: true
    idPer?: true
    idEmp?: true
    _all?: true
  }

  export type RolpermisoempleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolpermisoempleado to aggregate.
     */
    where?: rolpermisoempleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolpermisoempleados to fetch.
     */
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolpermisoempleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolpermisoempleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolpermisoempleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rolpermisoempleados
    **/
    _count?: true | RolpermisoempleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolpermisoempleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolpermisoempleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolpermisoempleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolpermisoempleadoMaxAggregateInputType
  }

  export type GetRolpermisoempleadoAggregateType<T extends RolpermisoempleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateRolpermisoempleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRolpermisoempleado[P]>
      : GetScalarType<T[P], AggregateRolpermisoempleado[P]>
  }




  export type rolpermisoempleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolpermisoempleadoWhereInput
    orderBy?: rolpermisoempleadoOrderByWithAggregationInput | rolpermisoempleadoOrderByWithAggregationInput[]
    by: RolpermisoempleadoScalarFieldEnum[] | RolpermisoempleadoScalarFieldEnum
    having?: rolpermisoempleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolpermisoempleadoCountAggregateInputType | true
    _avg?: RolpermisoempleadoAvgAggregateInputType
    _sum?: RolpermisoempleadoSumAggregateInputType
    _min?: RolpermisoempleadoMinAggregateInputType
    _max?: RolpermisoempleadoMaxAggregateInputType
  }

  export type RolpermisoempleadoGroupByOutputType = {
    id: number
    idRol: number
    idPer: number
    idEmp: number | null
    _count: RolpermisoempleadoCountAggregateOutputType | null
    _avg: RolpermisoempleadoAvgAggregateOutputType | null
    _sum: RolpermisoempleadoSumAggregateOutputType | null
    _min: RolpermisoempleadoMinAggregateOutputType | null
    _max: RolpermisoempleadoMaxAggregateOutputType | null
  }

  type GetRolpermisoempleadoGroupByPayload<T extends rolpermisoempleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolpermisoempleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolpermisoempleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolpermisoempleadoGroupByOutputType[P]>
            : GetScalarType<T[P], RolpermisoempleadoGroupByOutputType[P]>
        }
      >
    >


  export type rolpermisoempleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    idRol?: boolean
    idPer?: boolean
    idEmp?: boolean
    empleado?: boolean | rolpermisoempleado$empleadoArgs<ExtArgs>
    permiso?: boolean | permisoDefaultArgs<ExtArgs>
    rol?: boolean | rolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rolpermisoempleado"]>

  export type rolpermisoempleadoSelectScalar = {
    id?: boolean
    idRol?: boolean
    idPer?: boolean
    idEmp?: boolean
  }

  export type rolpermisoempleadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | rolpermisoempleado$empleadoArgs<ExtArgs>
    permiso?: boolean | permisoDefaultArgs<ExtArgs>
    rol?: boolean | rolDefaultArgs<ExtArgs>
  }


  export type $rolpermisoempleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rolpermisoempleado"
    objects: {
      empleado: Prisma.$empleadoPayload<ExtArgs> | null
      permiso: Prisma.$permisoPayload<ExtArgs>
      rol: Prisma.$rolPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      idRol: number
      idPer: number
      idEmp: number | null
    }, ExtArgs["result"]["rolpermisoempleado"]>
    composites: {}
  }


  type rolpermisoempleadoGetPayload<S extends boolean | null | undefined | rolpermisoempleadoDefaultArgs> = $Result.GetResult<Prisma.$rolpermisoempleadoPayload, S>

  type rolpermisoempleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rolpermisoempleadoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolpermisoempleadoCountAggregateInputType | true
    }

  export interface rolpermisoempleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rolpermisoempleado'], meta: { name: 'rolpermisoempleado' } }
    /**
     * Find zero or one Rolpermisoempleado that matches the filter.
     * @param {rolpermisoempleadoFindUniqueArgs} args - Arguments to find a Rolpermisoempleado
     * @example
     * // Get one Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends rolpermisoempleadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoFindUniqueArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rolpermisoempleado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {rolpermisoempleadoFindUniqueOrThrowArgs} args - Arguments to find a Rolpermisoempleado
     * @example
     * // Get one Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends rolpermisoempleadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rolpermisoempleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoFindFirstArgs} args - Arguments to find a Rolpermisoempleado
     * @example
     * // Get one Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends rolpermisoempleadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoFindFirstArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rolpermisoempleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoFindFirstOrThrowArgs} args - Arguments to find a Rolpermisoempleado
     * @example
     * // Get one Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends rolpermisoempleadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rolpermisoempleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rolpermisoempleados
     * const rolpermisoempleados = await prisma.rolpermisoempleado.findMany()
     * 
     * // Get first 10 Rolpermisoempleados
     * const rolpermisoempleados = await prisma.rolpermisoempleado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolpermisoempleadoWithIdOnly = await prisma.rolpermisoempleado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends rolpermisoempleadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rolpermisoempleado.
     * @param {rolpermisoempleadoCreateArgs} args - Arguments to create a Rolpermisoempleado.
     * @example
     * // Create one Rolpermisoempleado
     * const Rolpermisoempleado = await prisma.rolpermisoempleado.create({
     *   data: {
     *     // ... data to create a Rolpermisoempleado
     *   }
     * })
     * 
    **/
    create<T extends rolpermisoempleadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoCreateArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rolpermisoempleados.
     *     @param {rolpermisoempleadoCreateManyArgs} args - Arguments to create many Rolpermisoempleados.
     *     @example
     *     // Create many Rolpermisoempleados
     *     const rolpermisoempleado = await prisma.rolpermisoempleado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends rolpermisoempleadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rolpermisoempleado.
     * @param {rolpermisoempleadoDeleteArgs} args - Arguments to delete one Rolpermisoempleado.
     * @example
     * // Delete one Rolpermisoempleado
     * const Rolpermisoempleado = await prisma.rolpermisoempleado.delete({
     *   where: {
     *     // ... filter to delete one Rolpermisoempleado
     *   }
     * })
     * 
    **/
    delete<T extends rolpermisoempleadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoDeleteArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rolpermisoempleado.
     * @param {rolpermisoempleadoUpdateArgs} args - Arguments to update one Rolpermisoempleado.
     * @example
     * // Update one Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends rolpermisoempleadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoUpdateArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rolpermisoempleados.
     * @param {rolpermisoempleadoDeleteManyArgs} args - Arguments to filter Rolpermisoempleados to delete.
     * @example
     * // Delete a few Rolpermisoempleados
     * const { count } = await prisma.rolpermisoempleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends rolpermisoempleadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, rolpermisoempleadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rolpermisoempleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rolpermisoempleados
     * const rolpermisoempleado = await prisma.rolpermisoempleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends rolpermisoempleadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rolpermisoempleado.
     * @param {rolpermisoempleadoUpsertArgs} args - Arguments to update or create a Rolpermisoempleado.
     * @example
     * // Update or create a Rolpermisoempleado
     * const rolpermisoempleado = await prisma.rolpermisoempleado.upsert({
     *   create: {
     *     // ... data to create a Rolpermisoempleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rolpermisoempleado we want to update
     *   }
     * })
    **/
    upsert<T extends rolpermisoempleadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, rolpermisoempleadoUpsertArgs<ExtArgs>>
    ): Prisma__rolpermisoempleadoClient<$Result.GetResult<Prisma.$rolpermisoempleadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rolpermisoempleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoCountArgs} args - Arguments to filter Rolpermisoempleados to count.
     * @example
     * // Count the number of Rolpermisoempleados
     * const count = await prisma.rolpermisoempleado.count({
     *   where: {
     *     // ... the filter for the Rolpermisoempleados we want to count
     *   }
     * })
    **/
    count<T extends rolpermisoempleadoCountArgs>(
      args?: Subset<T, rolpermisoempleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolpermisoempleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rolpermisoempleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolpermisoempleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolpermisoempleadoAggregateArgs>(args: Subset<T, RolpermisoempleadoAggregateArgs>): Prisma.PrismaPromise<GetRolpermisoempleadoAggregateType<T>>

    /**
     * Group by Rolpermisoempleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolpermisoempleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolpermisoempleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolpermisoempleadoGroupByArgs['orderBy'] }
        : { orderBy?: rolpermisoempleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolpermisoempleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolpermisoempleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rolpermisoempleado model
   */
  readonly fields: rolpermisoempleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rolpermisoempleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolpermisoempleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    empleado<T extends rolpermisoempleado$empleadoArgs<ExtArgs> = {}>(args?: Subset<T, rolpermisoempleado$empleadoArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    permiso<T extends permisoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permisoDefaultArgs<ExtArgs>>): Prisma__permisoClient<$Result.GetResult<Prisma.$permisoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    rol<T extends rolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolDefaultArgs<ExtArgs>>): Prisma__rolClient<$Result.GetResult<Prisma.$rolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the rolpermisoempleado model
   */ 
  interface rolpermisoempleadoFieldRefs {
    readonly id: FieldRef<"rolpermisoempleado", 'Int'>
    readonly idRol: FieldRef<"rolpermisoempleado", 'Int'>
    readonly idPer: FieldRef<"rolpermisoempleado", 'Int'>
    readonly idEmp: FieldRef<"rolpermisoempleado", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * rolpermisoempleado findUnique
   */
  export type rolpermisoempleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter, which rolpermisoempleado to fetch.
     */
    where: rolpermisoempleadoWhereUniqueInput
  }


  /**
   * rolpermisoempleado findUniqueOrThrow
   */
  export type rolpermisoempleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter, which rolpermisoempleado to fetch.
     */
    where: rolpermisoempleadoWhereUniqueInput
  }


  /**
   * rolpermisoempleado findFirst
   */
  export type rolpermisoempleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter, which rolpermisoempleado to fetch.
     */
    where?: rolpermisoempleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolpermisoempleados to fetch.
     */
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolpermisoempleados.
     */
    cursor?: rolpermisoempleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolpermisoempleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolpermisoempleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolpermisoempleados.
     */
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * rolpermisoempleado findFirstOrThrow
   */
  export type rolpermisoempleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter, which rolpermisoempleado to fetch.
     */
    where?: rolpermisoempleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolpermisoempleados to fetch.
     */
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rolpermisoempleados.
     */
    cursor?: rolpermisoempleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolpermisoempleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolpermisoempleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rolpermisoempleados.
     */
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * rolpermisoempleado findMany
   */
  export type rolpermisoempleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter, which rolpermisoempleados to fetch.
     */
    where?: rolpermisoempleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rolpermisoempleados to fetch.
     */
    orderBy?: rolpermisoempleadoOrderByWithRelationInput | rolpermisoempleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rolpermisoempleados.
     */
    cursor?: rolpermisoempleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rolpermisoempleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rolpermisoempleados.
     */
    skip?: number
    distinct?: RolpermisoempleadoScalarFieldEnum | RolpermisoempleadoScalarFieldEnum[]
  }


  /**
   * rolpermisoempleado create
   */
  export type rolpermisoempleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * The data needed to create a rolpermisoempleado.
     */
    data: XOR<rolpermisoempleadoCreateInput, rolpermisoempleadoUncheckedCreateInput>
  }


  /**
   * rolpermisoempleado createMany
   */
  export type rolpermisoempleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rolpermisoempleados.
     */
    data: rolpermisoempleadoCreateManyInput | rolpermisoempleadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * rolpermisoempleado update
   */
  export type rolpermisoempleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * The data needed to update a rolpermisoempleado.
     */
    data: XOR<rolpermisoempleadoUpdateInput, rolpermisoempleadoUncheckedUpdateInput>
    /**
     * Choose, which rolpermisoempleado to update.
     */
    where: rolpermisoempleadoWhereUniqueInput
  }


  /**
   * rolpermisoempleado updateMany
   */
  export type rolpermisoempleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rolpermisoempleados.
     */
    data: XOR<rolpermisoempleadoUpdateManyMutationInput, rolpermisoempleadoUncheckedUpdateManyInput>
    /**
     * Filter which rolpermisoempleados to update
     */
    where?: rolpermisoempleadoWhereInput
  }


  /**
   * rolpermisoempleado upsert
   */
  export type rolpermisoempleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * The filter to search for the rolpermisoempleado to update in case it exists.
     */
    where: rolpermisoempleadoWhereUniqueInput
    /**
     * In case the rolpermisoempleado found by the `where` argument doesn't exist, create a new rolpermisoempleado with this data.
     */
    create: XOR<rolpermisoempleadoCreateInput, rolpermisoempleadoUncheckedCreateInput>
    /**
     * In case the rolpermisoempleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolpermisoempleadoUpdateInput, rolpermisoempleadoUncheckedUpdateInput>
  }


  /**
   * rolpermisoempleado delete
   */
  export type rolpermisoempleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
    /**
     * Filter which rolpermisoempleado to delete.
     */
    where: rolpermisoempleadoWhereUniqueInput
  }


  /**
   * rolpermisoempleado deleteMany
   */
  export type rolpermisoempleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rolpermisoempleados to delete
     */
    where?: rolpermisoempleadoWhereInput
  }


  /**
   * rolpermisoempleado.empleado
   */
  export type rolpermisoempleado$empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the empleado
     */
    select?: empleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: empleadoInclude<ExtArgs> | null
    where?: empleadoWhereInput
  }


  /**
   * rolpermisoempleado without action
   */
  export type rolpermisoempleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rolpermisoempleado
     */
    select?: rolpermisoempleadoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: rolpermisoempleadoInclude<ExtArgs> | null
  }



  /**
   * Model codigos
   */

  export type AggregateCodigos = {
    _count: CodigosCountAggregateOutputType | null
    _avg: CodigosAvgAggregateOutputType | null
    _sum: CodigosSumAggregateOutputType | null
    _min: CodigosMinAggregateOutputType | null
    _max: CodigosMaxAggregateOutputType | null
  }

  export type CodigosAvgAggregateOutputType = {
    Id: number | null
    estado: number | null
  }

  export type CodigosSumAggregateOutputType = {
    Id: number | null
    estado: number | null
  }

  export type CodigosMinAggregateOutputType = {
    Id: number | null
    codigo: string | null
    email: string | null
    estado: number | null
    fecha: string | null
  }

  export type CodigosMaxAggregateOutputType = {
    Id: number | null
    codigo: string | null
    email: string | null
    estado: number | null
    fecha: string | null
  }

  export type CodigosCountAggregateOutputType = {
    Id: number
    codigo: number
    email: number
    estado: number
    fecha: number
    _all: number
  }


  export type CodigosAvgAggregateInputType = {
    Id?: true
    estado?: true
  }

  export type CodigosSumAggregateInputType = {
    Id?: true
    estado?: true
  }

  export type CodigosMinAggregateInputType = {
    Id?: true
    codigo?: true
    email?: true
    estado?: true
    fecha?: true
  }

  export type CodigosMaxAggregateInputType = {
    Id?: true
    codigo?: true
    email?: true
    estado?: true
    fecha?: true
  }

  export type CodigosCountAggregateInputType = {
    Id?: true
    codigo?: true
    email?: true
    estado?: true
    fecha?: true
    _all?: true
  }

  export type CodigosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which codigos to aggregate.
     */
    where?: codigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codigos to fetch.
     */
    orderBy?: codigosOrderByWithRelationInput | codigosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: codigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codigos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codigos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned codigos
    **/
    _count?: true | CodigosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CodigosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CodigosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CodigosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CodigosMaxAggregateInputType
  }

  export type GetCodigosAggregateType<T extends CodigosAggregateArgs> = {
        [P in keyof T & keyof AggregateCodigos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCodigos[P]>
      : GetScalarType<T[P], AggregateCodigos[P]>
  }




  export type codigosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: codigosWhereInput
    orderBy?: codigosOrderByWithAggregationInput | codigosOrderByWithAggregationInput[]
    by: CodigosScalarFieldEnum[] | CodigosScalarFieldEnum
    having?: codigosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CodigosCountAggregateInputType | true
    _avg?: CodigosAvgAggregateInputType
    _sum?: CodigosSumAggregateInputType
    _min?: CodigosMinAggregateInputType
    _max?: CodigosMaxAggregateInputType
  }

  export type CodigosGroupByOutputType = {
    Id: number
    codigo: string | null
    email: string | null
    estado: number | null
    fecha: string | null
    _count: CodigosCountAggregateOutputType | null
    _avg: CodigosAvgAggregateOutputType | null
    _sum: CodigosSumAggregateOutputType | null
    _min: CodigosMinAggregateOutputType | null
    _max: CodigosMaxAggregateOutputType | null
  }

  type GetCodigosGroupByPayload<T extends codigosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CodigosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CodigosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CodigosGroupByOutputType[P]>
            : GetScalarType<T[P], CodigosGroupByOutputType[P]>
        }
      >
    >


  export type codigosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    codigo?: boolean
    email?: boolean
    estado?: boolean
    fecha?: boolean
  }, ExtArgs["result"]["codigos"]>

  export type codigosSelectScalar = {
    Id?: boolean
    codigo?: boolean
    email?: boolean
    estado?: boolean
    fecha?: boolean
  }


  export type $codigosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "codigos"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      codigo: string | null
      email: string | null
      estado: number | null
      fecha: string | null
    }, ExtArgs["result"]["codigos"]>
    composites: {}
  }


  type codigosGetPayload<S extends boolean | null | undefined | codigosDefaultArgs> = $Result.GetResult<Prisma.$codigosPayload, S>

  type codigosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<codigosFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CodigosCountAggregateInputType | true
    }

  export interface codigosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['codigos'], meta: { name: 'codigos' } }
    /**
     * Find zero or one Codigos that matches the filter.
     * @param {codigosFindUniqueArgs} args - Arguments to find a Codigos
     * @example
     * // Get one Codigos
     * const codigos = await prisma.codigos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends codigosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, codigosFindUniqueArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Codigos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {codigosFindUniqueOrThrowArgs} args - Arguments to find a Codigos
     * @example
     * // Get one Codigos
     * const codigos = await prisma.codigos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends codigosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Codigos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosFindFirstArgs} args - Arguments to find a Codigos
     * @example
     * // Get one Codigos
     * const codigos = await prisma.codigos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends codigosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosFindFirstArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Codigos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosFindFirstOrThrowArgs} args - Arguments to find a Codigos
     * @example
     * // Get one Codigos
     * const codigos = await prisma.codigos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends codigosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Codigos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Codigos
     * const codigos = await prisma.codigos.findMany()
     * 
     * // Get first 10 Codigos
     * const codigos = await prisma.codigos.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const codigosWithIdOnly = await prisma.codigos.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends codigosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Codigos.
     * @param {codigosCreateArgs} args - Arguments to create a Codigos.
     * @example
     * // Create one Codigos
     * const Codigos = await prisma.codigos.create({
     *   data: {
     *     // ... data to create a Codigos
     *   }
     * })
     * 
    **/
    create<T extends codigosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, codigosCreateArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Codigos.
     *     @param {codigosCreateManyArgs} args - Arguments to create many Codigos.
     *     @example
     *     // Create many Codigos
     *     const codigos = await prisma.codigos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends codigosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Codigos.
     * @param {codigosDeleteArgs} args - Arguments to delete one Codigos.
     * @example
     * // Delete one Codigos
     * const Codigos = await prisma.codigos.delete({
     *   where: {
     *     // ... filter to delete one Codigos
     *   }
     * })
     * 
    **/
    delete<T extends codigosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, codigosDeleteArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Codigos.
     * @param {codigosUpdateArgs} args - Arguments to update one Codigos.
     * @example
     * // Update one Codigos
     * const codigos = await prisma.codigos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends codigosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, codigosUpdateArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Codigos.
     * @param {codigosDeleteManyArgs} args - Arguments to filter Codigos to delete.
     * @example
     * // Delete a few Codigos
     * const { count } = await prisma.codigos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends codigosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, codigosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Codigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Codigos
     * const codigos = await prisma.codigos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends codigosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, codigosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Codigos.
     * @param {codigosUpsertArgs} args - Arguments to update or create a Codigos.
     * @example
     * // Update or create a Codigos
     * const codigos = await prisma.codigos.upsert({
     *   create: {
     *     // ... data to create a Codigos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Codigos we want to update
     *   }
     * })
    **/
    upsert<T extends codigosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, codigosUpsertArgs<ExtArgs>>
    ): Prisma__codigosClient<$Result.GetResult<Prisma.$codigosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Codigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosCountArgs} args - Arguments to filter Codigos to count.
     * @example
     * // Count the number of Codigos
     * const count = await prisma.codigos.count({
     *   where: {
     *     // ... the filter for the Codigos we want to count
     *   }
     * })
    **/
    count<T extends codigosCountArgs>(
      args?: Subset<T, codigosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CodigosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Codigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CodigosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CodigosAggregateArgs>(args: Subset<T, CodigosAggregateArgs>): Prisma.PrismaPromise<GetCodigosAggregateType<T>>

    /**
     * Group by Codigos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {codigosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends codigosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: codigosGroupByArgs['orderBy'] }
        : { orderBy?: codigosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, codigosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCodigosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the codigos model
   */
  readonly fields: codigosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for codigos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__codigosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the codigos model
   */ 
  interface codigosFieldRefs {
    readonly Id: FieldRef<"codigos", 'Int'>
    readonly codigo: FieldRef<"codigos", 'String'>
    readonly email: FieldRef<"codigos", 'String'>
    readonly estado: FieldRef<"codigos", 'Int'>
    readonly fecha: FieldRef<"codigos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * codigos findUnique
   */
  export type codigosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter, which codigos to fetch.
     */
    where: codigosWhereUniqueInput
  }


  /**
   * codigos findUniqueOrThrow
   */
  export type codigosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter, which codigos to fetch.
     */
    where: codigosWhereUniqueInput
  }


  /**
   * codigos findFirst
   */
  export type codigosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter, which codigos to fetch.
     */
    where?: codigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codigos to fetch.
     */
    orderBy?: codigosOrderByWithRelationInput | codigosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codigos.
     */
    cursor?: codigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codigos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codigos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codigos.
     */
    distinct?: CodigosScalarFieldEnum | CodigosScalarFieldEnum[]
  }


  /**
   * codigos findFirstOrThrow
   */
  export type codigosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter, which codigos to fetch.
     */
    where?: codigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codigos to fetch.
     */
    orderBy?: codigosOrderByWithRelationInput | codigosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for codigos.
     */
    cursor?: codigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codigos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codigos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of codigos.
     */
    distinct?: CodigosScalarFieldEnum | CodigosScalarFieldEnum[]
  }


  /**
   * codigos findMany
   */
  export type codigosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter, which codigos to fetch.
     */
    where?: codigosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of codigos to fetch.
     */
    orderBy?: codigosOrderByWithRelationInput | codigosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing codigos.
     */
    cursor?: codigosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` codigos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` codigos.
     */
    skip?: number
    distinct?: CodigosScalarFieldEnum | CodigosScalarFieldEnum[]
  }


  /**
   * codigos create
   */
  export type codigosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * The data needed to create a codigos.
     */
    data?: XOR<codigosCreateInput, codigosUncheckedCreateInput>
  }


  /**
   * codigos createMany
   */
  export type codigosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many codigos.
     */
    data: codigosCreateManyInput | codigosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * codigos update
   */
  export type codigosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * The data needed to update a codigos.
     */
    data: XOR<codigosUpdateInput, codigosUncheckedUpdateInput>
    /**
     * Choose, which codigos to update.
     */
    where: codigosWhereUniqueInput
  }


  /**
   * codigos updateMany
   */
  export type codigosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update codigos.
     */
    data: XOR<codigosUpdateManyMutationInput, codigosUncheckedUpdateManyInput>
    /**
     * Filter which codigos to update
     */
    where?: codigosWhereInput
  }


  /**
   * codigos upsert
   */
  export type codigosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * The filter to search for the codigos to update in case it exists.
     */
    where: codigosWhereUniqueInput
    /**
     * In case the codigos found by the `where` argument doesn't exist, create a new codigos with this data.
     */
    create: XOR<codigosCreateInput, codigosUncheckedCreateInput>
    /**
     * In case the codigos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<codigosUpdateInput, codigosUncheckedUpdateInput>
  }


  /**
   * codigos delete
   */
  export type codigosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
    /**
     * Filter which codigos to delete.
     */
    where: codigosWhereUniqueInput
  }


  /**
   * codigos deleteMany
   */
  export type codigosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which codigos to delete
     */
    where?: codigosWhereInput
  }


  /**
   * codigos without action
   */
  export type codigosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the codigos
     */
    select?: codigosSelect<ExtArgs> | null
  }



  /**
   * Model actividades_empleados
   */

  export type AggregateActividades_empleados = {
    _count: Actividades_empleadosCountAggregateOutputType | null
    _avg: Actividades_empleadosAvgAggregateOutputType | null
    _sum: Actividades_empleadosSumAggregateOutputType | null
    _min: Actividades_empleadosMinAggregateOutputType | null
    _max: Actividades_empleadosMaxAggregateOutputType | null
  }

  export type Actividades_empleadosAvgAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idObra: number | null
  }

  export type Actividades_empleadosSumAggregateOutputType = {
    id: number | null
    idEmp: number | null
    idObra: number | null
  }

  export type Actividades_empleadosMinAggregateOutputType = {
    id: number | null
    actividad: string | null
    idEmp: number | null
    idObra: number | null
  }

  export type Actividades_empleadosMaxAggregateOutputType = {
    id: number | null
    actividad: string | null
    idEmp: number | null
    idObra: number | null
  }

  export type Actividades_empleadosCountAggregateOutputType = {
    id: number
    actividad: number
    idEmp: number
    idObra: number
    _all: number
  }


  export type Actividades_empleadosAvgAggregateInputType = {
    id?: true
    idEmp?: true
    idObra?: true
  }

  export type Actividades_empleadosSumAggregateInputType = {
    id?: true
    idEmp?: true
    idObra?: true
  }

  export type Actividades_empleadosMinAggregateInputType = {
    id?: true
    actividad?: true
    idEmp?: true
    idObra?: true
  }

  export type Actividades_empleadosMaxAggregateInputType = {
    id?: true
    actividad?: true
    idEmp?: true
    idObra?: true
  }

  export type Actividades_empleadosCountAggregateInputType = {
    id?: true
    actividad?: true
    idEmp?: true
    idObra?: true
    _all?: true
  }

  export type Actividades_empleadosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades_empleados to aggregate.
     */
    where?: actividades_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_empleados to fetch.
     */
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: actividades_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned actividades_empleados
    **/
    _count?: true | Actividades_empleadosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Actividades_empleadosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Actividades_empleadosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Actividades_empleadosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Actividades_empleadosMaxAggregateInputType
  }

  export type GetActividades_empleadosAggregateType<T extends Actividades_empleadosAggregateArgs> = {
        [P in keyof T & keyof AggregateActividades_empleados]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividades_empleados[P]>
      : GetScalarType<T[P], AggregateActividades_empleados[P]>
  }




  export type actividades_empleadosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_empleadosWhereInput
    orderBy?: actividades_empleadosOrderByWithAggregationInput | actividades_empleadosOrderByWithAggregationInput[]
    by: Actividades_empleadosScalarFieldEnum[] | Actividades_empleadosScalarFieldEnum
    having?: actividades_empleadosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Actividades_empleadosCountAggregateInputType | true
    _avg?: Actividades_empleadosAvgAggregateInputType
    _sum?: Actividades_empleadosSumAggregateInputType
    _min?: Actividades_empleadosMinAggregateInputType
    _max?: Actividades_empleadosMaxAggregateInputType
  }

  export type Actividades_empleadosGroupByOutputType = {
    id: number
    actividad: string
    idEmp: number
    idObra: number
    _count: Actividades_empleadosCountAggregateOutputType | null
    _avg: Actividades_empleadosAvgAggregateOutputType | null
    _sum: Actividades_empleadosSumAggregateOutputType | null
    _min: Actividades_empleadosMinAggregateOutputType | null
    _max: Actividades_empleadosMaxAggregateOutputType | null
  }

  type GetActividades_empleadosGroupByPayload<T extends actividades_empleadosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Actividades_empleadosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Actividades_empleadosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Actividades_empleadosGroupByOutputType[P]>
            : GetScalarType<T[P], Actividades_empleadosGroupByOutputType[P]>
        }
      >
    >


  export type actividades_empleadosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actividad?: boolean
    idEmp?: boolean
    idObra?: boolean
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividades_empleados"]>

  export type actividades_empleadosSelectScalar = {
    id?: boolean
    actividad?: boolean
    idEmp?: boolean
    idObra?: boolean
  }

  export type actividades_empleadosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    empleado?: boolean | empleadoDefaultArgs<ExtArgs>
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }


  export type $actividades_empleadosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "actividades_empleados"
    objects: {
      empleado: Prisma.$empleadoPayload<ExtArgs>
      obras: Prisma.$obrasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actividad: string
      idEmp: number
      idObra: number
    }, ExtArgs["result"]["actividades_empleados"]>
    composites: {}
  }


  type actividades_empleadosGetPayload<S extends boolean | null | undefined | actividades_empleadosDefaultArgs> = $Result.GetResult<Prisma.$actividades_empleadosPayload, S>

  type actividades_empleadosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<actividades_empleadosFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Actividades_empleadosCountAggregateInputType | true
    }

  export interface actividades_empleadosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['actividades_empleados'], meta: { name: 'actividades_empleados' } }
    /**
     * Find zero or one Actividades_empleados that matches the filter.
     * @param {actividades_empleadosFindUniqueArgs} args - Arguments to find a Actividades_empleados
     * @example
     * // Get one Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends actividades_empleadosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosFindUniqueArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Actividades_empleados that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {actividades_empleadosFindUniqueOrThrowArgs} args - Arguments to find a Actividades_empleados
     * @example
     * // Get one Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends actividades_empleadosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Actividades_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosFindFirstArgs} args - Arguments to find a Actividades_empleados
     * @example
     * // Get one Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends actividades_empleadosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosFindFirstArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Actividades_empleados that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosFindFirstOrThrowArgs} args - Arguments to find a Actividades_empleados
     * @example
     * // Get one Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends actividades_empleadosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Actividades_empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findMany()
     * 
     * // Get first 10 Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividades_empleadosWithIdOnly = await prisma.actividades_empleados.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends actividades_empleadosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Actividades_empleados.
     * @param {actividades_empleadosCreateArgs} args - Arguments to create a Actividades_empleados.
     * @example
     * // Create one Actividades_empleados
     * const Actividades_empleados = await prisma.actividades_empleados.create({
     *   data: {
     *     // ... data to create a Actividades_empleados
     *   }
     * })
     * 
    **/
    create<T extends actividades_empleadosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosCreateArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Actividades_empleados.
     *     @param {actividades_empleadosCreateManyArgs} args - Arguments to create many Actividades_empleados.
     *     @example
     *     // Create many Actividades_empleados
     *     const actividades_empleados = await prisma.actividades_empleados.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends actividades_empleadosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actividades_empleados.
     * @param {actividades_empleadosDeleteArgs} args - Arguments to delete one Actividades_empleados.
     * @example
     * // Delete one Actividades_empleados
     * const Actividades_empleados = await prisma.actividades_empleados.delete({
     *   where: {
     *     // ... filter to delete one Actividades_empleados
     *   }
     * })
     * 
    **/
    delete<T extends actividades_empleadosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosDeleteArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Actividades_empleados.
     * @param {actividades_empleadosUpdateArgs} args - Arguments to update one Actividades_empleados.
     * @example
     * // Update one Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends actividades_empleadosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosUpdateArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Actividades_empleados.
     * @param {actividades_empleadosDeleteManyArgs} args - Arguments to filter Actividades_empleados to delete.
     * @example
     * // Delete a few Actividades_empleados
     * const { count } = await prisma.actividades_empleados.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends actividades_empleadosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_empleadosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividades_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends actividades_empleadosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividades_empleados.
     * @param {actividades_empleadosUpsertArgs} args - Arguments to update or create a Actividades_empleados.
     * @example
     * // Update or create a Actividades_empleados
     * const actividades_empleados = await prisma.actividades_empleados.upsert({
     *   create: {
     *     // ... data to create a Actividades_empleados
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividades_empleados we want to update
     *   }
     * })
    **/
    upsert<T extends actividades_empleadosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_empleadosUpsertArgs<ExtArgs>>
    ): Prisma__actividades_empleadosClient<$Result.GetResult<Prisma.$actividades_empleadosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Actividades_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosCountArgs} args - Arguments to filter Actividades_empleados to count.
     * @example
     * // Count the number of Actividades_empleados
     * const count = await prisma.actividades_empleados.count({
     *   where: {
     *     // ... the filter for the Actividades_empleados we want to count
     *   }
     * })
    **/
    count<T extends actividades_empleadosCountArgs>(
      args?: Subset<T, actividades_empleadosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Actividades_empleadosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividades_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Actividades_empleadosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Actividades_empleadosAggregateArgs>(args: Subset<T, Actividades_empleadosAggregateArgs>): Prisma.PrismaPromise<GetActividades_empleadosAggregateType<T>>

    /**
     * Group by Actividades_empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_empleadosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends actividades_empleadosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: actividades_empleadosGroupByArgs['orderBy'] }
        : { orderBy?: actividades_empleadosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, actividades_empleadosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividades_empleadosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the actividades_empleados model
   */
  readonly fields: actividades_empleadosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for actividades_empleados.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__actividades_empleadosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    empleado<T extends empleadoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, empleadoDefaultArgs<ExtArgs>>): Prisma__empleadoClient<$Result.GetResult<Prisma.$empleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    obras<T extends obrasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, obrasDefaultArgs<ExtArgs>>): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the actividades_empleados model
   */ 
  interface actividades_empleadosFieldRefs {
    readonly id: FieldRef<"actividades_empleados", 'Int'>
    readonly actividad: FieldRef<"actividades_empleados", 'String'>
    readonly idEmp: FieldRef<"actividades_empleados", 'Int'>
    readonly idObra: FieldRef<"actividades_empleados", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * actividades_empleados findUnique
   */
  export type actividades_empleadosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter, which actividades_empleados to fetch.
     */
    where: actividades_empleadosWhereUniqueInput
  }


  /**
   * actividades_empleados findUniqueOrThrow
   */
  export type actividades_empleadosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter, which actividades_empleados to fetch.
     */
    where: actividades_empleadosWhereUniqueInput
  }


  /**
   * actividades_empleados findFirst
   */
  export type actividades_empleadosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter, which actividades_empleados to fetch.
     */
    where?: actividades_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_empleados to fetch.
     */
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades_empleados.
     */
    cursor?: actividades_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades_empleados.
     */
    distinct?: Actividades_empleadosScalarFieldEnum | Actividades_empleadosScalarFieldEnum[]
  }


  /**
   * actividades_empleados findFirstOrThrow
   */
  export type actividades_empleadosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter, which actividades_empleados to fetch.
     */
    where?: actividades_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_empleados to fetch.
     */
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades_empleados.
     */
    cursor?: actividades_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades_empleados.
     */
    distinct?: Actividades_empleadosScalarFieldEnum | Actividades_empleadosScalarFieldEnum[]
  }


  /**
   * actividades_empleados findMany
   */
  export type actividades_empleadosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter, which actividades_empleados to fetch.
     */
    where?: actividades_empleadosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_empleados to fetch.
     */
    orderBy?: actividades_empleadosOrderByWithRelationInput | actividades_empleadosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing actividades_empleados.
     */
    cursor?: actividades_empleadosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_empleados.
     */
    skip?: number
    distinct?: Actividades_empleadosScalarFieldEnum | Actividades_empleadosScalarFieldEnum[]
  }


  /**
   * actividades_empleados create
   */
  export type actividades_empleadosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * The data needed to create a actividades_empleados.
     */
    data: XOR<actividades_empleadosCreateInput, actividades_empleadosUncheckedCreateInput>
  }


  /**
   * actividades_empleados createMany
   */
  export type actividades_empleadosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many actividades_empleados.
     */
    data: actividades_empleadosCreateManyInput | actividades_empleadosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * actividades_empleados update
   */
  export type actividades_empleadosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * The data needed to update a actividades_empleados.
     */
    data: XOR<actividades_empleadosUpdateInput, actividades_empleadosUncheckedUpdateInput>
    /**
     * Choose, which actividades_empleados to update.
     */
    where: actividades_empleadosWhereUniqueInput
  }


  /**
   * actividades_empleados updateMany
   */
  export type actividades_empleadosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update actividades_empleados.
     */
    data: XOR<actividades_empleadosUpdateManyMutationInput, actividades_empleadosUncheckedUpdateManyInput>
    /**
     * Filter which actividades_empleados to update
     */
    where?: actividades_empleadosWhereInput
  }


  /**
   * actividades_empleados upsert
   */
  export type actividades_empleadosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * The filter to search for the actividades_empleados to update in case it exists.
     */
    where: actividades_empleadosWhereUniqueInput
    /**
     * In case the actividades_empleados found by the `where` argument doesn't exist, create a new actividades_empleados with this data.
     */
    create: XOR<actividades_empleadosCreateInput, actividades_empleadosUncheckedCreateInput>
    /**
     * In case the actividades_empleados was found with the provided `where` argument, update it with this data.
     */
    update: XOR<actividades_empleadosUpdateInput, actividades_empleadosUncheckedUpdateInput>
  }


  /**
   * actividades_empleados delete
   */
  export type actividades_empleadosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
    /**
     * Filter which actividades_empleados to delete.
     */
    where: actividades_empleadosWhereUniqueInput
  }


  /**
   * actividades_empleados deleteMany
   */
  export type actividades_empleadosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades_empleados to delete
     */
    where?: actividades_empleadosWhereInput
  }


  /**
   * actividades_empleados without action
   */
  export type actividades_empleadosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_empleados
     */
    select?: actividades_empleadosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_empleadosInclude<ExtArgs> | null
  }



  /**
   * Model actividades_materiales
   */

  export type AggregateActividades_materiales = {
    _count: Actividades_materialesCountAggregateOutputType | null
    _avg: Actividades_materialesAvgAggregateOutputType | null
    _sum: Actividades_materialesSumAggregateOutputType | null
    _min: Actividades_materialesMinAggregateOutputType | null
    _max: Actividades_materialesMaxAggregateOutputType | null
  }

  export type Actividades_materialesAvgAggregateOutputType = {
    id: number | null
    idMat: number | null
    cantidad: number | null
    idObra: number | null
  }

  export type Actividades_materialesSumAggregateOutputType = {
    id: number | null
    idMat: number | null
    cantidad: number | null
    idObra: number | null
  }

  export type Actividades_materialesMinAggregateOutputType = {
    id: number | null
    actividad: string | null
    idMat: number | null
    cantidad: number | null
    idObra: number | null
  }

  export type Actividades_materialesMaxAggregateOutputType = {
    id: number | null
    actividad: string | null
    idMat: number | null
    cantidad: number | null
    idObra: number | null
  }

  export type Actividades_materialesCountAggregateOutputType = {
    id: number
    actividad: number
    idMat: number
    cantidad: number
    idObra: number
    _all: number
  }


  export type Actividades_materialesAvgAggregateInputType = {
    id?: true
    idMat?: true
    cantidad?: true
    idObra?: true
  }

  export type Actividades_materialesSumAggregateInputType = {
    id?: true
    idMat?: true
    cantidad?: true
    idObra?: true
  }

  export type Actividades_materialesMinAggregateInputType = {
    id?: true
    actividad?: true
    idMat?: true
    cantidad?: true
    idObra?: true
  }

  export type Actividades_materialesMaxAggregateInputType = {
    id?: true
    actividad?: true
    idMat?: true
    cantidad?: true
    idObra?: true
  }

  export type Actividades_materialesCountAggregateInputType = {
    id?: true
    actividad?: true
    idMat?: true
    cantidad?: true
    idObra?: true
    _all?: true
  }

  export type Actividades_materialesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades_materiales to aggregate.
     */
    where?: actividades_materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_materiales to fetch.
     */
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: actividades_materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned actividades_materiales
    **/
    _count?: true | Actividades_materialesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Actividades_materialesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Actividades_materialesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Actividades_materialesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Actividades_materialesMaxAggregateInputType
  }

  export type GetActividades_materialesAggregateType<T extends Actividades_materialesAggregateArgs> = {
        [P in keyof T & keyof AggregateActividades_materiales]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActividades_materiales[P]>
      : GetScalarType<T[P], AggregateActividades_materiales[P]>
  }




  export type actividades_materialesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: actividades_materialesWhereInput
    orderBy?: actividades_materialesOrderByWithAggregationInput | actividades_materialesOrderByWithAggregationInput[]
    by: Actividades_materialesScalarFieldEnum[] | Actividades_materialesScalarFieldEnum
    having?: actividades_materialesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Actividades_materialesCountAggregateInputType | true
    _avg?: Actividades_materialesAvgAggregateInputType
    _sum?: Actividades_materialesSumAggregateInputType
    _min?: Actividades_materialesMinAggregateInputType
    _max?: Actividades_materialesMaxAggregateInputType
  }

  export type Actividades_materialesGroupByOutputType = {
    id: number
    actividad: string
    idMat: number
    cantidad: number
    idObra: number
    _count: Actividades_materialesCountAggregateOutputType | null
    _avg: Actividades_materialesAvgAggregateOutputType | null
    _sum: Actividades_materialesSumAggregateOutputType | null
    _min: Actividades_materialesMinAggregateOutputType | null
    _max: Actividades_materialesMaxAggregateOutputType | null
  }

  type GetActividades_materialesGroupByPayload<T extends actividades_materialesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Actividades_materialesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Actividades_materialesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Actividades_materialesGroupByOutputType[P]>
            : GetScalarType<T[P], Actividades_materialesGroupByOutputType[P]>
        }
      >
    >


  export type actividades_materialesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actividad?: boolean
    idMat?: boolean
    cantidad?: boolean
    idObra?: boolean
    materiales?: boolean | materialesDefaultArgs<ExtArgs>
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["actividades_materiales"]>

  export type actividades_materialesSelectScalar = {
    id?: boolean
    actividad?: boolean
    idMat?: boolean
    cantidad?: boolean
    idObra?: boolean
  }

  export type actividades_materialesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materiales?: boolean | materialesDefaultArgs<ExtArgs>
    obras?: boolean | obrasDefaultArgs<ExtArgs>
  }


  export type $actividades_materialesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "actividades_materiales"
    objects: {
      materiales: Prisma.$materialesPayload<ExtArgs>
      obras: Prisma.$obrasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      actividad: string
      idMat: number
      cantidad: number
      idObra: number
    }, ExtArgs["result"]["actividades_materiales"]>
    composites: {}
  }


  type actividades_materialesGetPayload<S extends boolean | null | undefined | actividades_materialesDefaultArgs> = $Result.GetResult<Prisma.$actividades_materialesPayload, S>

  type actividades_materialesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<actividades_materialesFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Actividades_materialesCountAggregateInputType | true
    }

  export interface actividades_materialesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['actividades_materiales'], meta: { name: 'actividades_materiales' } }
    /**
     * Find zero or one Actividades_materiales that matches the filter.
     * @param {actividades_materialesFindUniqueArgs} args - Arguments to find a Actividades_materiales
     * @example
     * // Get one Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends actividades_materialesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesFindUniqueArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Actividades_materiales that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {actividades_materialesFindUniqueOrThrowArgs} args - Arguments to find a Actividades_materiales
     * @example
     * // Get one Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends actividades_materialesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Actividades_materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesFindFirstArgs} args - Arguments to find a Actividades_materiales
     * @example
     * // Get one Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends actividades_materialesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesFindFirstArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Actividades_materiales that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesFindFirstOrThrowArgs} args - Arguments to find a Actividades_materiales
     * @example
     * // Get one Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends actividades_materialesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Actividades_materiales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findMany()
     * 
     * // Get first 10 Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const actividades_materialesWithIdOnly = await prisma.actividades_materiales.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends actividades_materialesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Actividades_materiales.
     * @param {actividades_materialesCreateArgs} args - Arguments to create a Actividades_materiales.
     * @example
     * // Create one Actividades_materiales
     * const Actividades_materiales = await prisma.actividades_materiales.create({
     *   data: {
     *     // ... data to create a Actividades_materiales
     *   }
     * })
     * 
    **/
    create<T extends actividades_materialesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesCreateArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Actividades_materiales.
     *     @param {actividades_materialesCreateManyArgs} args - Arguments to create many Actividades_materiales.
     *     @example
     *     // Create many Actividades_materiales
     *     const actividades_materiales = await prisma.actividades_materiales.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends actividades_materialesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Actividades_materiales.
     * @param {actividades_materialesDeleteArgs} args - Arguments to delete one Actividades_materiales.
     * @example
     * // Delete one Actividades_materiales
     * const Actividades_materiales = await prisma.actividades_materiales.delete({
     *   where: {
     *     // ... filter to delete one Actividades_materiales
     *   }
     * })
     * 
    **/
    delete<T extends actividades_materialesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesDeleteArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Actividades_materiales.
     * @param {actividades_materialesUpdateArgs} args - Arguments to update one Actividades_materiales.
     * @example
     * // Update one Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends actividades_materialesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesUpdateArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Actividades_materiales.
     * @param {actividades_materialesDeleteManyArgs} args - Arguments to filter Actividades_materiales to delete.
     * @example
     * // Delete a few Actividades_materiales
     * const { count } = await prisma.actividades_materiales.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends actividades_materialesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, actividades_materialesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Actividades_materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends actividades_materialesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Actividades_materiales.
     * @param {actividades_materialesUpsertArgs} args - Arguments to update or create a Actividades_materiales.
     * @example
     * // Update or create a Actividades_materiales
     * const actividades_materiales = await prisma.actividades_materiales.upsert({
     *   create: {
     *     // ... data to create a Actividades_materiales
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Actividades_materiales we want to update
     *   }
     * })
    **/
    upsert<T extends actividades_materialesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, actividades_materialesUpsertArgs<ExtArgs>>
    ): Prisma__actividades_materialesClient<$Result.GetResult<Prisma.$actividades_materialesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Actividades_materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesCountArgs} args - Arguments to filter Actividades_materiales to count.
     * @example
     * // Count the number of Actividades_materiales
     * const count = await prisma.actividades_materiales.count({
     *   where: {
     *     // ... the filter for the Actividades_materiales we want to count
     *   }
     * })
    **/
    count<T extends actividades_materialesCountArgs>(
      args?: Subset<T, actividades_materialesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Actividades_materialesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Actividades_materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Actividades_materialesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Actividades_materialesAggregateArgs>(args: Subset<T, Actividades_materialesAggregateArgs>): Prisma.PrismaPromise<GetActividades_materialesAggregateType<T>>

    /**
     * Group by Actividades_materiales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {actividades_materialesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends actividades_materialesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: actividades_materialesGroupByArgs['orderBy'] }
        : { orderBy?: actividades_materialesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, actividades_materialesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActividades_materialesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the actividades_materiales model
   */
  readonly fields: actividades_materialesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for actividades_materiales.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__actividades_materialesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    materiales<T extends materialesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, materialesDefaultArgs<ExtArgs>>): Prisma__materialesClient<$Result.GetResult<Prisma.$materialesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    obras<T extends obrasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, obrasDefaultArgs<ExtArgs>>): Prisma__obrasClient<$Result.GetResult<Prisma.$obrasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the actividades_materiales model
   */ 
  interface actividades_materialesFieldRefs {
    readonly id: FieldRef<"actividades_materiales", 'Int'>
    readonly actividad: FieldRef<"actividades_materiales", 'String'>
    readonly idMat: FieldRef<"actividades_materiales", 'Int'>
    readonly cantidad: FieldRef<"actividades_materiales", 'Int'>
    readonly idObra: FieldRef<"actividades_materiales", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * actividades_materiales findUnique
   */
  export type actividades_materialesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter, which actividades_materiales to fetch.
     */
    where: actividades_materialesWhereUniqueInput
  }


  /**
   * actividades_materiales findUniqueOrThrow
   */
  export type actividades_materialesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter, which actividades_materiales to fetch.
     */
    where: actividades_materialesWhereUniqueInput
  }


  /**
   * actividades_materiales findFirst
   */
  export type actividades_materialesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter, which actividades_materiales to fetch.
     */
    where?: actividades_materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_materiales to fetch.
     */
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades_materiales.
     */
    cursor?: actividades_materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades_materiales.
     */
    distinct?: Actividades_materialesScalarFieldEnum | Actividades_materialesScalarFieldEnum[]
  }


  /**
   * actividades_materiales findFirstOrThrow
   */
  export type actividades_materialesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter, which actividades_materiales to fetch.
     */
    where?: actividades_materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_materiales to fetch.
     */
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for actividades_materiales.
     */
    cursor?: actividades_materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_materiales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of actividades_materiales.
     */
    distinct?: Actividades_materialesScalarFieldEnum | Actividades_materialesScalarFieldEnum[]
  }


  /**
   * actividades_materiales findMany
   */
  export type actividades_materialesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter, which actividades_materiales to fetch.
     */
    where?: actividades_materialesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of actividades_materiales to fetch.
     */
    orderBy?: actividades_materialesOrderByWithRelationInput | actividades_materialesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing actividades_materiales.
     */
    cursor?: actividades_materialesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` actividades_materiales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` actividades_materiales.
     */
    skip?: number
    distinct?: Actividades_materialesScalarFieldEnum | Actividades_materialesScalarFieldEnum[]
  }


  /**
   * actividades_materiales create
   */
  export type actividades_materialesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * The data needed to create a actividades_materiales.
     */
    data: XOR<actividades_materialesCreateInput, actividades_materialesUncheckedCreateInput>
  }


  /**
   * actividades_materiales createMany
   */
  export type actividades_materialesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many actividades_materiales.
     */
    data: actividades_materialesCreateManyInput | actividades_materialesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * actividades_materiales update
   */
  export type actividades_materialesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * The data needed to update a actividades_materiales.
     */
    data: XOR<actividades_materialesUpdateInput, actividades_materialesUncheckedUpdateInput>
    /**
     * Choose, which actividades_materiales to update.
     */
    where: actividades_materialesWhereUniqueInput
  }


  /**
   * actividades_materiales updateMany
   */
  export type actividades_materialesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update actividades_materiales.
     */
    data: XOR<actividades_materialesUpdateManyMutationInput, actividades_materialesUncheckedUpdateManyInput>
    /**
     * Filter which actividades_materiales to update
     */
    where?: actividades_materialesWhereInput
  }


  /**
   * actividades_materiales upsert
   */
  export type actividades_materialesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * The filter to search for the actividades_materiales to update in case it exists.
     */
    where: actividades_materialesWhereUniqueInput
    /**
     * In case the actividades_materiales found by the `where` argument doesn't exist, create a new actividades_materiales with this data.
     */
    create: XOR<actividades_materialesCreateInput, actividades_materialesUncheckedCreateInput>
    /**
     * In case the actividades_materiales was found with the provided `where` argument, update it with this data.
     */
    update: XOR<actividades_materialesUpdateInput, actividades_materialesUncheckedUpdateInput>
  }


  /**
   * actividades_materiales delete
   */
  export type actividades_materialesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
    /**
     * Filter which actividades_materiales to delete.
     */
    where: actividades_materialesWhereUniqueInput
  }


  /**
   * actividades_materiales deleteMany
   */
  export type actividades_materialesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which actividades_materiales to delete
     */
    where?: actividades_materialesWhereInput
  }


  /**
   * actividades_materiales without action
   */
  export type actividades_materialesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the actividades_materiales
     */
    select?: actividades_materialesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: actividades_materialesInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CategoriaScalarFieldEnum: {
    idcat: 'idcat',
    nombre: 'nombre',
    estado: 'estado',
    medida: 'medida'
  };

  export type CategoriaScalarFieldEnum = (typeof CategoriaScalarFieldEnum)[keyof typeof CategoriaScalarFieldEnum]


  export const ClienteScalarFieldEnum: {
    idCli: 'idCli',
    nombre: 'nombre',
    apellidos: 'apellidos',
    email: 'email',
    direccion: 'direccion',
    telefono: 'telefono',
    tipoDoc: 'tipoDoc',
    cedula: 'cedula',
    fecha_nac: 'fecha_nac',
    estado: 'estado',
    constrasena: 'constrasena',
    createdAt: 'createdAt'
  };

  export type ClienteScalarFieldEnum = (typeof ClienteScalarFieldEnum)[keyof typeof ClienteScalarFieldEnum]


  export const ComprasScalarFieldEnum: {
    idCom: 'idCom',
    fecha: 'fecha',
    imagen: 'imagen',
    total_compra: 'total_compra',
    codigoFactura: 'codigoFactura',
    idProv: 'idProv'
  };

  export type ComprasScalarFieldEnum = (typeof ComprasScalarFieldEnum)[keyof typeof ComprasScalarFieldEnum]


  export const Compras_detalleScalarFieldEnum: {
    id: 'id',
    idCompra: 'idCompra',
    idMat: 'idMat',
    cantidad: 'cantidad',
    precio: 'precio',
    subtotal: 'subtotal'
  };

  export type Compras_detalleScalarFieldEnum = (typeof Compras_detalleScalarFieldEnum)[keyof typeof Compras_detalleScalarFieldEnum]


  export const EmpleadoScalarFieldEnum: {
    idEmp: 'idEmp',
    nombre: 'nombre',
    direccion: 'direccion',
    estado: 'estado',
    email: 'email',
    telefono: 'telefono',
    cedula: 'cedula',
    tipoDoc: 'tipoDoc',
    apellidos: 'apellidos',
    contrasena: 'contrasena',
    createdAt: 'createdAt'
  };

  export type EmpleadoScalarFieldEnum = (typeof EmpleadoScalarFieldEnum)[keyof typeof EmpleadoScalarFieldEnum]


  export const Empleado_especialidadScalarFieldEnum: {
    id: 'id',
    idEmp: 'idEmp',
    idEsp: 'idEsp'
  };

  export type Empleado_especialidadScalarFieldEnum = (typeof Empleado_especialidadScalarFieldEnum)[keyof typeof Empleado_especialidadScalarFieldEnum]


  export const EspecialidadScalarFieldEnum: {
    id: 'id',
    especialidad: 'especialidad',
    estado: 'estado'
  };

  export type EspecialidadScalarFieldEnum = (typeof EspecialidadScalarFieldEnum)[keyof typeof EspecialidadScalarFieldEnum]


  export const MaterialesScalarFieldEnum: {
    idMat: 'idMat',
    nombre: 'nombre',
    estado: 'estado',
    idCategoria: 'idCategoria',
    cantidad: 'cantidad'
  };

  export type MaterialesScalarFieldEnum = (typeof MaterialesScalarFieldEnum)[keyof typeof MaterialesScalarFieldEnum]


  export const ObrasScalarFieldEnum: {
    idObra: 'idObra',
    descripcion: 'descripcion',
    fechaini: 'fechaini',
    fechafin: 'fechafin',
    area: 'area',
    idCliente: 'idCliente',
    estado: 'estado',
    precio: 'precio',
    createdAt: 'createdAt',
    idEmp: 'idEmp'
  };

  export type ObrasScalarFieldEnum = (typeof ObrasScalarFieldEnum)[keyof typeof ObrasScalarFieldEnum]


  export const PermisoScalarFieldEnum: {
    idPer: 'idPer',
    permiso: 'permiso',
    estado: 'estado'
  };

  export type PermisoScalarFieldEnum = (typeof PermisoScalarFieldEnum)[keyof typeof PermisoScalarFieldEnum]


  export const ProveedorScalarFieldEnum: {
    idProv: 'idProv',
    nombre: 'nombre',
    direccion: 'direccion',
    nit: 'nit',
    tipo: 'tipo',
    estado: 'estado',
    email: 'email',
    telefono: 'telefono',
    nombreContacto: 'nombreContacto',
    telefonoContacto: 'telefonoContacto',
    emailContacto: 'emailContacto'
  };

  export type ProveedorScalarFieldEnum = (typeof ProveedorScalarFieldEnum)[keyof typeof ProveedorScalarFieldEnum]


  export const RolScalarFieldEnum: {
    idRol: 'idRol',
    nombre: 'nombre',
    estado: 'estado'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const Detalle_obraScalarFieldEnum: {
    id: 'id',
    actividad: 'actividad',
    fechaini: 'fechaini',
    fechafin: 'fechafin',
    estado: 'estado',
    idObra: 'idObra'
  };

  export type Detalle_obraScalarFieldEnum = (typeof Detalle_obraScalarFieldEnum)[keyof typeof Detalle_obraScalarFieldEnum]


  export const RolpermisoempleadoScalarFieldEnum: {
    id: 'id',
    idRol: 'idRol',
    idPer: 'idPer',
    idEmp: 'idEmp'
  };

  export type RolpermisoempleadoScalarFieldEnum = (typeof RolpermisoempleadoScalarFieldEnum)[keyof typeof RolpermisoempleadoScalarFieldEnum]


  export const CodigosScalarFieldEnum: {
    Id: 'Id',
    codigo: 'codigo',
    email: 'email',
    estado: 'estado',
    fecha: 'fecha'
  };

  export type CodigosScalarFieldEnum = (typeof CodigosScalarFieldEnum)[keyof typeof CodigosScalarFieldEnum]


  export const Actividades_empleadosScalarFieldEnum: {
    id: 'id',
    actividad: 'actividad',
    idEmp: 'idEmp',
    idObra: 'idObra'
  };

  export type Actividades_empleadosScalarFieldEnum = (typeof Actividades_empleadosScalarFieldEnum)[keyof typeof Actividades_empleadosScalarFieldEnum]


  export const Actividades_materialesScalarFieldEnum: {
    id: 'id',
    actividad: 'actividad',
    idMat: 'idMat',
    cantidad: 'cantidad',
    idObra: 'idObra'
  };

  export type Actividades_materialesScalarFieldEnum = (typeof Actividades_materialesScalarFieldEnum)[keyof typeof Actividades_materialesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type categoriaWhereInput = {
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    idcat?: IntFilter<"categoria"> | number
    nombre?: StringNullableFilter<"categoria"> | string | null
    estado?: IntNullableFilter<"categoria"> | number | null
    medida?: StringNullableFilter<"categoria"> | string | null
    materiales?: MaterialesListRelationFilter
  }

  export type categoriaOrderByWithRelationInput = {
    idcat?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    medida?: SortOrderInput | SortOrder
    materiales?: materialesOrderByRelationAggregateInput
  }

  export type categoriaWhereUniqueInput = Prisma.AtLeast<{
    idcat?: number
    AND?: categoriaWhereInput | categoriaWhereInput[]
    OR?: categoriaWhereInput[]
    NOT?: categoriaWhereInput | categoriaWhereInput[]
    nombre?: StringNullableFilter<"categoria"> | string | null
    estado?: IntNullableFilter<"categoria"> | number | null
    medida?: StringNullableFilter<"categoria"> | string | null
    materiales?: MaterialesListRelationFilter
  }, "idcat">

  export type categoriaOrderByWithAggregationInput = {
    idcat?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    medida?: SortOrderInput | SortOrder
    _count?: categoriaCountOrderByAggregateInput
    _avg?: categoriaAvgOrderByAggregateInput
    _max?: categoriaMaxOrderByAggregateInput
    _min?: categoriaMinOrderByAggregateInput
    _sum?: categoriaSumOrderByAggregateInput
  }

  export type categoriaScalarWhereWithAggregatesInput = {
    AND?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    OR?: categoriaScalarWhereWithAggregatesInput[]
    NOT?: categoriaScalarWhereWithAggregatesInput | categoriaScalarWhereWithAggregatesInput[]
    idcat?: IntWithAggregatesFilter<"categoria"> | number
    nombre?: StringNullableWithAggregatesFilter<"categoria"> | string | null
    estado?: IntNullableWithAggregatesFilter<"categoria"> | number | null
    medida?: StringNullableWithAggregatesFilter<"categoria"> | string | null
  }

  export type clienteWhereInput = {
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    idCli?: IntFilter<"cliente"> | number
    nombre?: StringNullableFilter<"cliente"> | string | null
    apellidos?: StringNullableFilter<"cliente"> | string | null
    email?: StringNullableFilter<"cliente"> | string | null
    direccion?: StringNullableFilter<"cliente"> | string | null
    telefono?: StringNullableFilter<"cliente"> | string | null
    tipoDoc?: StringNullableFilter<"cliente"> | string | null
    cedula?: StringNullableFilter<"cliente"> | string | null
    fecha_nac?: StringNullableFilter<"cliente"> | string | null
    estado?: IntNullableFilter<"cliente"> | number | null
    constrasena?: StringNullableFilter<"cliente"> | string | null
    createdAt?: DateTimeFilter<"cliente"> | Date | string
    obras?: ObrasListRelationFilter
  }

  export type clienteOrderByWithRelationInput = {
    idCli?: SortOrder
    nombre?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    tipoDoc?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    fecha_nac?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    constrasena?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    obras?: obrasOrderByRelationAggregateInput
  }

  export type clienteWhereUniqueInput = Prisma.AtLeast<{
    idCli?: number
    AND?: clienteWhereInput | clienteWhereInput[]
    OR?: clienteWhereInput[]
    NOT?: clienteWhereInput | clienteWhereInput[]
    nombre?: StringNullableFilter<"cliente"> | string | null
    apellidos?: StringNullableFilter<"cliente"> | string | null
    email?: StringNullableFilter<"cliente"> | string | null
    direccion?: StringNullableFilter<"cliente"> | string | null
    telefono?: StringNullableFilter<"cliente"> | string | null
    tipoDoc?: StringNullableFilter<"cliente"> | string | null
    cedula?: StringNullableFilter<"cliente"> | string | null
    fecha_nac?: StringNullableFilter<"cliente"> | string | null
    estado?: IntNullableFilter<"cliente"> | number | null
    constrasena?: StringNullableFilter<"cliente"> | string | null
    createdAt?: DateTimeFilter<"cliente"> | Date | string
    obras?: ObrasListRelationFilter
  }, "idCli">

  export type clienteOrderByWithAggregationInput = {
    idCli?: SortOrder
    nombre?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    tipoDoc?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    fecha_nac?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    constrasena?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: clienteCountOrderByAggregateInput
    _avg?: clienteAvgOrderByAggregateInput
    _max?: clienteMaxOrderByAggregateInput
    _min?: clienteMinOrderByAggregateInput
    _sum?: clienteSumOrderByAggregateInput
  }

  export type clienteScalarWhereWithAggregatesInput = {
    AND?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    OR?: clienteScalarWhereWithAggregatesInput[]
    NOT?: clienteScalarWhereWithAggregatesInput | clienteScalarWhereWithAggregatesInput[]
    idCli?: IntWithAggregatesFilter<"cliente"> | number
    nombre?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    apellidos?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    email?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    tipoDoc?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    cedula?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    fecha_nac?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    estado?: IntNullableWithAggregatesFilter<"cliente"> | number | null
    constrasena?: StringNullableWithAggregatesFilter<"cliente"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"cliente"> | Date | string
  }

  export type comprasWhereInput = {
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    idCom?: IntFilter<"compras"> | number
    fecha?: StringNullableFilter<"compras"> | string | null
    imagen?: StringNullableFilter<"compras"> | string | null
    total_compra?: IntNullableFilter<"compras"> | number | null
    codigoFactura?: StringNullableFilter<"compras"> | string | null
    idProv?: IntFilter<"compras"> | number
    proveedor?: XOR<ProveedorRelationFilter, proveedorWhereInput>
    compras_detalle?: Compras_detalleListRelationFilter
  }

  export type comprasOrderByWithRelationInput = {
    idCom?: SortOrder
    fecha?: SortOrderInput | SortOrder
    imagen?: SortOrderInput | SortOrder
    total_compra?: SortOrderInput | SortOrder
    codigoFactura?: SortOrderInput | SortOrder
    idProv?: SortOrder
    proveedor?: proveedorOrderByWithRelationInput
    compras_detalle?: compras_detalleOrderByRelationAggregateInput
  }

  export type comprasWhereUniqueInput = Prisma.AtLeast<{
    idCom?: number
    AND?: comprasWhereInput | comprasWhereInput[]
    OR?: comprasWhereInput[]
    NOT?: comprasWhereInput | comprasWhereInput[]
    fecha?: StringNullableFilter<"compras"> | string | null
    imagen?: StringNullableFilter<"compras"> | string | null
    total_compra?: IntNullableFilter<"compras"> | number | null
    codigoFactura?: StringNullableFilter<"compras"> | string | null
    idProv?: IntFilter<"compras"> | number
    proveedor?: XOR<ProveedorRelationFilter, proveedorWhereInput>
    compras_detalle?: Compras_detalleListRelationFilter
  }, "idCom">

  export type comprasOrderByWithAggregationInput = {
    idCom?: SortOrder
    fecha?: SortOrderInput | SortOrder
    imagen?: SortOrderInput | SortOrder
    total_compra?: SortOrderInput | SortOrder
    codigoFactura?: SortOrderInput | SortOrder
    idProv?: SortOrder
    _count?: comprasCountOrderByAggregateInput
    _avg?: comprasAvgOrderByAggregateInput
    _max?: comprasMaxOrderByAggregateInput
    _min?: comprasMinOrderByAggregateInput
    _sum?: comprasSumOrderByAggregateInput
  }

  export type comprasScalarWhereWithAggregatesInput = {
    AND?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    OR?: comprasScalarWhereWithAggregatesInput[]
    NOT?: comprasScalarWhereWithAggregatesInput | comprasScalarWhereWithAggregatesInput[]
    idCom?: IntWithAggregatesFilter<"compras"> | number
    fecha?: StringNullableWithAggregatesFilter<"compras"> | string | null
    imagen?: StringNullableWithAggregatesFilter<"compras"> | string | null
    total_compra?: IntNullableWithAggregatesFilter<"compras"> | number | null
    codigoFactura?: StringNullableWithAggregatesFilter<"compras"> | string | null
    idProv?: IntWithAggregatesFilter<"compras"> | number
  }

  export type compras_detalleWhereInput = {
    AND?: compras_detalleWhereInput | compras_detalleWhereInput[]
    OR?: compras_detalleWhereInput[]
    NOT?: compras_detalleWhereInput | compras_detalleWhereInput[]
    id?: IntFilter<"compras_detalle"> | number
    idCompra?: IntFilter<"compras_detalle"> | number
    idMat?: IntNullableFilter<"compras_detalle"> | number | null
    cantidad?: IntNullableFilter<"compras_detalle"> | number | null
    precio?: IntNullableFilter<"compras_detalle"> | number | null
    subtotal?: IntNullableFilter<"compras_detalle"> | number | null
    compras?: XOR<ComprasRelationFilter, comprasWhereInput>
    materiales?: XOR<MaterialesNullableRelationFilter, materialesWhereInput> | null
  }

  export type compras_detalleOrderByWithRelationInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrderInput | SortOrder
    cantidad?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    compras?: comprasOrderByWithRelationInput
    materiales?: materialesOrderByWithRelationInput
  }

  export type compras_detalleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: compras_detalleWhereInput | compras_detalleWhereInput[]
    OR?: compras_detalleWhereInput[]
    NOT?: compras_detalleWhereInput | compras_detalleWhereInput[]
    idCompra?: IntFilter<"compras_detalle"> | number
    idMat?: IntNullableFilter<"compras_detalle"> | number | null
    cantidad?: IntNullableFilter<"compras_detalle"> | number | null
    precio?: IntNullableFilter<"compras_detalle"> | number | null
    subtotal?: IntNullableFilter<"compras_detalle"> | number | null
    compras?: XOR<ComprasRelationFilter, comprasWhereInput>
    materiales?: XOR<MaterialesNullableRelationFilter, materialesWhereInput> | null
  }, "id">

  export type compras_detalleOrderByWithAggregationInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrderInput | SortOrder
    cantidad?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    subtotal?: SortOrderInput | SortOrder
    _count?: compras_detalleCountOrderByAggregateInput
    _avg?: compras_detalleAvgOrderByAggregateInput
    _max?: compras_detalleMaxOrderByAggregateInput
    _min?: compras_detalleMinOrderByAggregateInput
    _sum?: compras_detalleSumOrderByAggregateInput
  }

  export type compras_detalleScalarWhereWithAggregatesInput = {
    AND?: compras_detalleScalarWhereWithAggregatesInput | compras_detalleScalarWhereWithAggregatesInput[]
    OR?: compras_detalleScalarWhereWithAggregatesInput[]
    NOT?: compras_detalleScalarWhereWithAggregatesInput | compras_detalleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"compras_detalle"> | number
    idCompra?: IntWithAggregatesFilter<"compras_detalle"> | number
    idMat?: IntNullableWithAggregatesFilter<"compras_detalle"> | number | null
    cantidad?: IntNullableWithAggregatesFilter<"compras_detalle"> | number | null
    precio?: IntNullableWithAggregatesFilter<"compras_detalle"> | number | null
    subtotal?: IntNullableWithAggregatesFilter<"compras_detalle"> | number | null
  }

  export type empleadoWhereInput = {
    AND?: empleadoWhereInput | empleadoWhereInput[]
    OR?: empleadoWhereInput[]
    NOT?: empleadoWhereInput | empleadoWhereInput[]
    idEmp?: IntFilter<"empleado"> | number
    nombre?: StringNullableFilter<"empleado"> | string | null
    direccion?: StringNullableFilter<"empleado"> | string | null
    estado?: IntNullableFilter<"empleado"> | number | null
    email?: StringNullableFilter<"empleado"> | string | null
    telefono?: StringNullableFilter<"empleado"> | string | null
    cedula?: StringNullableFilter<"empleado"> | string | null
    tipoDoc?: StringNullableFilter<"empleado"> | string | null
    apellidos?: StringNullableFilter<"empleado"> | string | null
    contrasena?: StringNullableFilter<"empleado"> | string | null
    createdAt?: DateTimeFilter<"empleado"> | Date | string
    actividades_empleados?: Actividades_empleadosListRelationFilter
    empleado_especialidad?: Empleado_especialidadListRelationFilter
    obras?: ObrasListRelationFilter
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }

  export type empleadoOrderByWithRelationInput = {
    idEmp?: SortOrder
    nombre?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    tipoDoc?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    contrasena?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actividades_empleados?: actividades_empleadosOrderByRelationAggregateInput
    empleado_especialidad?: empleado_especialidadOrderByRelationAggregateInput
    obras?: obrasOrderByRelationAggregateInput
    rolpermisoempleado?: rolpermisoempleadoOrderByRelationAggregateInput
  }

  export type empleadoWhereUniqueInput = Prisma.AtLeast<{
    idEmp?: number
    email?: string
    AND?: empleadoWhereInput | empleadoWhereInput[]
    OR?: empleadoWhereInput[]
    NOT?: empleadoWhereInput | empleadoWhereInput[]
    nombre?: StringNullableFilter<"empleado"> | string | null
    direccion?: StringNullableFilter<"empleado"> | string | null
    estado?: IntNullableFilter<"empleado"> | number | null
    telefono?: StringNullableFilter<"empleado"> | string | null
    cedula?: StringNullableFilter<"empleado"> | string | null
    tipoDoc?: StringNullableFilter<"empleado"> | string | null
    apellidos?: StringNullableFilter<"empleado"> | string | null
    contrasena?: StringNullableFilter<"empleado"> | string | null
    createdAt?: DateTimeFilter<"empleado"> | Date | string
    actividades_empleados?: Actividades_empleadosListRelationFilter
    empleado_especialidad?: Empleado_especialidadListRelationFilter
    obras?: ObrasListRelationFilter
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }, "idEmp" | "email">

  export type empleadoOrderByWithAggregationInput = {
    idEmp?: SortOrder
    nombre?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    tipoDoc?: SortOrderInput | SortOrder
    apellidos?: SortOrderInput | SortOrder
    contrasena?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: empleadoCountOrderByAggregateInput
    _avg?: empleadoAvgOrderByAggregateInput
    _max?: empleadoMaxOrderByAggregateInput
    _min?: empleadoMinOrderByAggregateInput
    _sum?: empleadoSumOrderByAggregateInput
  }

  export type empleadoScalarWhereWithAggregatesInput = {
    AND?: empleadoScalarWhereWithAggregatesInput | empleadoScalarWhereWithAggregatesInput[]
    OR?: empleadoScalarWhereWithAggregatesInput[]
    NOT?: empleadoScalarWhereWithAggregatesInput | empleadoScalarWhereWithAggregatesInput[]
    idEmp?: IntWithAggregatesFilter<"empleado"> | number
    nombre?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    estado?: IntNullableWithAggregatesFilter<"empleado"> | number | null
    email?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    cedula?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    tipoDoc?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    apellidos?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    contrasena?: StringNullableWithAggregatesFilter<"empleado"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"empleado"> | Date | string
  }

  export type empleado_especialidadWhereInput = {
    AND?: empleado_especialidadWhereInput | empleado_especialidadWhereInput[]
    OR?: empleado_especialidadWhereInput[]
    NOT?: empleado_especialidadWhereInput | empleado_especialidadWhereInput[]
    id?: IntFilter<"empleado_especialidad"> | number
    idEmp?: IntFilter<"empleado_especialidad"> | number
    idEsp?: IntFilter<"empleado_especialidad"> | number
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    especialidad?: XOR<EspecialidadRelationFilter, especialidadWhereInput>
  }

  export type empleado_especialidadOrderByWithRelationInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    especialidad?: especialidadOrderByWithRelationInput
  }

  export type empleado_especialidadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: empleado_especialidadWhereInput | empleado_especialidadWhereInput[]
    OR?: empleado_especialidadWhereInput[]
    NOT?: empleado_especialidadWhereInput | empleado_especialidadWhereInput[]
    idEmp?: IntFilter<"empleado_especialidad"> | number
    idEsp?: IntFilter<"empleado_especialidad"> | number
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    especialidad?: XOR<EspecialidadRelationFilter, especialidadWhereInput>
  }, "id">

  export type empleado_especialidadOrderByWithAggregationInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
    _count?: empleado_especialidadCountOrderByAggregateInput
    _avg?: empleado_especialidadAvgOrderByAggregateInput
    _max?: empleado_especialidadMaxOrderByAggregateInput
    _min?: empleado_especialidadMinOrderByAggregateInput
    _sum?: empleado_especialidadSumOrderByAggregateInput
  }

  export type empleado_especialidadScalarWhereWithAggregatesInput = {
    AND?: empleado_especialidadScalarWhereWithAggregatesInput | empleado_especialidadScalarWhereWithAggregatesInput[]
    OR?: empleado_especialidadScalarWhereWithAggregatesInput[]
    NOT?: empleado_especialidadScalarWhereWithAggregatesInput | empleado_especialidadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"empleado_especialidad"> | number
    idEmp?: IntWithAggregatesFilter<"empleado_especialidad"> | number
    idEsp?: IntWithAggregatesFilter<"empleado_especialidad"> | number
  }

  export type especialidadWhereInput = {
    AND?: especialidadWhereInput | especialidadWhereInput[]
    OR?: especialidadWhereInput[]
    NOT?: especialidadWhereInput | especialidadWhereInput[]
    id?: IntFilter<"especialidad"> | number
    especialidad?: StringNullableFilter<"especialidad"> | string | null
    estado?: IntNullableFilter<"especialidad"> | number | null
    empleado_especialidad?: Empleado_especialidadListRelationFilter
  }

  export type especialidadOrderByWithRelationInput = {
    id?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    empleado_especialidad?: empleado_especialidadOrderByRelationAggregateInput
  }

  export type especialidadWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: especialidadWhereInput | especialidadWhereInput[]
    OR?: especialidadWhereInput[]
    NOT?: especialidadWhereInput | especialidadWhereInput[]
    especialidad?: StringNullableFilter<"especialidad"> | string | null
    estado?: IntNullableFilter<"especialidad"> | number | null
    empleado_especialidad?: Empleado_especialidadListRelationFilter
  }, "id">

  export type especialidadOrderByWithAggregationInput = {
    id?: SortOrder
    especialidad?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: especialidadCountOrderByAggregateInput
    _avg?: especialidadAvgOrderByAggregateInput
    _max?: especialidadMaxOrderByAggregateInput
    _min?: especialidadMinOrderByAggregateInput
    _sum?: especialidadSumOrderByAggregateInput
  }

  export type especialidadScalarWhereWithAggregatesInput = {
    AND?: especialidadScalarWhereWithAggregatesInput | especialidadScalarWhereWithAggregatesInput[]
    OR?: especialidadScalarWhereWithAggregatesInput[]
    NOT?: especialidadScalarWhereWithAggregatesInput | especialidadScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"especialidad"> | number
    especialidad?: StringNullableWithAggregatesFilter<"especialidad"> | string | null
    estado?: IntNullableWithAggregatesFilter<"especialidad"> | number | null
  }

  export type materialesWhereInput = {
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    idMat?: IntFilter<"materiales"> | number
    nombre?: StringNullableFilter<"materiales"> | string | null
    estado?: IntNullableFilter<"materiales"> | number | null
    idCategoria?: IntNullableFilter<"materiales"> | number | null
    cantidad?: FloatFilter<"materiales"> | number
    actividades_materiales?: Actividades_materialesListRelationFilter
    compras_detalle?: Compras_detalleListRelationFilter
    categoria?: XOR<CategoriaNullableRelationFilter, categoriaWhereInput> | null
  }

  export type materialesOrderByWithRelationInput = {
    idMat?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idCategoria?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    actividades_materiales?: actividades_materialesOrderByRelationAggregateInput
    compras_detalle?: compras_detalleOrderByRelationAggregateInput
    categoria?: categoriaOrderByWithRelationInput
  }

  export type materialesWhereUniqueInput = Prisma.AtLeast<{
    idMat?: number
    AND?: materialesWhereInput | materialesWhereInput[]
    OR?: materialesWhereInput[]
    NOT?: materialesWhereInput | materialesWhereInput[]
    nombre?: StringNullableFilter<"materiales"> | string | null
    estado?: IntNullableFilter<"materiales"> | number | null
    idCategoria?: IntNullableFilter<"materiales"> | number | null
    cantidad?: FloatFilter<"materiales"> | number
    actividades_materiales?: Actividades_materialesListRelationFilter
    compras_detalle?: Compras_detalleListRelationFilter
    categoria?: XOR<CategoriaNullableRelationFilter, categoriaWhereInput> | null
  }, "idMat">

  export type materialesOrderByWithAggregationInput = {
    idMat?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idCategoria?: SortOrderInput | SortOrder
    cantidad?: SortOrder
    _count?: materialesCountOrderByAggregateInput
    _avg?: materialesAvgOrderByAggregateInput
    _max?: materialesMaxOrderByAggregateInput
    _min?: materialesMinOrderByAggregateInput
    _sum?: materialesSumOrderByAggregateInput
  }

  export type materialesScalarWhereWithAggregatesInput = {
    AND?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    OR?: materialesScalarWhereWithAggregatesInput[]
    NOT?: materialesScalarWhereWithAggregatesInput | materialesScalarWhereWithAggregatesInput[]
    idMat?: IntWithAggregatesFilter<"materiales"> | number
    nombre?: StringNullableWithAggregatesFilter<"materiales"> | string | null
    estado?: IntNullableWithAggregatesFilter<"materiales"> | number | null
    idCategoria?: IntNullableWithAggregatesFilter<"materiales"> | number | null
    cantidad?: FloatWithAggregatesFilter<"materiales"> | number
  }

  export type obrasWhereInput = {
    AND?: obrasWhereInput | obrasWhereInput[]
    OR?: obrasWhereInput[]
    NOT?: obrasWhereInput | obrasWhereInput[]
    idObra?: IntFilter<"obras"> | number
    descripcion?: StringNullableFilter<"obras"> | string | null
    fechaini?: StringNullableFilter<"obras"> | string | null
    fechafin?: StringNullableFilter<"obras"> | string | null
    area?: StringNullableFilter<"obras"> | string | null
    idCliente?: IntNullableFilter<"obras"> | number | null
    estado?: StringNullableFilter<"obras"> | string | null
    precio?: IntNullableFilter<"obras"> | number | null
    createdAt?: DateTimeFilter<"obras"> | Date | string
    idEmp?: IntFilter<"obras"> | number
    actividades_empleados?: Actividades_empleadosListRelationFilter
    actividades_materiales?: Actividades_materialesListRelationFilter
    detalle_obra?: Detalle_obraListRelationFilter
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
  }

  export type obrasOrderByWithRelationInput = {
    idObra?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaini?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    idCliente?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    idEmp?: SortOrder
    actividades_empleados?: actividades_empleadosOrderByRelationAggregateInput
    actividades_materiales?: actividades_materialesOrderByRelationAggregateInput
    detalle_obra?: detalle_obraOrderByRelationAggregateInput
    empleado?: empleadoOrderByWithRelationInput
    cliente?: clienteOrderByWithRelationInput
  }

  export type obrasWhereUniqueInput = Prisma.AtLeast<{
    idObra?: number
    AND?: obrasWhereInput | obrasWhereInput[]
    OR?: obrasWhereInput[]
    NOT?: obrasWhereInput | obrasWhereInput[]
    descripcion?: StringNullableFilter<"obras"> | string | null
    fechaini?: StringNullableFilter<"obras"> | string | null
    fechafin?: StringNullableFilter<"obras"> | string | null
    area?: StringNullableFilter<"obras"> | string | null
    idCliente?: IntNullableFilter<"obras"> | number | null
    estado?: StringNullableFilter<"obras"> | string | null
    precio?: IntNullableFilter<"obras"> | number | null
    createdAt?: DateTimeFilter<"obras"> | Date | string
    idEmp?: IntFilter<"obras"> | number
    actividades_empleados?: Actividades_empleadosListRelationFilter
    actividades_materiales?: Actividades_materialesListRelationFilter
    detalle_obra?: Detalle_obraListRelationFilter
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    cliente?: XOR<ClienteNullableRelationFilter, clienteWhereInput> | null
  }, "idObra">

  export type obrasOrderByWithAggregationInput = {
    idObra?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaini?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    area?: SortOrderInput | SortOrder
    idCliente?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    precio?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    idEmp?: SortOrder
    _count?: obrasCountOrderByAggregateInput
    _avg?: obrasAvgOrderByAggregateInput
    _max?: obrasMaxOrderByAggregateInput
    _min?: obrasMinOrderByAggregateInput
    _sum?: obrasSumOrderByAggregateInput
  }

  export type obrasScalarWhereWithAggregatesInput = {
    AND?: obrasScalarWhereWithAggregatesInput | obrasScalarWhereWithAggregatesInput[]
    OR?: obrasScalarWhereWithAggregatesInput[]
    NOT?: obrasScalarWhereWithAggregatesInput | obrasScalarWhereWithAggregatesInput[]
    idObra?: IntWithAggregatesFilter<"obras"> | number
    descripcion?: StringNullableWithAggregatesFilter<"obras"> | string | null
    fechaini?: StringNullableWithAggregatesFilter<"obras"> | string | null
    fechafin?: StringNullableWithAggregatesFilter<"obras"> | string | null
    area?: StringNullableWithAggregatesFilter<"obras"> | string | null
    idCliente?: IntNullableWithAggregatesFilter<"obras"> | number | null
    estado?: StringNullableWithAggregatesFilter<"obras"> | string | null
    precio?: IntNullableWithAggregatesFilter<"obras"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"obras"> | Date | string
    idEmp?: IntWithAggregatesFilter<"obras"> | number
  }

  export type permisoWhereInput = {
    AND?: permisoWhereInput | permisoWhereInput[]
    OR?: permisoWhereInput[]
    NOT?: permisoWhereInput | permisoWhereInput[]
    idPer?: IntFilter<"permiso"> | number
    permiso?: StringNullableFilter<"permiso"> | string | null
    estado?: IntNullableFilter<"permiso"> | number | null
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }

  export type permisoOrderByWithRelationInput = {
    idPer?: SortOrder
    permiso?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    rolpermisoempleado?: rolpermisoempleadoOrderByRelationAggregateInput
  }

  export type permisoWhereUniqueInput = Prisma.AtLeast<{
    idPer?: number
    AND?: permisoWhereInput | permisoWhereInput[]
    OR?: permisoWhereInput[]
    NOT?: permisoWhereInput | permisoWhereInput[]
    permiso?: StringNullableFilter<"permiso"> | string | null
    estado?: IntNullableFilter<"permiso"> | number | null
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }, "idPer">

  export type permisoOrderByWithAggregationInput = {
    idPer?: SortOrder
    permiso?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: permisoCountOrderByAggregateInput
    _avg?: permisoAvgOrderByAggregateInput
    _max?: permisoMaxOrderByAggregateInput
    _min?: permisoMinOrderByAggregateInput
    _sum?: permisoSumOrderByAggregateInput
  }

  export type permisoScalarWhereWithAggregatesInput = {
    AND?: permisoScalarWhereWithAggregatesInput | permisoScalarWhereWithAggregatesInput[]
    OR?: permisoScalarWhereWithAggregatesInput[]
    NOT?: permisoScalarWhereWithAggregatesInput | permisoScalarWhereWithAggregatesInput[]
    idPer?: IntWithAggregatesFilter<"permiso"> | number
    permiso?: StringNullableWithAggregatesFilter<"permiso"> | string | null
    estado?: IntNullableWithAggregatesFilter<"permiso"> | number | null
  }

  export type proveedorWhereInput = {
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    idProv?: IntFilter<"proveedor"> | number
    nombre?: StringNullableFilter<"proveedor"> | string | null
    direccion?: StringNullableFilter<"proveedor"> | string | null
    nit?: StringNullableFilter<"proveedor"> | string | null
    tipo?: StringNullableFilter<"proveedor"> | string | null
    estado?: IntNullableFilter<"proveedor"> | number | null
    email?: StringNullableFilter<"proveedor"> | string | null
    telefono?: StringNullableFilter<"proveedor"> | string | null
    nombreContacto?: StringNullableFilter<"proveedor"> | string | null
    telefonoContacto?: StringNullableFilter<"proveedor"> | string | null
    emailContacto?: StringNullableFilter<"proveedor"> | string | null
    compras?: ComprasListRelationFilter
  }

  export type proveedorOrderByWithRelationInput = {
    idProv?: SortOrder
    nombre?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    nombreContacto?: SortOrderInput | SortOrder
    telefonoContacto?: SortOrderInput | SortOrder
    emailContacto?: SortOrderInput | SortOrder
    compras?: comprasOrderByRelationAggregateInput
  }

  export type proveedorWhereUniqueInput = Prisma.AtLeast<{
    idProv?: number
    AND?: proveedorWhereInput | proveedorWhereInput[]
    OR?: proveedorWhereInput[]
    NOT?: proveedorWhereInput | proveedorWhereInput[]
    nombre?: StringNullableFilter<"proveedor"> | string | null
    direccion?: StringNullableFilter<"proveedor"> | string | null
    nit?: StringNullableFilter<"proveedor"> | string | null
    tipo?: StringNullableFilter<"proveedor"> | string | null
    estado?: IntNullableFilter<"proveedor"> | number | null
    email?: StringNullableFilter<"proveedor"> | string | null
    telefono?: StringNullableFilter<"proveedor"> | string | null
    nombreContacto?: StringNullableFilter<"proveedor"> | string | null
    telefonoContacto?: StringNullableFilter<"proveedor"> | string | null
    emailContacto?: StringNullableFilter<"proveedor"> | string | null
    compras?: ComprasListRelationFilter
  }, "idProv">

  export type proveedorOrderByWithAggregationInput = {
    idProv?: SortOrder
    nombre?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    nit?: SortOrderInput | SortOrder
    tipo?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    nombreContacto?: SortOrderInput | SortOrder
    telefonoContacto?: SortOrderInput | SortOrder
    emailContacto?: SortOrderInput | SortOrder
    _count?: proveedorCountOrderByAggregateInput
    _avg?: proveedorAvgOrderByAggregateInput
    _max?: proveedorMaxOrderByAggregateInput
    _min?: proveedorMinOrderByAggregateInput
    _sum?: proveedorSumOrderByAggregateInput
  }

  export type proveedorScalarWhereWithAggregatesInput = {
    AND?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    OR?: proveedorScalarWhereWithAggregatesInput[]
    NOT?: proveedorScalarWhereWithAggregatesInput | proveedorScalarWhereWithAggregatesInput[]
    idProv?: IntWithAggregatesFilter<"proveedor"> | number
    nombre?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    nit?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    tipo?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    estado?: IntNullableWithAggregatesFilter<"proveedor"> | number | null
    email?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    nombreContacto?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    telefonoContacto?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
    emailContacto?: StringNullableWithAggregatesFilter<"proveedor"> | string | null
  }

  export type rolWhereInput = {
    AND?: rolWhereInput | rolWhereInput[]
    OR?: rolWhereInput[]
    NOT?: rolWhereInput | rolWhereInput[]
    idRol?: IntFilter<"rol"> | number
    nombre?: StringNullableFilter<"rol"> | string | null
    estado?: IntNullableFilter<"rol"> | number | null
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }

  export type rolOrderByWithRelationInput = {
    idRol?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    rolpermisoempleado?: rolpermisoempleadoOrderByRelationAggregateInput
  }

  export type rolWhereUniqueInput = Prisma.AtLeast<{
    idRol?: number
    AND?: rolWhereInput | rolWhereInput[]
    OR?: rolWhereInput[]
    NOT?: rolWhereInput | rolWhereInput[]
    nombre?: StringNullableFilter<"rol"> | string | null
    estado?: IntNullableFilter<"rol"> | number | null
    rolpermisoempleado?: RolpermisoempleadoListRelationFilter
  }, "idRol">

  export type rolOrderByWithAggregationInput = {
    idRol?: SortOrder
    nombre?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    _count?: rolCountOrderByAggregateInput
    _avg?: rolAvgOrderByAggregateInput
    _max?: rolMaxOrderByAggregateInput
    _min?: rolMinOrderByAggregateInput
    _sum?: rolSumOrderByAggregateInput
  }

  export type rolScalarWhereWithAggregatesInput = {
    AND?: rolScalarWhereWithAggregatesInput | rolScalarWhereWithAggregatesInput[]
    OR?: rolScalarWhereWithAggregatesInput[]
    NOT?: rolScalarWhereWithAggregatesInput | rolScalarWhereWithAggregatesInput[]
    idRol?: IntWithAggregatesFilter<"rol"> | number
    nombre?: StringNullableWithAggregatesFilter<"rol"> | string | null
    estado?: IntNullableWithAggregatesFilter<"rol"> | number | null
  }

  export type detalle_obraWhereInput = {
    AND?: detalle_obraWhereInput | detalle_obraWhereInput[]
    OR?: detalle_obraWhereInput[]
    NOT?: detalle_obraWhereInput | detalle_obraWhereInput[]
    id?: IntFilter<"detalle_obra"> | number
    actividad?: StringNullableFilter<"detalle_obra"> | string | null
    fechaini?: StringNullableFilter<"detalle_obra"> | string | null
    fechafin?: IntNullableFilter<"detalle_obra"> | number | null
    estado?: StringNullableFilter<"detalle_obra"> | string | null
    idObra?: IntFilter<"detalle_obra"> | number
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }

  export type detalle_obraOrderByWithRelationInput = {
    id?: SortOrder
    actividad?: SortOrderInput | SortOrder
    fechaini?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idObra?: SortOrder
    obras?: obrasOrderByWithRelationInput
  }

  export type detalle_obraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: detalle_obraWhereInput | detalle_obraWhereInput[]
    OR?: detalle_obraWhereInput[]
    NOT?: detalle_obraWhereInput | detalle_obraWhereInput[]
    actividad?: StringNullableFilter<"detalle_obra"> | string | null
    fechaini?: StringNullableFilter<"detalle_obra"> | string | null
    fechafin?: IntNullableFilter<"detalle_obra"> | number | null
    estado?: StringNullableFilter<"detalle_obra"> | string | null
    idObra?: IntFilter<"detalle_obra"> | number
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }, "id">

  export type detalle_obraOrderByWithAggregationInput = {
    id?: SortOrder
    actividad?: SortOrderInput | SortOrder
    fechaini?: SortOrderInput | SortOrder
    fechafin?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    idObra?: SortOrder
    _count?: detalle_obraCountOrderByAggregateInput
    _avg?: detalle_obraAvgOrderByAggregateInput
    _max?: detalle_obraMaxOrderByAggregateInput
    _min?: detalle_obraMinOrderByAggregateInput
    _sum?: detalle_obraSumOrderByAggregateInput
  }

  export type detalle_obraScalarWhereWithAggregatesInput = {
    AND?: detalle_obraScalarWhereWithAggregatesInput | detalle_obraScalarWhereWithAggregatesInput[]
    OR?: detalle_obraScalarWhereWithAggregatesInput[]
    NOT?: detalle_obraScalarWhereWithAggregatesInput | detalle_obraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"detalle_obra"> | number
    actividad?: StringNullableWithAggregatesFilter<"detalle_obra"> | string | null
    fechaini?: StringNullableWithAggregatesFilter<"detalle_obra"> | string | null
    fechafin?: IntNullableWithAggregatesFilter<"detalle_obra"> | number | null
    estado?: StringNullableWithAggregatesFilter<"detalle_obra"> | string | null
    idObra?: IntWithAggregatesFilter<"detalle_obra"> | number
  }

  export type rolpermisoempleadoWhereInput = {
    AND?: rolpermisoempleadoWhereInput | rolpermisoempleadoWhereInput[]
    OR?: rolpermisoempleadoWhereInput[]
    NOT?: rolpermisoempleadoWhereInput | rolpermisoempleadoWhereInput[]
    id?: IntFilter<"rolpermisoempleado"> | number
    idRol?: IntFilter<"rolpermisoempleado"> | number
    idPer?: IntFilter<"rolpermisoempleado"> | number
    idEmp?: IntNullableFilter<"rolpermisoempleado"> | number | null
    empleado?: XOR<EmpleadoNullableRelationFilter, empleadoWhereInput> | null
    permiso?: XOR<PermisoRelationFilter, permisoWhereInput>
    rol?: XOR<RolRelationFilter, rolWhereInput>
  }

  export type rolpermisoempleadoOrderByWithRelationInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrderInput | SortOrder
    empleado?: empleadoOrderByWithRelationInput
    permiso?: permisoOrderByWithRelationInput
    rol?: rolOrderByWithRelationInput
  }

  export type rolpermisoempleadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: rolpermisoempleadoWhereInput | rolpermisoempleadoWhereInput[]
    OR?: rolpermisoempleadoWhereInput[]
    NOT?: rolpermisoempleadoWhereInput | rolpermisoempleadoWhereInput[]
    idRol?: IntFilter<"rolpermisoempleado"> | number
    idPer?: IntFilter<"rolpermisoempleado"> | number
    idEmp?: IntNullableFilter<"rolpermisoempleado"> | number | null
    empleado?: XOR<EmpleadoNullableRelationFilter, empleadoWhereInput> | null
    permiso?: XOR<PermisoRelationFilter, permisoWhereInput>
    rol?: XOR<RolRelationFilter, rolWhereInput>
  }, "id">

  export type rolpermisoempleadoOrderByWithAggregationInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrderInput | SortOrder
    _count?: rolpermisoempleadoCountOrderByAggregateInput
    _avg?: rolpermisoempleadoAvgOrderByAggregateInput
    _max?: rolpermisoempleadoMaxOrderByAggregateInput
    _min?: rolpermisoempleadoMinOrderByAggregateInput
    _sum?: rolpermisoempleadoSumOrderByAggregateInput
  }

  export type rolpermisoempleadoScalarWhereWithAggregatesInput = {
    AND?: rolpermisoempleadoScalarWhereWithAggregatesInput | rolpermisoempleadoScalarWhereWithAggregatesInput[]
    OR?: rolpermisoempleadoScalarWhereWithAggregatesInput[]
    NOT?: rolpermisoempleadoScalarWhereWithAggregatesInput | rolpermisoempleadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"rolpermisoempleado"> | number
    idRol?: IntWithAggregatesFilter<"rolpermisoempleado"> | number
    idPer?: IntWithAggregatesFilter<"rolpermisoempleado"> | number
    idEmp?: IntNullableWithAggregatesFilter<"rolpermisoempleado"> | number | null
  }

  export type codigosWhereInput = {
    AND?: codigosWhereInput | codigosWhereInput[]
    OR?: codigosWhereInput[]
    NOT?: codigosWhereInput | codigosWhereInput[]
    Id?: IntFilter<"codigos"> | number
    codigo?: StringNullableFilter<"codigos"> | string | null
    email?: StringNullableFilter<"codigos"> | string | null
    estado?: IntNullableFilter<"codigos"> | number | null
    fecha?: StringNullableFilter<"codigos"> | string | null
  }

  export type codigosOrderByWithRelationInput = {
    Id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
  }

  export type codigosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    codigo?: string
    AND?: codigosWhereInput | codigosWhereInput[]
    OR?: codigosWhereInput[]
    NOT?: codigosWhereInput | codigosWhereInput[]
    email?: StringNullableFilter<"codigos"> | string | null
    estado?: IntNullableFilter<"codigos"> | number | null
    fecha?: StringNullableFilter<"codigos"> | string | null
  }, "Id" | "codigo">

  export type codigosOrderByWithAggregationInput = {
    Id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    fecha?: SortOrderInput | SortOrder
    _count?: codigosCountOrderByAggregateInput
    _avg?: codigosAvgOrderByAggregateInput
    _max?: codigosMaxOrderByAggregateInput
    _min?: codigosMinOrderByAggregateInput
    _sum?: codigosSumOrderByAggregateInput
  }

  export type codigosScalarWhereWithAggregatesInput = {
    AND?: codigosScalarWhereWithAggregatesInput | codigosScalarWhereWithAggregatesInput[]
    OR?: codigosScalarWhereWithAggregatesInput[]
    NOT?: codigosScalarWhereWithAggregatesInput | codigosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"codigos"> | number
    codigo?: StringNullableWithAggregatesFilter<"codigos"> | string | null
    email?: StringNullableWithAggregatesFilter<"codigos"> | string | null
    estado?: IntNullableWithAggregatesFilter<"codigos"> | number | null
    fecha?: StringNullableWithAggregatesFilter<"codigos"> | string | null
  }

  export type actividades_empleadosWhereInput = {
    AND?: actividades_empleadosWhereInput | actividades_empleadosWhereInput[]
    OR?: actividades_empleadosWhereInput[]
    NOT?: actividades_empleadosWhereInput | actividades_empleadosWhereInput[]
    id?: IntFilter<"actividades_empleados"> | number
    actividad?: StringFilter<"actividades_empleados"> | string
    idEmp?: IntFilter<"actividades_empleados"> | number
    idObra?: IntFilter<"actividades_empleados"> | number
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }

  export type actividades_empleadosOrderByWithRelationInput = {
    id?: SortOrder
    actividad?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
    empleado?: empleadoOrderByWithRelationInput
    obras?: obrasOrderByWithRelationInput
  }

  export type actividades_empleadosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: actividades_empleadosWhereInput | actividades_empleadosWhereInput[]
    OR?: actividades_empleadosWhereInput[]
    NOT?: actividades_empleadosWhereInput | actividades_empleadosWhereInput[]
    actividad?: StringFilter<"actividades_empleados"> | string
    idEmp?: IntFilter<"actividades_empleados"> | number
    idObra?: IntFilter<"actividades_empleados"> | number
    empleado?: XOR<EmpleadoRelationFilter, empleadoWhereInput>
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }, "id">

  export type actividades_empleadosOrderByWithAggregationInput = {
    id?: SortOrder
    actividad?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
    _count?: actividades_empleadosCountOrderByAggregateInput
    _avg?: actividades_empleadosAvgOrderByAggregateInput
    _max?: actividades_empleadosMaxOrderByAggregateInput
    _min?: actividades_empleadosMinOrderByAggregateInput
    _sum?: actividades_empleadosSumOrderByAggregateInput
  }

  export type actividades_empleadosScalarWhereWithAggregatesInput = {
    AND?: actividades_empleadosScalarWhereWithAggregatesInput | actividades_empleadosScalarWhereWithAggregatesInput[]
    OR?: actividades_empleadosScalarWhereWithAggregatesInput[]
    NOT?: actividades_empleadosScalarWhereWithAggregatesInput | actividades_empleadosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"actividades_empleados"> | number
    actividad?: StringWithAggregatesFilter<"actividades_empleados"> | string
    idEmp?: IntWithAggregatesFilter<"actividades_empleados"> | number
    idObra?: IntWithAggregatesFilter<"actividades_empleados"> | number
  }

  export type actividades_materialesWhereInput = {
    AND?: actividades_materialesWhereInput | actividades_materialesWhereInput[]
    OR?: actividades_materialesWhereInput[]
    NOT?: actividades_materialesWhereInput | actividades_materialesWhereInput[]
    id?: IntFilter<"actividades_materiales"> | number
    actividad?: StringFilter<"actividades_materiales"> | string
    idMat?: IntFilter<"actividades_materiales"> | number
    cantidad?: IntFilter<"actividades_materiales"> | number
    idObra?: IntFilter<"actividades_materiales"> | number
    materiales?: XOR<MaterialesRelationFilter, materialesWhereInput>
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }

  export type actividades_materialesOrderByWithRelationInput = {
    id?: SortOrder
    actividad?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
    materiales?: materialesOrderByWithRelationInput
    obras?: obrasOrderByWithRelationInput
  }

  export type actividades_materialesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: actividades_materialesWhereInput | actividades_materialesWhereInput[]
    OR?: actividades_materialesWhereInput[]
    NOT?: actividades_materialesWhereInput | actividades_materialesWhereInput[]
    actividad?: StringFilter<"actividades_materiales"> | string
    idMat?: IntFilter<"actividades_materiales"> | number
    cantidad?: IntFilter<"actividades_materiales"> | number
    idObra?: IntFilter<"actividades_materiales"> | number
    materiales?: XOR<MaterialesRelationFilter, materialesWhereInput>
    obras?: XOR<ObrasRelationFilter, obrasWhereInput>
  }, "id">

  export type actividades_materialesOrderByWithAggregationInput = {
    id?: SortOrder
    actividad?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
    _count?: actividades_materialesCountOrderByAggregateInput
    _avg?: actividades_materialesAvgOrderByAggregateInput
    _max?: actividades_materialesMaxOrderByAggregateInput
    _min?: actividades_materialesMinOrderByAggregateInput
    _sum?: actividades_materialesSumOrderByAggregateInput
  }

  export type actividades_materialesScalarWhereWithAggregatesInput = {
    AND?: actividades_materialesScalarWhereWithAggregatesInput | actividades_materialesScalarWhereWithAggregatesInput[]
    OR?: actividades_materialesScalarWhereWithAggregatesInput[]
    NOT?: actividades_materialesScalarWhereWithAggregatesInput | actividades_materialesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"actividades_materiales"> | number
    actividad?: StringWithAggregatesFilter<"actividades_materiales"> | string
    idMat?: IntWithAggregatesFilter<"actividades_materiales"> | number
    cantidad?: IntWithAggregatesFilter<"actividades_materiales"> | number
    idObra?: IntWithAggregatesFilter<"actividades_materiales"> | number
  }

  export type categoriaCreateInput = {
    nombre?: string | null
    estado?: number | null
    medida?: string | null
    materiales?: materialesCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUncheckedCreateInput = {
    idcat?: number
    nombre?: string | null
    estado?: number | null
    medida?: string | null
    materiales?: materialesUncheckedCreateNestedManyWithoutCategoriaInput
  }

  export type categoriaUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
    materiales?: materialesUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaUncheckedUpdateInput = {
    idcat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
    materiales?: materialesUncheckedUpdateManyWithoutCategoriaNestedInput
  }

  export type categoriaCreateManyInput = {
    idcat?: number
    nombre?: string | null
    estado?: number | null
    medida?: string | null
  }

  export type categoriaUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriaUncheckedUpdateManyInput = {
    idcat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type clienteCreateInput = {
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    direccion?: string | null
    telefono?: string | null
    tipoDoc?: string | null
    cedula?: string | null
    fecha_nac?: string | null
    estado?: number | null
    constrasena?: string | null
    createdAt?: Date | string
    obras?: obrasCreateNestedManyWithoutClienteInput
  }

  export type clienteUncheckedCreateInput = {
    idCli?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    direccion?: string | null
    telefono?: string | null
    tipoDoc?: string | null
    cedula?: string | null
    fecha_nac?: string | null
    estado?: number | null
    constrasena?: string | null
    createdAt?: Date | string
    obras?: obrasUncheckedCreateNestedManyWithoutClienteInput
  }

  export type clienteUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: obrasUpdateManyWithoutClienteNestedInput
  }

  export type clienteUncheckedUpdateInput = {
    idCli?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    obras?: obrasUncheckedUpdateManyWithoutClienteNestedInput
  }

  export type clienteCreateManyInput = {
    idCli?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    direccion?: string | null
    telefono?: string | null
    tipoDoc?: string | null
    cedula?: string | null
    fecha_nac?: string | null
    estado?: number | null
    constrasena?: string | null
    createdAt?: Date | string
  }

  export type clienteUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clienteUncheckedUpdateManyInput = {
    idCli?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comprasCreateInput = {
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    proveedor: proveedorCreateNestedOneWithoutComprasInput
    compras_detalle?: compras_detalleCreateNestedManyWithoutComprasInput
  }

  export type comprasUncheckedCreateInput = {
    idCom?: number
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    idProv: number
    compras_detalle?: compras_detalleUncheckedCreateNestedManyWithoutComprasInput
  }

  export type comprasUpdateInput = {
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: proveedorUpdateOneRequiredWithoutComprasNestedInput
    compras_detalle?: compras_detalleUpdateManyWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateInput = {
    idCom?: IntFieldUpdateOperationsInput | number
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    idProv?: IntFieldUpdateOperationsInput | number
    compras_detalle?: compras_detalleUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type comprasCreateManyInput = {
    idCom?: number
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    idProv: number
  }

  export type comprasUpdateManyMutationInput = {
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type comprasUncheckedUpdateManyInput = {
    idCom?: IntFieldUpdateOperationsInput | number
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    idProv?: IntFieldUpdateOperationsInput | number
  }

  export type compras_detalleCreateInput = {
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
    compras: comprasCreateNestedOneWithoutCompras_detalleInput
    materiales?: materialesCreateNestedOneWithoutCompras_detalleInput
  }

  export type compras_detalleUncheckedCreateInput = {
    id?: number
    idCompra: number
    idMat?: number | null
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type compras_detalleUpdateInput = {
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
    compras?: comprasUpdateOneRequiredWithoutCompras_detalleNestedInput
    materiales?: materialesUpdateOneWithoutCompras_detalleNestedInput
  }

  export type compras_detalleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCompra?: IntFieldUpdateOperationsInput | number
    idMat?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type compras_detalleCreateManyInput = {
    id?: number
    idCompra: number
    idMat?: number | null
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type compras_detalleUpdateManyMutationInput = {
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type compras_detalleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCompra?: IntFieldUpdateOperationsInput | number
    idMat?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleadoCreateInput = {
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadCreateNestedManyWithoutEmpleadoInput
    obras?: obrasCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadUncheckedCreateNestedManyWithoutEmpleadoInput
    obras?: obrasUncheckedCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUncheckedUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUncheckedUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoCreateManyInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
  }

  export type empleadoUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type empleadoUncheckedUpdateManyInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type empleado_especialidadCreateInput = {
    empleado: empleadoCreateNestedOneWithoutEmpleado_especialidadInput
    especialidad: especialidadCreateNestedOneWithoutEmpleado_especialidadInput
  }

  export type empleado_especialidadUncheckedCreateInput = {
    id?: number
    idEmp: number
    idEsp: number
  }

  export type empleado_especialidadUpdateInput = {
    empleado?: empleadoUpdateOneRequiredWithoutEmpleado_especialidadNestedInput
    especialidad?: especialidadUpdateOneRequiredWithoutEmpleado_especialidadNestedInput
  }

  export type empleado_especialidadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEmp?: IntFieldUpdateOperationsInput | number
    idEsp?: IntFieldUpdateOperationsInput | number
  }

  export type empleado_especialidadCreateManyInput = {
    id?: number
    idEmp: number
    idEsp: number
  }

  export type empleado_especialidadUpdateManyMutationInput = {

  }

  export type empleado_especialidadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEmp?: IntFieldUpdateOperationsInput | number
    idEsp?: IntFieldUpdateOperationsInput | number
  }

  export type especialidadCreateInput = {
    especialidad?: string | null
    estado?: number | null
    empleado_especialidad?: empleado_especialidadCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUncheckedCreateInput = {
    id?: number
    especialidad?: string | null
    estado?: number | null
    empleado_especialidad?: empleado_especialidadUncheckedCreateNestedManyWithoutEspecialidadInput
  }

  export type especialidadUpdateInput = {
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleado_especialidad?: empleado_especialidadUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    empleado_especialidad?: empleado_especialidadUncheckedUpdateManyWithoutEspecialidadNestedInput
  }

  export type especialidadCreateManyInput = {
    id?: number
    especialidad?: string | null
    estado?: number | null
  }

  export type especialidadUpdateManyMutationInput = {
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidadUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type materialesCreateInput = {
    nombre?: string | null
    estado?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutMaterialesInput
    compras_detalle?: compras_detalleCreateNestedManyWithoutMaterialesInput
    categoria?: categoriaCreateNestedOneWithoutMaterialesInput
  }

  export type materialesUncheckedCreateInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    idCategoria?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutMaterialesInput
    compras_detalle?: compras_detalleUncheckedCreateNestedManyWithoutMaterialesInput
  }

  export type materialesUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUpdateManyWithoutMaterialesNestedInput
    compras_detalle?: compras_detalleUpdateManyWithoutMaterialesNestedInput
    categoria?: categoriaUpdateOneWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    idCategoria?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutMaterialesNestedInput
    compras_detalle?: compras_detalleUncheckedUpdateManyWithoutMaterialesNestedInput
  }

  export type materialesCreateManyInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    idCategoria?: number | null
    cantidad: number
  }

  export type materialesUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type materialesUncheckedUpdateManyInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    idCategoria?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type obrasCreateInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraCreateNestedManyWithoutObrasInput
    empleado: empleadoCreateNestedOneWithoutObrasInput
    cliente?: clienteCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasUpdateInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUpdateManyWithoutObrasNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutObrasNestedInput
    cliente?: clienteUpdateOneWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type obrasCreateManyInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
  }

  export type obrasUpdateManyMutationInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type obrasUncheckedUpdateManyInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type permisoCreateInput = {
    permiso?: string | null
    estado?: number | null
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutPermisoInput
  }

  export type permisoUncheckedCreateInput = {
    idPer?: number
    permiso?: string | null
    estado?: number | null
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutPermisoInput
  }

  export type permisoUpdateInput = {
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutPermisoNestedInput
  }

  export type permisoUncheckedUpdateInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutPermisoNestedInput
  }

  export type permisoCreateManyInput = {
    idPer?: number
    permiso?: string | null
    estado?: number | null
  }

  export type permisoUpdateManyMutationInput = {
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type permisoUncheckedUpdateManyInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type proveedorCreateInput = {
    nombre?: string | null
    direccion?: string | null
    nit?: string | null
    tipo?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    nombreContacto?: string | null
    telefonoContacto?: string | null
    emailContacto?: string | null
    compras?: comprasCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUncheckedCreateInput = {
    idProv?: number
    nombre?: string | null
    direccion?: string | null
    nit?: string | null
    tipo?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    nombreContacto?: string | null
    telefonoContacto?: string | null
    emailContacto?: string | null
    compras?: comprasUncheckedCreateNestedManyWithoutProveedorInput
  }

  export type proveedorUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    compras?: comprasUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorUncheckedUpdateInput = {
    idProv?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
    compras?: comprasUncheckedUpdateManyWithoutProveedorNestedInput
  }

  export type proveedorCreateManyInput = {
    idProv?: number
    nombre?: string | null
    direccion?: string | null
    nit?: string | null
    tipo?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    nombreContacto?: string | null
    telefonoContacto?: string | null
    emailContacto?: string | null
  }

  export type proveedorUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedorUncheckedUpdateManyInput = {
    idProv?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolCreateInput = {
    nombre?: string | null
    estado?: number | null
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutRolInput
  }

  export type rolUncheckedCreateInput = {
    idRol?: number
    nombre?: string | null
    estado?: number | null
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutRolInput
  }

  export type rolUpdateInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutRolNestedInput
  }

  export type rolUncheckedUpdateInput = {
    idRol?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutRolNestedInput
  }

  export type rolCreateManyInput = {
    idRol?: number
    nombre?: string | null
    estado?: number | null
  }

  export type rolUpdateManyMutationInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolUncheckedUpdateManyInput = {
    idRol?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type detalle_obraCreateInput = {
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
    obras: obrasCreateNestedOneWithoutDetalle_obraInput
  }

  export type detalle_obraUncheckedCreateInput = {
    id?: number
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
    idObra: number
  }

  export type detalle_obraUpdateInput = {
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    obras?: obrasUpdateOneRequiredWithoutDetalle_obraNestedInput
  }

  export type detalle_obraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type detalle_obraCreateManyInput = {
    id?: number
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
    idObra: number
  }

  export type detalle_obraUpdateManyMutationInput = {
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detalle_obraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type rolpermisoempleadoCreateInput = {
    empleado?: empleadoCreateNestedOneWithoutRolpermisoempleadoInput
    permiso: permisoCreateNestedOneWithoutRolpermisoempleadoInput
    rol: rolCreateNestedOneWithoutRolpermisoempleadoInput
  }

  export type rolpermisoempleadoUncheckedCreateInput = {
    id?: number
    idRol: number
    idPer: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoUpdateInput = {
    empleado?: empleadoUpdateOneWithoutRolpermisoempleadoNestedInput
    permiso?: permisoUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
    rol?: rolUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
  }

  export type rolpermisoempleadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolpermisoempleadoCreateManyInput = {
    id?: number
    idRol: number
    idPer: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoUpdateManyMutationInput = {

  }

  export type rolpermisoempleadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type codigosCreateInput = {
    codigo?: string | null
    email?: string | null
    estado?: number | null
    fecha?: string | null
  }

  export type codigosUncheckedCreateInput = {
    Id?: number
    codigo?: string | null
    email?: string | null
    estado?: number | null
    fecha?: string | null
  }

  export type codigosUpdateInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type codigosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type codigosCreateManyInput = {
    Id?: number
    codigo?: string | null
    email?: string | null
    estado?: number | null
    fecha?: string | null
  }

  export type codigosUpdateManyMutationInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type codigosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type actividades_empleadosCreateInput = {
    actividad: string
    empleado: empleadoCreateNestedOneWithoutActividades_empleadosInput
    obras: obrasCreateNestedOneWithoutActividades_empleadosInput
  }

  export type actividades_empleadosUncheckedCreateInput = {
    id?: number
    actividad: string
    idEmp: number
    idObra: number
  }

  export type actividades_empleadosUpdateInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    empleado?: empleadoUpdateOneRequiredWithoutActividades_empleadosNestedInput
    obras?: obrasUpdateOneRequiredWithoutActividades_empleadosNestedInput
  }

  export type actividades_empleadosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idEmp?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_empleadosCreateManyInput = {
    id?: number
    actividad: string
    idEmp: number
    idObra: number
  }

  export type actividades_empleadosUpdateManyMutationInput = {
    actividad?: StringFieldUpdateOperationsInput | string
  }

  export type actividades_empleadosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idEmp?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesCreateInput = {
    actividad: string
    cantidad: number
    materiales: materialesCreateNestedOneWithoutActividades_materialesInput
    obras: obrasCreateNestedOneWithoutActividades_materialesInput
  }

  export type actividades_materialesUncheckedCreateInput = {
    id?: number
    actividad: string
    idMat: number
    cantidad: number
    idObra: number
  }

  export type actividades_materialesUpdateInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    materiales?: materialesUpdateOneRequiredWithoutActividades_materialesNestedInput
    obras?: obrasUpdateOneRequiredWithoutActividades_materialesNestedInput
  }

  export type actividades_materialesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idMat?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesCreateManyInput = {
    id?: number
    actividad: string
    idMat: number
    cantidad: number
    idObra: number
  }

  export type actividades_materialesUpdateManyMutationInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idMat?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type MaterialesListRelationFilter = {
    every?: materialesWhereInput
    some?: materialesWhereInput
    none?: materialesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type materialesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriaCountOrderByAggregateInput = {
    idcat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    medida?: SortOrder
  }

  export type categoriaAvgOrderByAggregateInput = {
    idcat?: SortOrder
    estado?: SortOrder
  }

  export type categoriaMaxOrderByAggregateInput = {
    idcat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    medida?: SortOrder
  }

  export type categoriaMinOrderByAggregateInput = {
    idcat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    medida?: SortOrder
  }

  export type categoriaSumOrderByAggregateInput = {
    idcat?: SortOrder
    estado?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ObrasListRelationFilter = {
    every?: obrasWhereInput
    some?: obrasWhereInput
    none?: obrasWhereInput
  }

  export type obrasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type clienteCountOrderByAggregateInput = {
    idCli?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    tipoDoc?: SortOrder
    cedula?: SortOrder
    fecha_nac?: SortOrder
    estado?: SortOrder
    constrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type clienteAvgOrderByAggregateInput = {
    idCli?: SortOrder
    estado?: SortOrder
  }

  export type clienteMaxOrderByAggregateInput = {
    idCli?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    tipoDoc?: SortOrder
    cedula?: SortOrder
    fecha_nac?: SortOrder
    estado?: SortOrder
    constrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type clienteMinOrderByAggregateInput = {
    idCli?: SortOrder
    nombre?: SortOrder
    apellidos?: SortOrder
    email?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    tipoDoc?: SortOrder
    cedula?: SortOrder
    fecha_nac?: SortOrder
    estado?: SortOrder
    constrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type clienteSumOrderByAggregateInput = {
    idCli?: SortOrder
    estado?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProveedorRelationFilter = {
    is?: proveedorWhereInput
    isNot?: proveedorWhereInput
  }

  export type Compras_detalleListRelationFilter = {
    every?: compras_detalleWhereInput
    some?: compras_detalleWhereInput
    none?: compras_detalleWhereInput
  }

  export type compras_detalleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comprasCountOrderByAggregateInput = {
    idCom?: SortOrder
    fecha?: SortOrder
    imagen?: SortOrder
    total_compra?: SortOrder
    codigoFactura?: SortOrder
    idProv?: SortOrder
  }

  export type comprasAvgOrderByAggregateInput = {
    idCom?: SortOrder
    total_compra?: SortOrder
    idProv?: SortOrder
  }

  export type comprasMaxOrderByAggregateInput = {
    idCom?: SortOrder
    fecha?: SortOrder
    imagen?: SortOrder
    total_compra?: SortOrder
    codigoFactura?: SortOrder
    idProv?: SortOrder
  }

  export type comprasMinOrderByAggregateInput = {
    idCom?: SortOrder
    fecha?: SortOrder
    imagen?: SortOrder
    total_compra?: SortOrder
    codigoFactura?: SortOrder
    idProv?: SortOrder
  }

  export type comprasSumOrderByAggregateInput = {
    idCom?: SortOrder
    total_compra?: SortOrder
    idProv?: SortOrder
  }

  export type ComprasRelationFilter = {
    is?: comprasWhereInput
    isNot?: comprasWhereInput
  }

  export type MaterialesNullableRelationFilter = {
    is?: materialesWhereInput | null
    isNot?: materialesWhereInput | null
  }

  export type compras_detalleCountOrderByAggregateInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    subtotal?: SortOrder
  }

  export type compras_detalleAvgOrderByAggregateInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    subtotal?: SortOrder
  }

  export type compras_detalleMaxOrderByAggregateInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    subtotal?: SortOrder
  }

  export type compras_detalleMinOrderByAggregateInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    subtotal?: SortOrder
  }

  export type compras_detalleSumOrderByAggregateInput = {
    id?: SortOrder
    idCompra?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    precio?: SortOrder
    subtotal?: SortOrder
  }

  export type Actividades_empleadosListRelationFilter = {
    every?: actividades_empleadosWhereInput
    some?: actividades_empleadosWhereInput
    none?: actividades_empleadosWhereInput
  }

  export type Empleado_especialidadListRelationFilter = {
    every?: empleado_especialidadWhereInput
    some?: empleado_especialidadWhereInput
    none?: empleado_especialidadWhereInput
  }

  export type RolpermisoempleadoListRelationFilter = {
    every?: rolpermisoempleadoWhereInput
    some?: rolpermisoempleadoWhereInput
    none?: rolpermisoempleadoWhereInput
  }

  export type actividades_empleadosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empleado_especialidadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolpermisoempleadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type empleadoCountOrderByAggregateInput = {
    idEmp?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cedula?: SortOrder
    tipoDoc?: SortOrder
    apellidos?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type empleadoAvgOrderByAggregateInput = {
    idEmp?: SortOrder
    estado?: SortOrder
  }

  export type empleadoMaxOrderByAggregateInput = {
    idEmp?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cedula?: SortOrder
    tipoDoc?: SortOrder
    apellidos?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type empleadoMinOrderByAggregateInput = {
    idEmp?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    cedula?: SortOrder
    tipoDoc?: SortOrder
    apellidos?: SortOrder
    contrasena?: SortOrder
    createdAt?: SortOrder
  }

  export type empleadoSumOrderByAggregateInput = {
    idEmp?: SortOrder
    estado?: SortOrder
  }

  export type EmpleadoRelationFilter = {
    is?: empleadoWhereInput
    isNot?: empleadoWhereInput
  }

  export type EspecialidadRelationFilter = {
    is?: especialidadWhereInput
    isNot?: especialidadWhereInput
  }

  export type empleado_especialidadCountOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
  }

  export type empleado_especialidadAvgOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
  }

  export type empleado_especialidadMaxOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
  }

  export type empleado_especialidadMinOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
  }

  export type empleado_especialidadSumOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idEsp?: SortOrder
  }

  export type especialidadCountOrderByAggregateInput = {
    id?: SortOrder
    especialidad?: SortOrder
    estado?: SortOrder
  }

  export type especialidadAvgOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type especialidadMaxOrderByAggregateInput = {
    id?: SortOrder
    especialidad?: SortOrder
    estado?: SortOrder
  }

  export type especialidadMinOrderByAggregateInput = {
    id?: SortOrder
    especialidad?: SortOrder
    estado?: SortOrder
  }

  export type especialidadSumOrderByAggregateInput = {
    id?: SortOrder
    estado?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type Actividades_materialesListRelationFilter = {
    every?: actividades_materialesWhereInput
    some?: actividades_materialesWhereInput
    none?: actividades_materialesWhereInput
  }

  export type CategoriaNullableRelationFilter = {
    is?: categoriaWhereInput | null
    isNot?: categoriaWhereInput | null
  }

  export type actividades_materialesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type materialesCountOrderByAggregateInput = {
    idMat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    cantidad?: SortOrder
  }

  export type materialesAvgOrderByAggregateInput = {
    idMat?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    cantidad?: SortOrder
  }

  export type materialesMaxOrderByAggregateInput = {
    idMat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    cantidad?: SortOrder
  }

  export type materialesMinOrderByAggregateInput = {
    idMat?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    cantidad?: SortOrder
  }

  export type materialesSumOrderByAggregateInput = {
    idMat?: SortOrder
    estado?: SortOrder
    idCategoria?: SortOrder
    cantidad?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type Detalle_obraListRelationFilter = {
    every?: detalle_obraWhereInput
    some?: detalle_obraWhereInput
    none?: detalle_obraWhereInput
  }

  export type ClienteNullableRelationFilter = {
    is?: clienteWhereInput | null
    isNot?: clienteWhereInput | null
  }

  export type detalle_obraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type obrasCountOrderByAggregateInput = {
    idObra?: SortOrder
    descripcion?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    area?: SortOrder
    idCliente?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createdAt?: SortOrder
    idEmp?: SortOrder
  }

  export type obrasAvgOrderByAggregateInput = {
    idObra?: SortOrder
    idCliente?: SortOrder
    precio?: SortOrder
    idEmp?: SortOrder
  }

  export type obrasMaxOrderByAggregateInput = {
    idObra?: SortOrder
    descripcion?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    area?: SortOrder
    idCliente?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createdAt?: SortOrder
    idEmp?: SortOrder
  }

  export type obrasMinOrderByAggregateInput = {
    idObra?: SortOrder
    descripcion?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    area?: SortOrder
    idCliente?: SortOrder
    estado?: SortOrder
    precio?: SortOrder
    createdAt?: SortOrder
    idEmp?: SortOrder
  }

  export type obrasSumOrderByAggregateInput = {
    idObra?: SortOrder
    idCliente?: SortOrder
    precio?: SortOrder
    idEmp?: SortOrder
  }

  export type permisoCountOrderByAggregateInput = {
    idPer?: SortOrder
    permiso?: SortOrder
    estado?: SortOrder
  }

  export type permisoAvgOrderByAggregateInput = {
    idPer?: SortOrder
    estado?: SortOrder
  }

  export type permisoMaxOrderByAggregateInput = {
    idPer?: SortOrder
    permiso?: SortOrder
    estado?: SortOrder
  }

  export type permisoMinOrderByAggregateInput = {
    idPer?: SortOrder
    permiso?: SortOrder
    estado?: SortOrder
  }

  export type permisoSumOrderByAggregateInput = {
    idPer?: SortOrder
    estado?: SortOrder
  }

  export type ComprasListRelationFilter = {
    every?: comprasWhereInput
    some?: comprasWhereInput
    none?: comprasWhereInput
  }

  export type comprasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type proveedorCountOrderByAggregateInput = {
    idProv?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    nit?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    nombreContacto?: SortOrder
    telefonoContacto?: SortOrder
    emailContacto?: SortOrder
  }

  export type proveedorAvgOrderByAggregateInput = {
    idProv?: SortOrder
    estado?: SortOrder
  }

  export type proveedorMaxOrderByAggregateInput = {
    idProv?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    nit?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    nombreContacto?: SortOrder
    telefonoContacto?: SortOrder
    emailContacto?: SortOrder
  }

  export type proveedorMinOrderByAggregateInput = {
    idProv?: SortOrder
    nombre?: SortOrder
    direccion?: SortOrder
    nit?: SortOrder
    tipo?: SortOrder
    estado?: SortOrder
    email?: SortOrder
    telefono?: SortOrder
    nombreContacto?: SortOrder
    telefonoContacto?: SortOrder
    emailContacto?: SortOrder
  }

  export type proveedorSumOrderByAggregateInput = {
    idProv?: SortOrder
    estado?: SortOrder
  }

  export type rolCountOrderByAggregateInput = {
    idRol?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type rolAvgOrderByAggregateInput = {
    idRol?: SortOrder
    estado?: SortOrder
  }

  export type rolMaxOrderByAggregateInput = {
    idRol?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type rolMinOrderByAggregateInput = {
    idRol?: SortOrder
    nombre?: SortOrder
    estado?: SortOrder
  }

  export type rolSumOrderByAggregateInput = {
    idRol?: SortOrder
    estado?: SortOrder
  }

  export type ObrasRelationFilter = {
    is?: obrasWhereInput
    isNot?: obrasWhereInput
  }

  export type detalle_obraCountOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    estado?: SortOrder
    idObra?: SortOrder
  }

  export type detalle_obraAvgOrderByAggregateInput = {
    id?: SortOrder
    fechafin?: SortOrder
    idObra?: SortOrder
  }

  export type detalle_obraMaxOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    estado?: SortOrder
    idObra?: SortOrder
  }

  export type detalle_obraMinOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    fechaini?: SortOrder
    fechafin?: SortOrder
    estado?: SortOrder
    idObra?: SortOrder
  }

  export type detalle_obraSumOrderByAggregateInput = {
    id?: SortOrder
    fechafin?: SortOrder
    idObra?: SortOrder
  }

  export type EmpleadoNullableRelationFilter = {
    is?: empleadoWhereInput | null
    isNot?: empleadoWhereInput | null
  }

  export type PermisoRelationFilter = {
    is?: permisoWhereInput
    isNot?: permisoWhereInput
  }

  export type RolRelationFilter = {
    is?: rolWhereInput
    isNot?: rolWhereInput
  }

  export type rolpermisoempleadoCountOrderByAggregateInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrder
  }

  export type rolpermisoempleadoAvgOrderByAggregateInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrder
  }

  export type rolpermisoempleadoMaxOrderByAggregateInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrder
  }

  export type rolpermisoempleadoMinOrderByAggregateInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrder
  }

  export type rolpermisoempleadoSumOrderByAggregateInput = {
    id?: SortOrder
    idRol?: SortOrder
    idPer?: SortOrder
    idEmp?: SortOrder
  }

  export type codigosCountOrderByAggregateInput = {
    Id?: SortOrder
    codigo?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
  }

  export type codigosAvgOrderByAggregateInput = {
    Id?: SortOrder
    estado?: SortOrder
  }

  export type codigosMaxOrderByAggregateInput = {
    Id?: SortOrder
    codigo?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
  }

  export type codigosMinOrderByAggregateInput = {
    Id?: SortOrder
    codigo?: SortOrder
    email?: SortOrder
    estado?: SortOrder
    fecha?: SortOrder
  }

  export type codigosSumOrderByAggregateInput = {
    Id?: SortOrder
    estado?: SortOrder
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type actividades_empleadosCountOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_empleadosAvgOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_empleadosMaxOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_empleadosMinOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_empleadosSumOrderByAggregateInput = {
    id?: SortOrder
    idEmp?: SortOrder
    idObra?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type MaterialesRelationFilter = {
    is?: materialesWhereInput
    isNot?: materialesWhereInput
  }

  export type actividades_materialesCountOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_materialesAvgOrderByAggregateInput = {
    id?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_materialesMaxOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_materialesMinOrderByAggregateInput = {
    id?: SortOrder
    actividad?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
  }

  export type actividades_materialesSumOrderByAggregateInput = {
    id?: SortOrder
    idMat?: SortOrder
    cantidad?: SortOrder
    idObra?: SortOrder
  }

  export type materialesCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput> | materialesCreateWithoutCategoriaInput[] | materialesUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutCategoriaInput | materialesCreateOrConnectWithoutCategoriaInput[]
    createMany?: materialesCreateManyCategoriaInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type materialesUncheckedCreateNestedManyWithoutCategoriaInput = {
    create?: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput> | materialesCreateWithoutCategoriaInput[] | materialesUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutCategoriaInput | materialesCreateOrConnectWithoutCategoriaInput[]
    createMany?: materialesCreateManyCategoriaInputEnvelope
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type materialesUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput> | materialesCreateWithoutCategoriaInput[] | materialesUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutCategoriaInput | materialesCreateOrConnectWithoutCategoriaInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutCategoriaInput | materialesUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: materialesCreateManyCategoriaInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutCategoriaInput | materialesUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutCategoriaInput | materialesUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type materialesUncheckedUpdateManyWithoutCategoriaNestedInput = {
    create?: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput> | materialesCreateWithoutCategoriaInput[] | materialesUncheckedCreateWithoutCategoriaInput[]
    connectOrCreate?: materialesCreateOrConnectWithoutCategoriaInput | materialesCreateOrConnectWithoutCategoriaInput[]
    upsert?: materialesUpsertWithWhereUniqueWithoutCategoriaInput | materialesUpsertWithWhereUniqueWithoutCategoriaInput[]
    createMany?: materialesCreateManyCategoriaInputEnvelope
    set?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    disconnect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    delete?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    connect?: materialesWhereUniqueInput | materialesWhereUniqueInput[]
    update?: materialesUpdateWithWhereUniqueWithoutCategoriaInput | materialesUpdateWithWhereUniqueWithoutCategoriaInput[]
    updateMany?: materialesUpdateManyWithWhereWithoutCategoriaInput | materialesUpdateManyWithWhereWithoutCategoriaInput[]
    deleteMany?: materialesScalarWhereInput | materialesScalarWhereInput[]
  }

  export type obrasCreateNestedManyWithoutClienteInput = {
    create?: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput> | obrasCreateWithoutClienteInput[] | obrasUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutClienteInput | obrasCreateOrConnectWithoutClienteInput[]
    createMany?: obrasCreateManyClienteInputEnvelope
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
  }

  export type obrasUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput> | obrasCreateWithoutClienteInput[] | obrasUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutClienteInput | obrasCreateOrConnectWithoutClienteInput[]
    createMany?: obrasCreateManyClienteInputEnvelope
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type obrasUpdateManyWithoutClienteNestedInput = {
    create?: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput> | obrasCreateWithoutClienteInput[] | obrasUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutClienteInput | obrasCreateOrConnectWithoutClienteInput[]
    upsert?: obrasUpsertWithWhereUniqueWithoutClienteInput | obrasUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: obrasCreateManyClienteInputEnvelope
    set?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    disconnect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    delete?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    update?: obrasUpdateWithWhereUniqueWithoutClienteInput | obrasUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: obrasUpdateManyWithWhereWithoutClienteInput | obrasUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: obrasScalarWhereInput | obrasScalarWhereInput[]
  }

  export type obrasUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput> | obrasCreateWithoutClienteInput[] | obrasUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutClienteInput | obrasCreateOrConnectWithoutClienteInput[]
    upsert?: obrasUpsertWithWhereUniqueWithoutClienteInput | obrasUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: obrasCreateManyClienteInputEnvelope
    set?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    disconnect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    delete?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    update?: obrasUpdateWithWhereUniqueWithoutClienteInput | obrasUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: obrasUpdateManyWithWhereWithoutClienteInput | obrasUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: obrasScalarWhereInput | obrasScalarWhereInput[]
  }

  export type proveedorCreateNestedOneWithoutComprasInput = {
    create?: XOR<proveedorCreateWithoutComprasInput, proveedorUncheckedCreateWithoutComprasInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutComprasInput
    connect?: proveedorWhereUniqueInput
  }

  export type compras_detalleCreateNestedManyWithoutComprasInput = {
    create?: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput> | compras_detalleCreateWithoutComprasInput[] | compras_detalleUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutComprasInput | compras_detalleCreateOrConnectWithoutComprasInput[]
    createMany?: compras_detalleCreateManyComprasInputEnvelope
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
  }

  export type compras_detalleUncheckedCreateNestedManyWithoutComprasInput = {
    create?: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput> | compras_detalleCreateWithoutComprasInput[] | compras_detalleUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutComprasInput | compras_detalleCreateOrConnectWithoutComprasInput[]
    createMany?: compras_detalleCreateManyComprasInputEnvelope
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
  }

  export type proveedorUpdateOneRequiredWithoutComprasNestedInput = {
    create?: XOR<proveedorCreateWithoutComprasInput, proveedorUncheckedCreateWithoutComprasInput>
    connectOrCreate?: proveedorCreateOrConnectWithoutComprasInput
    upsert?: proveedorUpsertWithoutComprasInput
    connect?: proveedorWhereUniqueInput
    update?: XOR<XOR<proveedorUpdateToOneWithWhereWithoutComprasInput, proveedorUpdateWithoutComprasInput>, proveedorUncheckedUpdateWithoutComprasInput>
  }

  export type compras_detalleUpdateManyWithoutComprasNestedInput = {
    create?: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput> | compras_detalleCreateWithoutComprasInput[] | compras_detalleUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutComprasInput | compras_detalleCreateOrConnectWithoutComprasInput[]
    upsert?: compras_detalleUpsertWithWhereUniqueWithoutComprasInput | compras_detalleUpsertWithWhereUniqueWithoutComprasInput[]
    createMany?: compras_detalleCreateManyComprasInputEnvelope
    set?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    disconnect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    delete?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    update?: compras_detalleUpdateWithWhereUniqueWithoutComprasInput | compras_detalleUpdateWithWhereUniqueWithoutComprasInput[]
    updateMany?: compras_detalleUpdateManyWithWhereWithoutComprasInput | compras_detalleUpdateManyWithWhereWithoutComprasInput[]
    deleteMany?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
  }

  export type compras_detalleUncheckedUpdateManyWithoutComprasNestedInput = {
    create?: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput> | compras_detalleCreateWithoutComprasInput[] | compras_detalleUncheckedCreateWithoutComprasInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutComprasInput | compras_detalleCreateOrConnectWithoutComprasInput[]
    upsert?: compras_detalleUpsertWithWhereUniqueWithoutComprasInput | compras_detalleUpsertWithWhereUniqueWithoutComprasInput[]
    createMany?: compras_detalleCreateManyComprasInputEnvelope
    set?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    disconnect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    delete?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    update?: compras_detalleUpdateWithWhereUniqueWithoutComprasInput | compras_detalleUpdateWithWhereUniqueWithoutComprasInput[]
    updateMany?: compras_detalleUpdateManyWithWhereWithoutComprasInput | compras_detalleUpdateManyWithWhereWithoutComprasInput[]
    deleteMany?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
  }

  export type comprasCreateNestedOneWithoutCompras_detalleInput = {
    create?: XOR<comprasCreateWithoutCompras_detalleInput, comprasUncheckedCreateWithoutCompras_detalleInput>
    connectOrCreate?: comprasCreateOrConnectWithoutCompras_detalleInput
    connect?: comprasWhereUniqueInput
  }

  export type materialesCreateNestedOneWithoutCompras_detalleInput = {
    create?: XOR<materialesCreateWithoutCompras_detalleInput, materialesUncheckedCreateWithoutCompras_detalleInput>
    connectOrCreate?: materialesCreateOrConnectWithoutCompras_detalleInput
    connect?: materialesWhereUniqueInput
  }

  export type comprasUpdateOneRequiredWithoutCompras_detalleNestedInput = {
    create?: XOR<comprasCreateWithoutCompras_detalleInput, comprasUncheckedCreateWithoutCompras_detalleInput>
    connectOrCreate?: comprasCreateOrConnectWithoutCompras_detalleInput
    upsert?: comprasUpsertWithoutCompras_detalleInput
    connect?: comprasWhereUniqueInput
    update?: XOR<XOR<comprasUpdateToOneWithWhereWithoutCompras_detalleInput, comprasUpdateWithoutCompras_detalleInput>, comprasUncheckedUpdateWithoutCompras_detalleInput>
  }

  export type materialesUpdateOneWithoutCompras_detalleNestedInput = {
    create?: XOR<materialesCreateWithoutCompras_detalleInput, materialesUncheckedCreateWithoutCompras_detalleInput>
    connectOrCreate?: materialesCreateOrConnectWithoutCompras_detalleInput
    upsert?: materialesUpsertWithoutCompras_detalleInput
    disconnect?: materialesWhereInput | boolean
    delete?: materialesWhereInput | boolean
    connect?: materialesWhereUniqueInput
    update?: XOR<XOR<materialesUpdateToOneWithWhereWithoutCompras_detalleInput, materialesUpdateWithoutCompras_detalleInput>, materialesUncheckedUpdateWithoutCompras_detalleInput>
  }

  export type actividades_empleadosCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput> | actividades_empleadosCreateWithoutEmpleadoInput[] | actividades_empleadosUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutEmpleadoInput | actividades_empleadosCreateOrConnectWithoutEmpleadoInput[]
    createMany?: actividades_empleadosCreateManyEmpleadoInputEnvelope
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
  }

  export type empleado_especialidadCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput> | empleado_especialidadCreateWithoutEmpleadoInput[] | empleado_especialidadUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEmpleadoInput | empleado_especialidadCreateOrConnectWithoutEmpleadoInput[]
    createMany?: empleado_especialidadCreateManyEmpleadoInputEnvelope
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
  }

  export type obrasCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput> | obrasCreateWithoutEmpleadoInput[] | obrasUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutEmpleadoInput | obrasCreateOrConnectWithoutEmpleadoInput[]
    createMany?: obrasCreateManyEmpleadoInputEnvelope
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
  }

  export type rolpermisoempleadoCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput> | rolpermisoempleadoCreateWithoutEmpleadoInput[] | rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput | rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: rolpermisoempleadoCreateManyEmpleadoInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type actividades_empleadosUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput> | actividades_empleadosCreateWithoutEmpleadoInput[] | actividades_empleadosUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutEmpleadoInput | actividades_empleadosCreateOrConnectWithoutEmpleadoInput[]
    createMany?: actividades_empleadosCreateManyEmpleadoInputEnvelope
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
  }

  export type empleado_especialidadUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput> | empleado_especialidadCreateWithoutEmpleadoInput[] | empleado_especialidadUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEmpleadoInput | empleado_especialidadCreateOrConnectWithoutEmpleadoInput[]
    createMany?: empleado_especialidadCreateManyEmpleadoInputEnvelope
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
  }

  export type obrasUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput> | obrasCreateWithoutEmpleadoInput[] | obrasUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutEmpleadoInput | obrasCreateOrConnectWithoutEmpleadoInput[]
    createMany?: obrasCreateManyEmpleadoInputEnvelope
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
  }

  export type rolpermisoempleadoUncheckedCreateNestedManyWithoutEmpleadoInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput> | rolpermisoempleadoCreateWithoutEmpleadoInput[] | rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput | rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput[]
    createMany?: rolpermisoempleadoCreateManyEmpleadoInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type actividades_empleadosUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput> | actividades_empleadosCreateWithoutEmpleadoInput[] | actividades_empleadosUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutEmpleadoInput | actividades_empleadosCreateOrConnectWithoutEmpleadoInput[]
    upsert?: actividades_empleadosUpsertWithWhereUniqueWithoutEmpleadoInput | actividades_empleadosUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: actividades_empleadosCreateManyEmpleadoInputEnvelope
    set?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    disconnect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    delete?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    update?: actividades_empleadosUpdateWithWhereUniqueWithoutEmpleadoInput | actividades_empleadosUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: actividades_empleadosUpdateManyWithWhereWithoutEmpleadoInput | actividades_empleadosUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
  }

  export type empleado_especialidadUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput> | empleado_especialidadCreateWithoutEmpleadoInput[] | empleado_especialidadUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEmpleadoInput | empleado_especialidadCreateOrConnectWithoutEmpleadoInput[]
    upsert?: empleado_especialidadUpsertWithWhereUniqueWithoutEmpleadoInput | empleado_especialidadUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: empleado_especialidadCreateManyEmpleadoInputEnvelope
    set?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    disconnect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    delete?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    update?: empleado_especialidadUpdateWithWhereUniqueWithoutEmpleadoInput | empleado_especialidadUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: empleado_especialidadUpdateManyWithWhereWithoutEmpleadoInput | empleado_especialidadUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
  }

  export type obrasUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput> | obrasCreateWithoutEmpleadoInput[] | obrasUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutEmpleadoInput | obrasCreateOrConnectWithoutEmpleadoInput[]
    upsert?: obrasUpsertWithWhereUniqueWithoutEmpleadoInput | obrasUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: obrasCreateManyEmpleadoInputEnvelope
    set?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    disconnect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    delete?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    update?: obrasUpdateWithWhereUniqueWithoutEmpleadoInput | obrasUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: obrasUpdateManyWithWhereWithoutEmpleadoInput | obrasUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: obrasScalarWhereInput | obrasScalarWhereInput[]
  }

  export type rolpermisoempleadoUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput> | rolpermisoempleadoCreateWithoutEmpleadoInput[] | rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput | rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutEmpleadoInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: rolpermisoempleadoCreateManyEmpleadoInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutEmpleadoInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutEmpleadoInput | rolpermisoempleadoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type actividades_empleadosUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput> | actividades_empleadosCreateWithoutEmpleadoInput[] | actividades_empleadosUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutEmpleadoInput | actividades_empleadosCreateOrConnectWithoutEmpleadoInput[]
    upsert?: actividades_empleadosUpsertWithWhereUniqueWithoutEmpleadoInput | actividades_empleadosUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: actividades_empleadosCreateManyEmpleadoInputEnvelope
    set?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    disconnect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    delete?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    update?: actividades_empleadosUpdateWithWhereUniqueWithoutEmpleadoInput | actividades_empleadosUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: actividades_empleadosUpdateManyWithWhereWithoutEmpleadoInput | actividades_empleadosUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
  }

  export type empleado_especialidadUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput> | empleado_especialidadCreateWithoutEmpleadoInput[] | empleado_especialidadUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEmpleadoInput | empleado_especialidadCreateOrConnectWithoutEmpleadoInput[]
    upsert?: empleado_especialidadUpsertWithWhereUniqueWithoutEmpleadoInput | empleado_especialidadUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: empleado_especialidadCreateManyEmpleadoInputEnvelope
    set?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    disconnect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    delete?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    update?: empleado_especialidadUpdateWithWhereUniqueWithoutEmpleadoInput | empleado_especialidadUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: empleado_especialidadUpdateManyWithWhereWithoutEmpleadoInput | empleado_especialidadUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
  }

  export type obrasUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput> | obrasCreateWithoutEmpleadoInput[] | obrasUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: obrasCreateOrConnectWithoutEmpleadoInput | obrasCreateOrConnectWithoutEmpleadoInput[]
    upsert?: obrasUpsertWithWhereUniqueWithoutEmpleadoInput | obrasUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: obrasCreateManyEmpleadoInputEnvelope
    set?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    disconnect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    delete?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    connect?: obrasWhereUniqueInput | obrasWhereUniqueInput[]
    update?: obrasUpdateWithWhereUniqueWithoutEmpleadoInput | obrasUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: obrasUpdateManyWithWhereWithoutEmpleadoInput | obrasUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: obrasScalarWhereInput | obrasScalarWhereInput[]
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput> | rolpermisoempleadoCreateWithoutEmpleadoInput[] | rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput | rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutEmpleadoInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutEmpleadoInput[]
    createMany?: rolpermisoempleadoCreateManyEmpleadoInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutEmpleadoInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutEmpleadoInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutEmpleadoInput | rolpermisoempleadoUpdateManyWithWhereWithoutEmpleadoInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type empleadoCreateNestedOneWithoutEmpleado_especialidadInput = {
    create?: XOR<empleadoCreateWithoutEmpleado_especialidadInput, empleadoUncheckedCreateWithoutEmpleado_especialidadInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEmpleado_especialidadInput
    connect?: empleadoWhereUniqueInput
  }

  export type especialidadCreateNestedOneWithoutEmpleado_especialidadInput = {
    create?: XOR<especialidadCreateWithoutEmpleado_especialidadInput, especialidadUncheckedCreateWithoutEmpleado_especialidadInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutEmpleado_especialidadInput
    connect?: especialidadWhereUniqueInput
  }

  export type empleadoUpdateOneRequiredWithoutEmpleado_especialidadNestedInput = {
    create?: XOR<empleadoCreateWithoutEmpleado_especialidadInput, empleadoUncheckedCreateWithoutEmpleado_especialidadInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutEmpleado_especialidadInput
    upsert?: empleadoUpsertWithoutEmpleado_especialidadInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutEmpleado_especialidadInput, empleadoUpdateWithoutEmpleado_especialidadInput>, empleadoUncheckedUpdateWithoutEmpleado_especialidadInput>
  }

  export type especialidadUpdateOneRequiredWithoutEmpleado_especialidadNestedInput = {
    create?: XOR<especialidadCreateWithoutEmpleado_especialidadInput, especialidadUncheckedCreateWithoutEmpleado_especialidadInput>
    connectOrCreate?: especialidadCreateOrConnectWithoutEmpleado_especialidadInput
    upsert?: especialidadUpsertWithoutEmpleado_especialidadInput
    connect?: especialidadWhereUniqueInput
    update?: XOR<XOR<especialidadUpdateToOneWithWhereWithoutEmpleado_especialidadInput, especialidadUpdateWithoutEmpleado_especialidadInput>, especialidadUncheckedUpdateWithoutEmpleado_especialidadInput>
  }

  export type empleado_especialidadCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput> | empleado_especialidadCreateWithoutEspecialidadInput[] | empleado_especialidadUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEspecialidadInput | empleado_especialidadCreateOrConnectWithoutEspecialidadInput[]
    createMany?: empleado_especialidadCreateManyEspecialidadInputEnvelope
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
  }

  export type empleado_especialidadUncheckedCreateNestedManyWithoutEspecialidadInput = {
    create?: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput> | empleado_especialidadCreateWithoutEspecialidadInput[] | empleado_especialidadUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEspecialidadInput | empleado_especialidadCreateOrConnectWithoutEspecialidadInput[]
    createMany?: empleado_especialidadCreateManyEspecialidadInputEnvelope
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
  }

  export type empleado_especialidadUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput> | empleado_especialidadCreateWithoutEspecialidadInput[] | empleado_especialidadUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEspecialidadInput | empleado_especialidadCreateOrConnectWithoutEspecialidadInput[]
    upsert?: empleado_especialidadUpsertWithWhereUniqueWithoutEspecialidadInput | empleado_especialidadUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: empleado_especialidadCreateManyEspecialidadInputEnvelope
    set?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    disconnect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    delete?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    update?: empleado_especialidadUpdateWithWhereUniqueWithoutEspecialidadInput | empleado_especialidadUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: empleado_especialidadUpdateManyWithWhereWithoutEspecialidadInput | empleado_especialidadUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
  }

  export type empleado_especialidadUncheckedUpdateManyWithoutEspecialidadNestedInput = {
    create?: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput> | empleado_especialidadCreateWithoutEspecialidadInput[] | empleado_especialidadUncheckedCreateWithoutEspecialidadInput[]
    connectOrCreate?: empleado_especialidadCreateOrConnectWithoutEspecialidadInput | empleado_especialidadCreateOrConnectWithoutEspecialidadInput[]
    upsert?: empleado_especialidadUpsertWithWhereUniqueWithoutEspecialidadInput | empleado_especialidadUpsertWithWhereUniqueWithoutEspecialidadInput[]
    createMany?: empleado_especialidadCreateManyEspecialidadInputEnvelope
    set?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    disconnect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    delete?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    connect?: empleado_especialidadWhereUniqueInput | empleado_especialidadWhereUniqueInput[]
    update?: empleado_especialidadUpdateWithWhereUniqueWithoutEspecialidadInput | empleado_especialidadUpdateWithWhereUniqueWithoutEspecialidadInput[]
    updateMany?: empleado_especialidadUpdateManyWithWhereWithoutEspecialidadInput | empleado_especialidadUpdateManyWithWhereWithoutEspecialidadInput[]
    deleteMany?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
  }

  export type actividades_materialesCreateNestedManyWithoutMaterialesInput = {
    create?: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput> | actividades_materialesCreateWithoutMaterialesInput[] | actividades_materialesUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutMaterialesInput | actividades_materialesCreateOrConnectWithoutMaterialesInput[]
    createMany?: actividades_materialesCreateManyMaterialesInputEnvelope
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
  }

  export type compras_detalleCreateNestedManyWithoutMaterialesInput = {
    create?: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput> | compras_detalleCreateWithoutMaterialesInput[] | compras_detalleUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutMaterialesInput | compras_detalleCreateOrConnectWithoutMaterialesInput[]
    createMany?: compras_detalleCreateManyMaterialesInputEnvelope
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
  }

  export type categoriaCreateNestedOneWithoutMaterialesInput = {
    create?: XOR<categoriaCreateWithoutMaterialesInput, categoriaUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutMaterialesInput
    connect?: categoriaWhereUniqueInput
  }

  export type actividades_materialesUncheckedCreateNestedManyWithoutMaterialesInput = {
    create?: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput> | actividades_materialesCreateWithoutMaterialesInput[] | actividades_materialesUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutMaterialesInput | actividades_materialesCreateOrConnectWithoutMaterialesInput[]
    createMany?: actividades_materialesCreateManyMaterialesInputEnvelope
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
  }

  export type compras_detalleUncheckedCreateNestedManyWithoutMaterialesInput = {
    create?: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput> | compras_detalleCreateWithoutMaterialesInput[] | compras_detalleUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutMaterialesInput | compras_detalleCreateOrConnectWithoutMaterialesInput[]
    createMany?: compras_detalleCreateManyMaterialesInputEnvelope
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type actividades_materialesUpdateManyWithoutMaterialesNestedInput = {
    create?: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput> | actividades_materialesCreateWithoutMaterialesInput[] | actividades_materialesUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutMaterialesInput | actividades_materialesCreateOrConnectWithoutMaterialesInput[]
    upsert?: actividades_materialesUpsertWithWhereUniqueWithoutMaterialesInput | actividades_materialesUpsertWithWhereUniqueWithoutMaterialesInput[]
    createMany?: actividades_materialesCreateManyMaterialesInputEnvelope
    set?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    disconnect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    delete?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    update?: actividades_materialesUpdateWithWhereUniqueWithoutMaterialesInput | actividades_materialesUpdateWithWhereUniqueWithoutMaterialesInput[]
    updateMany?: actividades_materialesUpdateManyWithWhereWithoutMaterialesInput | actividades_materialesUpdateManyWithWhereWithoutMaterialesInput[]
    deleteMany?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
  }

  export type compras_detalleUpdateManyWithoutMaterialesNestedInput = {
    create?: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput> | compras_detalleCreateWithoutMaterialesInput[] | compras_detalleUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutMaterialesInput | compras_detalleCreateOrConnectWithoutMaterialesInput[]
    upsert?: compras_detalleUpsertWithWhereUniqueWithoutMaterialesInput | compras_detalleUpsertWithWhereUniqueWithoutMaterialesInput[]
    createMany?: compras_detalleCreateManyMaterialesInputEnvelope
    set?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    disconnect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    delete?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    update?: compras_detalleUpdateWithWhereUniqueWithoutMaterialesInput | compras_detalleUpdateWithWhereUniqueWithoutMaterialesInput[]
    updateMany?: compras_detalleUpdateManyWithWhereWithoutMaterialesInput | compras_detalleUpdateManyWithWhereWithoutMaterialesInput[]
    deleteMany?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
  }

  export type categoriaUpdateOneWithoutMaterialesNestedInput = {
    create?: XOR<categoriaCreateWithoutMaterialesInput, categoriaUncheckedCreateWithoutMaterialesInput>
    connectOrCreate?: categoriaCreateOrConnectWithoutMaterialesInput
    upsert?: categoriaUpsertWithoutMaterialesInput
    disconnect?: categoriaWhereInput | boolean
    delete?: categoriaWhereInput | boolean
    connect?: categoriaWhereUniqueInput
    update?: XOR<XOR<categoriaUpdateToOneWithWhereWithoutMaterialesInput, categoriaUpdateWithoutMaterialesInput>, categoriaUncheckedUpdateWithoutMaterialesInput>
  }

  export type actividades_materialesUncheckedUpdateManyWithoutMaterialesNestedInput = {
    create?: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput> | actividades_materialesCreateWithoutMaterialesInput[] | actividades_materialesUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutMaterialesInput | actividades_materialesCreateOrConnectWithoutMaterialesInput[]
    upsert?: actividades_materialesUpsertWithWhereUniqueWithoutMaterialesInput | actividades_materialesUpsertWithWhereUniqueWithoutMaterialesInput[]
    createMany?: actividades_materialesCreateManyMaterialesInputEnvelope
    set?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    disconnect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    delete?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    update?: actividades_materialesUpdateWithWhereUniqueWithoutMaterialesInput | actividades_materialesUpdateWithWhereUniqueWithoutMaterialesInput[]
    updateMany?: actividades_materialesUpdateManyWithWhereWithoutMaterialesInput | actividades_materialesUpdateManyWithWhereWithoutMaterialesInput[]
    deleteMany?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
  }

  export type compras_detalleUncheckedUpdateManyWithoutMaterialesNestedInput = {
    create?: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput> | compras_detalleCreateWithoutMaterialesInput[] | compras_detalleUncheckedCreateWithoutMaterialesInput[]
    connectOrCreate?: compras_detalleCreateOrConnectWithoutMaterialesInput | compras_detalleCreateOrConnectWithoutMaterialesInput[]
    upsert?: compras_detalleUpsertWithWhereUniqueWithoutMaterialesInput | compras_detalleUpsertWithWhereUniqueWithoutMaterialesInput[]
    createMany?: compras_detalleCreateManyMaterialesInputEnvelope
    set?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    disconnect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    delete?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    connect?: compras_detalleWhereUniqueInput | compras_detalleWhereUniqueInput[]
    update?: compras_detalleUpdateWithWhereUniqueWithoutMaterialesInput | compras_detalleUpdateWithWhereUniqueWithoutMaterialesInput[]
    updateMany?: compras_detalleUpdateManyWithWhereWithoutMaterialesInput | compras_detalleUpdateManyWithWhereWithoutMaterialesInput[]
    deleteMany?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
  }

  export type actividades_empleadosCreateNestedManyWithoutObrasInput = {
    create?: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput> | actividades_empleadosCreateWithoutObrasInput[] | actividades_empleadosUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutObrasInput | actividades_empleadosCreateOrConnectWithoutObrasInput[]
    createMany?: actividades_empleadosCreateManyObrasInputEnvelope
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
  }

  export type actividades_materialesCreateNestedManyWithoutObrasInput = {
    create?: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput> | actividades_materialesCreateWithoutObrasInput[] | actividades_materialesUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutObrasInput | actividades_materialesCreateOrConnectWithoutObrasInput[]
    createMany?: actividades_materialesCreateManyObrasInputEnvelope
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
  }

  export type detalle_obraCreateNestedManyWithoutObrasInput = {
    create?: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput> | detalle_obraCreateWithoutObrasInput[] | detalle_obraUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: detalle_obraCreateOrConnectWithoutObrasInput | detalle_obraCreateOrConnectWithoutObrasInput[]
    createMany?: detalle_obraCreateManyObrasInputEnvelope
    connect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
  }

  export type empleadoCreateNestedOneWithoutObrasInput = {
    create?: XOR<empleadoCreateWithoutObrasInput, empleadoUncheckedCreateWithoutObrasInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutObrasInput
    connect?: empleadoWhereUniqueInput
  }

  export type clienteCreateNestedOneWithoutObrasInput = {
    create?: XOR<clienteCreateWithoutObrasInput, clienteUncheckedCreateWithoutObrasInput>
    connectOrCreate?: clienteCreateOrConnectWithoutObrasInput
    connect?: clienteWhereUniqueInput
  }

  export type actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput = {
    create?: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput> | actividades_empleadosCreateWithoutObrasInput[] | actividades_empleadosUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutObrasInput | actividades_empleadosCreateOrConnectWithoutObrasInput[]
    createMany?: actividades_empleadosCreateManyObrasInputEnvelope
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
  }

  export type actividades_materialesUncheckedCreateNestedManyWithoutObrasInput = {
    create?: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput> | actividades_materialesCreateWithoutObrasInput[] | actividades_materialesUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutObrasInput | actividades_materialesCreateOrConnectWithoutObrasInput[]
    createMany?: actividades_materialesCreateManyObrasInputEnvelope
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
  }

  export type detalle_obraUncheckedCreateNestedManyWithoutObrasInput = {
    create?: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput> | detalle_obraCreateWithoutObrasInput[] | detalle_obraUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: detalle_obraCreateOrConnectWithoutObrasInput | detalle_obraCreateOrConnectWithoutObrasInput[]
    createMany?: detalle_obraCreateManyObrasInputEnvelope
    connect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
  }

  export type actividades_empleadosUpdateManyWithoutObrasNestedInput = {
    create?: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput> | actividades_empleadosCreateWithoutObrasInput[] | actividades_empleadosUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutObrasInput | actividades_empleadosCreateOrConnectWithoutObrasInput[]
    upsert?: actividades_empleadosUpsertWithWhereUniqueWithoutObrasInput | actividades_empleadosUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: actividades_empleadosCreateManyObrasInputEnvelope
    set?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    disconnect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    delete?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    update?: actividades_empleadosUpdateWithWhereUniqueWithoutObrasInput | actividades_empleadosUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: actividades_empleadosUpdateManyWithWhereWithoutObrasInput | actividades_empleadosUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
  }

  export type actividades_materialesUpdateManyWithoutObrasNestedInput = {
    create?: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput> | actividades_materialesCreateWithoutObrasInput[] | actividades_materialesUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutObrasInput | actividades_materialesCreateOrConnectWithoutObrasInput[]
    upsert?: actividades_materialesUpsertWithWhereUniqueWithoutObrasInput | actividades_materialesUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: actividades_materialesCreateManyObrasInputEnvelope
    set?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    disconnect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    delete?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    update?: actividades_materialesUpdateWithWhereUniqueWithoutObrasInput | actividades_materialesUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: actividades_materialesUpdateManyWithWhereWithoutObrasInput | actividades_materialesUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
  }

  export type detalle_obraUpdateManyWithoutObrasNestedInput = {
    create?: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput> | detalle_obraCreateWithoutObrasInput[] | detalle_obraUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: detalle_obraCreateOrConnectWithoutObrasInput | detalle_obraCreateOrConnectWithoutObrasInput[]
    upsert?: detalle_obraUpsertWithWhereUniqueWithoutObrasInput | detalle_obraUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: detalle_obraCreateManyObrasInputEnvelope
    set?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    disconnect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    delete?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    connect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    update?: detalle_obraUpdateWithWhereUniqueWithoutObrasInput | detalle_obraUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: detalle_obraUpdateManyWithWhereWithoutObrasInput | detalle_obraUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: detalle_obraScalarWhereInput | detalle_obraScalarWhereInput[]
  }

  export type empleadoUpdateOneRequiredWithoutObrasNestedInput = {
    create?: XOR<empleadoCreateWithoutObrasInput, empleadoUncheckedCreateWithoutObrasInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutObrasInput
    upsert?: empleadoUpsertWithoutObrasInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutObrasInput, empleadoUpdateWithoutObrasInput>, empleadoUncheckedUpdateWithoutObrasInput>
  }

  export type clienteUpdateOneWithoutObrasNestedInput = {
    create?: XOR<clienteCreateWithoutObrasInput, clienteUncheckedCreateWithoutObrasInput>
    connectOrCreate?: clienteCreateOrConnectWithoutObrasInput
    upsert?: clienteUpsertWithoutObrasInput
    disconnect?: clienteWhereInput | boolean
    delete?: clienteWhereInput | boolean
    connect?: clienteWhereUniqueInput
    update?: XOR<XOR<clienteUpdateToOneWithWhereWithoutObrasInput, clienteUpdateWithoutObrasInput>, clienteUncheckedUpdateWithoutObrasInput>
  }

  export type actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput = {
    create?: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput> | actividades_empleadosCreateWithoutObrasInput[] | actividades_empleadosUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_empleadosCreateOrConnectWithoutObrasInput | actividades_empleadosCreateOrConnectWithoutObrasInput[]
    upsert?: actividades_empleadosUpsertWithWhereUniqueWithoutObrasInput | actividades_empleadosUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: actividades_empleadosCreateManyObrasInputEnvelope
    set?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    disconnect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    delete?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    connect?: actividades_empleadosWhereUniqueInput | actividades_empleadosWhereUniqueInput[]
    update?: actividades_empleadosUpdateWithWhereUniqueWithoutObrasInput | actividades_empleadosUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: actividades_empleadosUpdateManyWithWhereWithoutObrasInput | actividades_empleadosUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
  }

  export type actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput = {
    create?: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput> | actividades_materialesCreateWithoutObrasInput[] | actividades_materialesUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: actividades_materialesCreateOrConnectWithoutObrasInput | actividades_materialesCreateOrConnectWithoutObrasInput[]
    upsert?: actividades_materialesUpsertWithWhereUniqueWithoutObrasInput | actividades_materialesUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: actividades_materialesCreateManyObrasInputEnvelope
    set?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    disconnect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    delete?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    connect?: actividades_materialesWhereUniqueInput | actividades_materialesWhereUniqueInput[]
    update?: actividades_materialesUpdateWithWhereUniqueWithoutObrasInput | actividades_materialesUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: actividades_materialesUpdateManyWithWhereWithoutObrasInput | actividades_materialesUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
  }

  export type detalle_obraUncheckedUpdateManyWithoutObrasNestedInput = {
    create?: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput> | detalle_obraCreateWithoutObrasInput[] | detalle_obraUncheckedCreateWithoutObrasInput[]
    connectOrCreate?: detalle_obraCreateOrConnectWithoutObrasInput | detalle_obraCreateOrConnectWithoutObrasInput[]
    upsert?: detalle_obraUpsertWithWhereUniqueWithoutObrasInput | detalle_obraUpsertWithWhereUniqueWithoutObrasInput[]
    createMany?: detalle_obraCreateManyObrasInputEnvelope
    set?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    disconnect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    delete?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    connect?: detalle_obraWhereUniqueInput | detalle_obraWhereUniqueInput[]
    update?: detalle_obraUpdateWithWhereUniqueWithoutObrasInput | detalle_obraUpdateWithWhereUniqueWithoutObrasInput[]
    updateMany?: detalle_obraUpdateManyWithWhereWithoutObrasInput | detalle_obraUpdateManyWithWhereWithoutObrasInput[]
    deleteMany?: detalle_obraScalarWhereInput | detalle_obraScalarWhereInput[]
  }

  export type rolpermisoempleadoCreateNestedManyWithoutPermisoInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput> | rolpermisoempleadoCreateWithoutPermisoInput[] | rolpermisoempleadoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutPermisoInput | rolpermisoempleadoCreateOrConnectWithoutPermisoInput[]
    createMany?: rolpermisoempleadoCreateManyPermisoInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type rolpermisoempleadoUncheckedCreateNestedManyWithoutPermisoInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput> | rolpermisoempleadoCreateWithoutPermisoInput[] | rolpermisoempleadoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutPermisoInput | rolpermisoempleadoCreateOrConnectWithoutPermisoInput[]
    createMany?: rolpermisoempleadoCreateManyPermisoInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type rolpermisoempleadoUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput> | rolpermisoempleadoCreateWithoutPermisoInput[] | rolpermisoempleadoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutPermisoInput | rolpermisoempleadoCreateOrConnectWithoutPermisoInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutPermisoInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: rolpermisoempleadoCreateManyPermisoInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutPermisoInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutPermisoInput | rolpermisoempleadoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutPermisoNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput> | rolpermisoempleadoCreateWithoutPermisoInput[] | rolpermisoempleadoUncheckedCreateWithoutPermisoInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutPermisoInput | rolpermisoempleadoCreateOrConnectWithoutPermisoInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutPermisoInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutPermisoInput[]
    createMany?: rolpermisoempleadoCreateManyPermisoInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutPermisoInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutPermisoInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutPermisoInput | rolpermisoempleadoUpdateManyWithWhereWithoutPermisoInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type comprasCreateNestedManyWithoutProveedorInput = {
    create?: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput> | comprasCreateWithoutProveedorInput[] | comprasUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutProveedorInput | comprasCreateOrConnectWithoutProveedorInput[]
    createMany?: comprasCreateManyProveedorInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type comprasUncheckedCreateNestedManyWithoutProveedorInput = {
    create?: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput> | comprasCreateWithoutProveedorInput[] | comprasUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutProveedorInput | comprasCreateOrConnectWithoutProveedorInput[]
    createMany?: comprasCreateManyProveedorInputEnvelope
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
  }

  export type comprasUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput> | comprasCreateWithoutProveedorInput[] | comprasUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutProveedorInput | comprasCreateOrConnectWithoutProveedorInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutProveedorInput | comprasUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: comprasCreateManyProveedorInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutProveedorInput | comprasUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutProveedorInput | comprasUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type comprasUncheckedUpdateManyWithoutProveedorNestedInput = {
    create?: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput> | comprasCreateWithoutProveedorInput[] | comprasUncheckedCreateWithoutProveedorInput[]
    connectOrCreate?: comprasCreateOrConnectWithoutProveedorInput | comprasCreateOrConnectWithoutProveedorInput[]
    upsert?: comprasUpsertWithWhereUniqueWithoutProveedorInput | comprasUpsertWithWhereUniqueWithoutProveedorInput[]
    createMany?: comprasCreateManyProveedorInputEnvelope
    set?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    disconnect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    delete?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    connect?: comprasWhereUniqueInput | comprasWhereUniqueInput[]
    update?: comprasUpdateWithWhereUniqueWithoutProveedorInput | comprasUpdateWithWhereUniqueWithoutProveedorInput[]
    updateMany?: comprasUpdateManyWithWhereWithoutProveedorInput | comprasUpdateManyWithWhereWithoutProveedorInput[]
    deleteMany?: comprasScalarWhereInput | comprasScalarWhereInput[]
  }

  export type rolpermisoempleadoCreateNestedManyWithoutRolInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput> | rolpermisoempleadoCreateWithoutRolInput[] | rolpermisoempleadoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutRolInput | rolpermisoempleadoCreateOrConnectWithoutRolInput[]
    createMany?: rolpermisoempleadoCreateManyRolInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type rolpermisoempleadoUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput> | rolpermisoempleadoCreateWithoutRolInput[] | rolpermisoempleadoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutRolInput | rolpermisoempleadoCreateOrConnectWithoutRolInput[]
    createMany?: rolpermisoempleadoCreateManyRolInputEnvelope
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
  }

  export type rolpermisoempleadoUpdateManyWithoutRolNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput> | rolpermisoempleadoCreateWithoutRolInput[] | rolpermisoempleadoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutRolInput | rolpermisoempleadoCreateOrConnectWithoutRolInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutRolInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: rolpermisoempleadoCreateManyRolInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutRolInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutRolInput | rolpermisoempleadoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput> | rolpermisoempleadoCreateWithoutRolInput[] | rolpermisoempleadoUncheckedCreateWithoutRolInput[]
    connectOrCreate?: rolpermisoempleadoCreateOrConnectWithoutRolInput | rolpermisoempleadoCreateOrConnectWithoutRolInput[]
    upsert?: rolpermisoempleadoUpsertWithWhereUniqueWithoutRolInput | rolpermisoempleadoUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: rolpermisoempleadoCreateManyRolInputEnvelope
    set?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    disconnect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    delete?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    connect?: rolpermisoempleadoWhereUniqueInput | rolpermisoempleadoWhereUniqueInput[]
    update?: rolpermisoempleadoUpdateWithWhereUniqueWithoutRolInput | rolpermisoempleadoUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: rolpermisoempleadoUpdateManyWithWhereWithoutRolInput | rolpermisoempleadoUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
  }

  export type obrasCreateNestedOneWithoutDetalle_obraInput = {
    create?: XOR<obrasCreateWithoutDetalle_obraInput, obrasUncheckedCreateWithoutDetalle_obraInput>
    connectOrCreate?: obrasCreateOrConnectWithoutDetalle_obraInput
    connect?: obrasWhereUniqueInput
  }

  export type obrasUpdateOneRequiredWithoutDetalle_obraNestedInput = {
    create?: XOR<obrasCreateWithoutDetalle_obraInput, obrasUncheckedCreateWithoutDetalle_obraInput>
    connectOrCreate?: obrasCreateOrConnectWithoutDetalle_obraInput
    upsert?: obrasUpsertWithoutDetalle_obraInput
    connect?: obrasWhereUniqueInput
    update?: XOR<XOR<obrasUpdateToOneWithWhereWithoutDetalle_obraInput, obrasUpdateWithoutDetalle_obraInput>, obrasUncheckedUpdateWithoutDetalle_obraInput>
  }

  export type empleadoCreateNestedOneWithoutRolpermisoempleadoInput = {
    create?: XOR<empleadoCreateWithoutRolpermisoempleadoInput, empleadoUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutRolpermisoempleadoInput
    connect?: empleadoWhereUniqueInput
  }

  export type permisoCreateNestedOneWithoutRolpermisoempleadoInput = {
    create?: XOR<permisoCreateWithoutRolpermisoempleadoInput, permisoUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: permisoCreateOrConnectWithoutRolpermisoempleadoInput
    connect?: permisoWhereUniqueInput
  }

  export type rolCreateNestedOneWithoutRolpermisoempleadoInput = {
    create?: XOR<rolCreateWithoutRolpermisoempleadoInput, rolUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: rolCreateOrConnectWithoutRolpermisoempleadoInput
    connect?: rolWhereUniqueInput
  }

  export type empleadoUpdateOneWithoutRolpermisoempleadoNestedInput = {
    create?: XOR<empleadoCreateWithoutRolpermisoempleadoInput, empleadoUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutRolpermisoempleadoInput
    upsert?: empleadoUpsertWithoutRolpermisoempleadoInput
    disconnect?: empleadoWhereInput | boolean
    delete?: empleadoWhereInput | boolean
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutRolpermisoempleadoInput, empleadoUpdateWithoutRolpermisoempleadoInput>, empleadoUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type permisoUpdateOneRequiredWithoutRolpermisoempleadoNestedInput = {
    create?: XOR<permisoCreateWithoutRolpermisoempleadoInput, permisoUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: permisoCreateOrConnectWithoutRolpermisoempleadoInput
    upsert?: permisoUpsertWithoutRolpermisoempleadoInput
    connect?: permisoWhereUniqueInput
    update?: XOR<XOR<permisoUpdateToOneWithWhereWithoutRolpermisoempleadoInput, permisoUpdateWithoutRolpermisoempleadoInput>, permisoUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type rolUpdateOneRequiredWithoutRolpermisoempleadoNestedInput = {
    create?: XOR<rolCreateWithoutRolpermisoempleadoInput, rolUncheckedCreateWithoutRolpermisoempleadoInput>
    connectOrCreate?: rolCreateOrConnectWithoutRolpermisoempleadoInput
    upsert?: rolUpsertWithoutRolpermisoempleadoInput
    connect?: rolWhereUniqueInput
    update?: XOR<XOR<rolUpdateToOneWithWhereWithoutRolpermisoempleadoInput, rolUpdateWithoutRolpermisoempleadoInput>, rolUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type empleadoCreateNestedOneWithoutActividades_empleadosInput = {
    create?: XOR<empleadoCreateWithoutActividades_empleadosInput, empleadoUncheckedCreateWithoutActividades_empleadosInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutActividades_empleadosInput
    connect?: empleadoWhereUniqueInput
  }

  export type obrasCreateNestedOneWithoutActividades_empleadosInput = {
    create?: XOR<obrasCreateWithoutActividades_empleadosInput, obrasUncheckedCreateWithoutActividades_empleadosInput>
    connectOrCreate?: obrasCreateOrConnectWithoutActividades_empleadosInput
    connect?: obrasWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type empleadoUpdateOneRequiredWithoutActividades_empleadosNestedInput = {
    create?: XOR<empleadoCreateWithoutActividades_empleadosInput, empleadoUncheckedCreateWithoutActividades_empleadosInput>
    connectOrCreate?: empleadoCreateOrConnectWithoutActividades_empleadosInput
    upsert?: empleadoUpsertWithoutActividades_empleadosInput
    connect?: empleadoWhereUniqueInput
    update?: XOR<XOR<empleadoUpdateToOneWithWhereWithoutActividades_empleadosInput, empleadoUpdateWithoutActividades_empleadosInput>, empleadoUncheckedUpdateWithoutActividades_empleadosInput>
  }

  export type obrasUpdateOneRequiredWithoutActividades_empleadosNestedInput = {
    create?: XOR<obrasCreateWithoutActividades_empleadosInput, obrasUncheckedCreateWithoutActividades_empleadosInput>
    connectOrCreate?: obrasCreateOrConnectWithoutActividades_empleadosInput
    upsert?: obrasUpsertWithoutActividades_empleadosInput
    connect?: obrasWhereUniqueInput
    update?: XOR<XOR<obrasUpdateToOneWithWhereWithoutActividades_empleadosInput, obrasUpdateWithoutActividades_empleadosInput>, obrasUncheckedUpdateWithoutActividades_empleadosInput>
  }

  export type materialesCreateNestedOneWithoutActividades_materialesInput = {
    create?: XOR<materialesCreateWithoutActividades_materialesInput, materialesUncheckedCreateWithoutActividades_materialesInput>
    connectOrCreate?: materialesCreateOrConnectWithoutActividades_materialesInput
    connect?: materialesWhereUniqueInput
  }

  export type obrasCreateNestedOneWithoutActividades_materialesInput = {
    create?: XOR<obrasCreateWithoutActividades_materialesInput, obrasUncheckedCreateWithoutActividades_materialesInput>
    connectOrCreate?: obrasCreateOrConnectWithoutActividades_materialesInput
    connect?: obrasWhereUniqueInput
  }

  export type materialesUpdateOneRequiredWithoutActividades_materialesNestedInput = {
    create?: XOR<materialesCreateWithoutActividades_materialesInput, materialesUncheckedCreateWithoutActividades_materialesInput>
    connectOrCreate?: materialesCreateOrConnectWithoutActividades_materialesInput
    upsert?: materialesUpsertWithoutActividades_materialesInput
    connect?: materialesWhereUniqueInput
    update?: XOR<XOR<materialesUpdateToOneWithWhereWithoutActividades_materialesInput, materialesUpdateWithoutActividades_materialesInput>, materialesUncheckedUpdateWithoutActividades_materialesInput>
  }

  export type obrasUpdateOneRequiredWithoutActividades_materialesNestedInput = {
    create?: XOR<obrasCreateWithoutActividades_materialesInput, obrasUncheckedCreateWithoutActividades_materialesInput>
    connectOrCreate?: obrasCreateOrConnectWithoutActividades_materialesInput
    upsert?: obrasUpsertWithoutActividades_materialesInput
    connect?: obrasWhereUniqueInput
    update?: XOR<XOR<obrasUpdateToOneWithWhereWithoutActividades_materialesInput, obrasUpdateWithoutActividades_materialesInput>, obrasUncheckedUpdateWithoutActividades_materialesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type materialesCreateWithoutCategoriaInput = {
    nombre?: string | null
    estado?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutMaterialesInput
    compras_detalle?: compras_detalleCreateNestedManyWithoutMaterialesInput
  }

  export type materialesUncheckedCreateWithoutCategoriaInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutMaterialesInput
    compras_detalle?: compras_detalleUncheckedCreateNestedManyWithoutMaterialesInput
  }

  export type materialesCreateOrConnectWithoutCategoriaInput = {
    where: materialesWhereUniqueInput
    create: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput>
  }

  export type materialesCreateManyCategoriaInputEnvelope = {
    data: materialesCreateManyCategoriaInput | materialesCreateManyCategoriaInput[]
    skipDuplicates?: boolean
  }

  export type materialesUpsertWithWhereUniqueWithoutCategoriaInput = {
    where: materialesWhereUniqueInput
    update: XOR<materialesUpdateWithoutCategoriaInput, materialesUncheckedUpdateWithoutCategoriaInput>
    create: XOR<materialesCreateWithoutCategoriaInput, materialesUncheckedCreateWithoutCategoriaInput>
  }

  export type materialesUpdateWithWhereUniqueWithoutCategoriaInput = {
    where: materialesWhereUniqueInput
    data: XOR<materialesUpdateWithoutCategoriaInput, materialesUncheckedUpdateWithoutCategoriaInput>
  }

  export type materialesUpdateManyWithWhereWithoutCategoriaInput = {
    where: materialesScalarWhereInput
    data: XOR<materialesUpdateManyMutationInput, materialesUncheckedUpdateManyWithoutCategoriaInput>
  }

  export type materialesScalarWhereInput = {
    AND?: materialesScalarWhereInput | materialesScalarWhereInput[]
    OR?: materialesScalarWhereInput[]
    NOT?: materialesScalarWhereInput | materialesScalarWhereInput[]
    idMat?: IntFilter<"materiales"> | number
    nombre?: StringNullableFilter<"materiales"> | string | null
    estado?: IntNullableFilter<"materiales"> | number | null
    idCategoria?: IntNullableFilter<"materiales"> | number | null
    cantidad?: FloatFilter<"materiales"> | number
  }

  export type obrasCreateWithoutClienteInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraCreateNestedManyWithoutObrasInput
    empleado: empleadoCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateWithoutClienteInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasCreateOrConnectWithoutClienteInput = {
    where: obrasWhereUniqueInput
    create: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput>
  }

  export type obrasCreateManyClienteInputEnvelope = {
    data: obrasCreateManyClienteInput | obrasCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type obrasUpsertWithWhereUniqueWithoutClienteInput = {
    where: obrasWhereUniqueInput
    update: XOR<obrasUpdateWithoutClienteInput, obrasUncheckedUpdateWithoutClienteInput>
    create: XOR<obrasCreateWithoutClienteInput, obrasUncheckedCreateWithoutClienteInput>
  }

  export type obrasUpdateWithWhereUniqueWithoutClienteInput = {
    where: obrasWhereUniqueInput
    data: XOR<obrasUpdateWithoutClienteInput, obrasUncheckedUpdateWithoutClienteInput>
  }

  export type obrasUpdateManyWithWhereWithoutClienteInput = {
    where: obrasScalarWhereInput
    data: XOR<obrasUpdateManyMutationInput, obrasUncheckedUpdateManyWithoutClienteInput>
  }

  export type obrasScalarWhereInput = {
    AND?: obrasScalarWhereInput | obrasScalarWhereInput[]
    OR?: obrasScalarWhereInput[]
    NOT?: obrasScalarWhereInput | obrasScalarWhereInput[]
    idObra?: IntFilter<"obras"> | number
    descripcion?: StringNullableFilter<"obras"> | string | null
    fechaini?: StringNullableFilter<"obras"> | string | null
    fechafin?: StringNullableFilter<"obras"> | string | null
    area?: StringNullableFilter<"obras"> | string | null
    idCliente?: IntNullableFilter<"obras"> | number | null
    estado?: StringNullableFilter<"obras"> | string | null
    precio?: IntNullableFilter<"obras"> | number | null
    createdAt?: DateTimeFilter<"obras"> | Date | string
    idEmp?: IntFilter<"obras"> | number
  }

  export type proveedorCreateWithoutComprasInput = {
    nombre?: string | null
    direccion?: string | null
    nit?: string | null
    tipo?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    nombreContacto?: string | null
    telefonoContacto?: string | null
    emailContacto?: string | null
  }

  export type proveedorUncheckedCreateWithoutComprasInput = {
    idProv?: number
    nombre?: string | null
    direccion?: string | null
    nit?: string | null
    tipo?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    nombreContacto?: string | null
    telefonoContacto?: string | null
    emailContacto?: string | null
  }

  export type proveedorCreateOrConnectWithoutComprasInput = {
    where: proveedorWhereUniqueInput
    create: XOR<proveedorCreateWithoutComprasInput, proveedorUncheckedCreateWithoutComprasInput>
  }

  export type compras_detalleCreateWithoutComprasInput = {
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
    materiales?: materialesCreateNestedOneWithoutCompras_detalleInput
  }

  export type compras_detalleUncheckedCreateWithoutComprasInput = {
    id?: number
    idMat?: number | null
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type compras_detalleCreateOrConnectWithoutComprasInput = {
    where: compras_detalleWhereUniqueInput
    create: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput>
  }

  export type compras_detalleCreateManyComprasInputEnvelope = {
    data: compras_detalleCreateManyComprasInput | compras_detalleCreateManyComprasInput[]
    skipDuplicates?: boolean
  }

  export type proveedorUpsertWithoutComprasInput = {
    update: XOR<proveedorUpdateWithoutComprasInput, proveedorUncheckedUpdateWithoutComprasInput>
    create: XOR<proveedorCreateWithoutComprasInput, proveedorUncheckedCreateWithoutComprasInput>
    where?: proveedorWhereInput
  }

  export type proveedorUpdateToOneWithWhereWithoutComprasInput = {
    where?: proveedorWhereInput
    data: XOR<proveedorUpdateWithoutComprasInput, proveedorUncheckedUpdateWithoutComprasInput>
  }

  export type proveedorUpdateWithoutComprasInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type proveedorUncheckedUpdateWithoutComprasInput = {
    idProv?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    nit?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    nombreContacto?: NullableStringFieldUpdateOperationsInput | string | null
    telefonoContacto?: NullableStringFieldUpdateOperationsInput | string | null
    emailContacto?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type compras_detalleUpsertWithWhereUniqueWithoutComprasInput = {
    where: compras_detalleWhereUniqueInput
    update: XOR<compras_detalleUpdateWithoutComprasInput, compras_detalleUncheckedUpdateWithoutComprasInput>
    create: XOR<compras_detalleCreateWithoutComprasInput, compras_detalleUncheckedCreateWithoutComprasInput>
  }

  export type compras_detalleUpdateWithWhereUniqueWithoutComprasInput = {
    where: compras_detalleWhereUniqueInput
    data: XOR<compras_detalleUpdateWithoutComprasInput, compras_detalleUncheckedUpdateWithoutComprasInput>
  }

  export type compras_detalleUpdateManyWithWhereWithoutComprasInput = {
    where: compras_detalleScalarWhereInput
    data: XOR<compras_detalleUpdateManyMutationInput, compras_detalleUncheckedUpdateManyWithoutComprasInput>
  }

  export type compras_detalleScalarWhereInput = {
    AND?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
    OR?: compras_detalleScalarWhereInput[]
    NOT?: compras_detalleScalarWhereInput | compras_detalleScalarWhereInput[]
    id?: IntFilter<"compras_detalle"> | number
    idCompra?: IntFilter<"compras_detalle"> | number
    idMat?: IntNullableFilter<"compras_detalle"> | number | null
    cantidad?: IntNullableFilter<"compras_detalle"> | number | null
    precio?: IntNullableFilter<"compras_detalle"> | number | null
    subtotal?: IntNullableFilter<"compras_detalle"> | number | null
  }

  export type comprasCreateWithoutCompras_detalleInput = {
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    proveedor: proveedorCreateNestedOneWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutCompras_detalleInput = {
    idCom?: number
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    idProv: number
  }

  export type comprasCreateOrConnectWithoutCompras_detalleInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutCompras_detalleInput, comprasUncheckedCreateWithoutCompras_detalleInput>
  }

  export type materialesCreateWithoutCompras_detalleInput = {
    nombre?: string | null
    estado?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutMaterialesInput
    categoria?: categoriaCreateNestedOneWithoutMaterialesInput
  }

  export type materialesUncheckedCreateWithoutCompras_detalleInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    idCategoria?: number | null
    cantidad: number
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutMaterialesInput
  }

  export type materialesCreateOrConnectWithoutCompras_detalleInput = {
    where: materialesWhereUniqueInput
    create: XOR<materialesCreateWithoutCompras_detalleInput, materialesUncheckedCreateWithoutCompras_detalleInput>
  }

  export type comprasUpsertWithoutCompras_detalleInput = {
    update: XOR<comprasUpdateWithoutCompras_detalleInput, comprasUncheckedUpdateWithoutCompras_detalleInput>
    create: XOR<comprasCreateWithoutCompras_detalleInput, comprasUncheckedCreateWithoutCompras_detalleInput>
    where?: comprasWhereInput
  }

  export type comprasUpdateToOneWithWhereWithoutCompras_detalleInput = {
    where?: comprasWhereInput
    data: XOR<comprasUpdateWithoutCompras_detalleInput, comprasUncheckedUpdateWithoutCompras_detalleInput>
  }

  export type comprasUpdateWithoutCompras_detalleInput = {
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    proveedor?: proveedorUpdateOneRequiredWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutCompras_detalleInput = {
    idCom?: IntFieldUpdateOperationsInput | number
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    idProv?: IntFieldUpdateOperationsInput | number
  }

  export type materialesUpsertWithoutCompras_detalleInput = {
    update: XOR<materialesUpdateWithoutCompras_detalleInput, materialesUncheckedUpdateWithoutCompras_detalleInput>
    create: XOR<materialesCreateWithoutCompras_detalleInput, materialesUncheckedCreateWithoutCompras_detalleInput>
    where?: materialesWhereInput
  }

  export type materialesUpdateToOneWithWhereWithoutCompras_detalleInput = {
    where?: materialesWhereInput
    data: XOR<materialesUpdateWithoutCompras_detalleInput, materialesUncheckedUpdateWithoutCompras_detalleInput>
  }

  export type materialesUpdateWithoutCompras_detalleInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUpdateManyWithoutMaterialesNestedInput
    categoria?: categoriaUpdateOneWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateWithoutCompras_detalleInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    idCategoria?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutMaterialesNestedInput
  }

  export type actividades_empleadosCreateWithoutEmpleadoInput = {
    actividad: string
    obras: obrasCreateNestedOneWithoutActividades_empleadosInput
  }

  export type actividades_empleadosUncheckedCreateWithoutEmpleadoInput = {
    id?: number
    actividad: string
    idObra: number
  }

  export type actividades_empleadosCreateOrConnectWithoutEmpleadoInput = {
    where: actividades_empleadosWhereUniqueInput
    create: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput>
  }

  export type actividades_empleadosCreateManyEmpleadoInputEnvelope = {
    data: actividades_empleadosCreateManyEmpleadoInput | actividades_empleadosCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type empleado_especialidadCreateWithoutEmpleadoInput = {
    especialidad: especialidadCreateNestedOneWithoutEmpleado_especialidadInput
  }

  export type empleado_especialidadUncheckedCreateWithoutEmpleadoInput = {
    id?: number
    idEsp: number
  }

  export type empleado_especialidadCreateOrConnectWithoutEmpleadoInput = {
    where: empleado_especialidadWhereUniqueInput
    create: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput>
  }

  export type empleado_especialidadCreateManyEmpleadoInputEnvelope = {
    data: empleado_especialidadCreateManyEmpleadoInput | empleado_especialidadCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type obrasCreateWithoutEmpleadoInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraCreateNestedManyWithoutObrasInput
    cliente?: clienteCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateWithoutEmpleadoInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasCreateOrConnectWithoutEmpleadoInput = {
    where: obrasWhereUniqueInput
    create: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput>
  }

  export type obrasCreateManyEmpleadoInputEnvelope = {
    data: obrasCreateManyEmpleadoInput | obrasCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type rolpermisoempleadoCreateWithoutEmpleadoInput = {
    permiso: permisoCreateNestedOneWithoutRolpermisoempleadoInput
    rol: rolCreateNestedOneWithoutRolpermisoempleadoInput
  }

  export type rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput = {
    id?: number
    idRol: number
    idPer: number
  }

  export type rolpermisoempleadoCreateOrConnectWithoutEmpleadoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    create: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type rolpermisoempleadoCreateManyEmpleadoInputEnvelope = {
    data: rolpermisoempleadoCreateManyEmpleadoInput | rolpermisoempleadoCreateManyEmpleadoInput[]
    skipDuplicates?: boolean
  }

  export type actividades_empleadosUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: actividades_empleadosWhereUniqueInput
    update: XOR<actividades_empleadosUpdateWithoutEmpleadoInput, actividades_empleadosUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<actividades_empleadosCreateWithoutEmpleadoInput, actividades_empleadosUncheckedCreateWithoutEmpleadoInput>
  }

  export type actividades_empleadosUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: actividades_empleadosWhereUniqueInput
    data: XOR<actividades_empleadosUpdateWithoutEmpleadoInput, actividades_empleadosUncheckedUpdateWithoutEmpleadoInput>
  }

  export type actividades_empleadosUpdateManyWithWhereWithoutEmpleadoInput = {
    where: actividades_empleadosScalarWhereInput
    data: XOR<actividades_empleadosUpdateManyMutationInput, actividades_empleadosUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type actividades_empleadosScalarWhereInput = {
    AND?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
    OR?: actividades_empleadosScalarWhereInput[]
    NOT?: actividades_empleadosScalarWhereInput | actividades_empleadosScalarWhereInput[]
    id?: IntFilter<"actividades_empleados"> | number
    actividad?: StringFilter<"actividades_empleados"> | string
    idEmp?: IntFilter<"actividades_empleados"> | number
    idObra?: IntFilter<"actividades_empleados"> | number
  }

  export type empleado_especialidadUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: empleado_especialidadWhereUniqueInput
    update: XOR<empleado_especialidadUpdateWithoutEmpleadoInput, empleado_especialidadUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<empleado_especialidadCreateWithoutEmpleadoInput, empleado_especialidadUncheckedCreateWithoutEmpleadoInput>
  }

  export type empleado_especialidadUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: empleado_especialidadWhereUniqueInput
    data: XOR<empleado_especialidadUpdateWithoutEmpleadoInput, empleado_especialidadUncheckedUpdateWithoutEmpleadoInput>
  }

  export type empleado_especialidadUpdateManyWithWhereWithoutEmpleadoInput = {
    where: empleado_especialidadScalarWhereInput
    data: XOR<empleado_especialidadUpdateManyMutationInput, empleado_especialidadUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type empleado_especialidadScalarWhereInput = {
    AND?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
    OR?: empleado_especialidadScalarWhereInput[]
    NOT?: empleado_especialidadScalarWhereInput | empleado_especialidadScalarWhereInput[]
    id?: IntFilter<"empleado_especialidad"> | number
    idEmp?: IntFilter<"empleado_especialidad"> | number
    idEsp?: IntFilter<"empleado_especialidad"> | number
  }

  export type obrasUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: obrasWhereUniqueInput
    update: XOR<obrasUpdateWithoutEmpleadoInput, obrasUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<obrasCreateWithoutEmpleadoInput, obrasUncheckedCreateWithoutEmpleadoInput>
  }

  export type obrasUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: obrasWhereUniqueInput
    data: XOR<obrasUpdateWithoutEmpleadoInput, obrasUncheckedUpdateWithoutEmpleadoInput>
  }

  export type obrasUpdateManyWithWhereWithoutEmpleadoInput = {
    where: obrasScalarWhereInput
    data: XOR<obrasUpdateManyMutationInput, obrasUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type rolpermisoempleadoUpsertWithWhereUniqueWithoutEmpleadoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    update: XOR<rolpermisoempleadoUpdateWithoutEmpleadoInput, rolpermisoempleadoUncheckedUpdateWithoutEmpleadoInput>
    create: XOR<rolpermisoempleadoCreateWithoutEmpleadoInput, rolpermisoempleadoUncheckedCreateWithoutEmpleadoInput>
  }

  export type rolpermisoempleadoUpdateWithWhereUniqueWithoutEmpleadoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    data: XOR<rolpermisoempleadoUpdateWithoutEmpleadoInput, rolpermisoempleadoUncheckedUpdateWithoutEmpleadoInput>
  }

  export type rolpermisoempleadoUpdateManyWithWhereWithoutEmpleadoInput = {
    where: rolpermisoempleadoScalarWhereInput
    data: XOR<rolpermisoempleadoUpdateManyMutationInput, rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoInput>
  }

  export type rolpermisoempleadoScalarWhereInput = {
    AND?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
    OR?: rolpermisoempleadoScalarWhereInput[]
    NOT?: rolpermisoempleadoScalarWhereInput | rolpermisoempleadoScalarWhereInput[]
    id?: IntFilter<"rolpermisoempleado"> | number
    idRol?: IntFilter<"rolpermisoempleado"> | number
    idPer?: IntFilter<"rolpermisoempleado"> | number
    idEmp?: IntNullableFilter<"rolpermisoempleado"> | number | null
  }

  export type empleadoCreateWithoutEmpleado_especialidadInput = {
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutEmpleadoInput
    obras?: obrasCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutEmpleado_especialidadInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutEmpleadoInput
    obras?: obrasUncheckedCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutEmpleado_especialidadInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutEmpleado_especialidadInput, empleadoUncheckedCreateWithoutEmpleado_especialidadInput>
  }

  export type especialidadCreateWithoutEmpleado_especialidadInput = {
    especialidad?: string | null
    estado?: number | null
  }

  export type especialidadUncheckedCreateWithoutEmpleado_especialidadInput = {
    id?: number
    especialidad?: string | null
    estado?: number | null
  }

  export type especialidadCreateOrConnectWithoutEmpleado_especialidadInput = {
    where: especialidadWhereUniqueInput
    create: XOR<especialidadCreateWithoutEmpleado_especialidadInput, especialidadUncheckedCreateWithoutEmpleado_especialidadInput>
  }

  export type empleadoUpsertWithoutEmpleado_especialidadInput = {
    update: XOR<empleadoUpdateWithoutEmpleado_especialidadInput, empleadoUncheckedUpdateWithoutEmpleado_especialidadInput>
    create: XOR<empleadoCreateWithoutEmpleado_especialidadInput, empleadoUncheckedCreateWithoutEmpleado_especialidadInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutEmpleado_especialidadInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutEmpleado_especialidadInput, empleadoUncheckedUpdateWithoutEmpleado_especialidadInput>
  }

  export type empleadoUpdateWithoutEmpleado_especialidadInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutEmpleado_especialidadInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUncheckedUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type especialidadUpsertWithoutEmpleado_especialidadInput = {
    update: XOR<especialidadUpdateWithoutEmpleado_especialidadInput, especialidadUncheckedUpdateWithoutEmpleado_especialidadInput>
    create: XOR<especialidadCreateWithoutEmpleado_especialidadInput, especialidadUncheckedCreateWithoutEmpleado_especialidadInput>
    where?: especialidadWhereInput
  }

  export type especialidadUpdateToOneWithWhereWithoutEmpleado_especialidadInput = {
    where?: especialidadWhereInput
    data: XOR<especialidadUpdateWithoutEmpleado_especialidadInput, especialidadUncheckedUpdateWithoutEmpleado_especialidadInput>
  }

  export type especialidadUpdateWithoutEmpleado_especialidadInput = {
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type especialidadUncheckedUpdateWithoutEmpleado_especialidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleado_especialidadCreateWithoutEspecialidadInput = {
    empleado: empleadoCreateNestedOneWithoutEmpleado_especialidadInput
  }

  export type empleado_especialidadUncheckedCreateWithoutEspecialidadInput = {
    id?: number
    idEmp: number
  }

  export type empleado_especialidadCreateOrConnectWithoutEspecialidadInput = {
    where: empleado_especialidadWhereUniqueInput
    create: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput>
  }

  export type empleado_especialidadCreateManyEspecialidadInputEnvelope = {
    data: empleado_especialidadCreateManyEspecialidadInput | empleado_especialidadCreateManyEspecialidadInput[]
    skipDuplicates?: boolean
  }

  export type empleado_especialidadUpsertWithWhereUniqueWithoutEspecialidadInput = {
    where: empleado_especialidadWhereUniqueInput
    update: XOR<empleado_especialidadUpdateWithoutEspecialidadInput, empleado_especialidadUncheckedUpdateWithoutEspecialidadInput>
    create: XOR<empleado_especialidadCreateWithoutEspecialidadInput, empleado_especialidadUncheckedCreateWithoutEspecialidadInput>
  }

  export type empleado_especialidadUpdateWithWhereUniqueWithoutEspecialidadInput = {
    where: empleado_especialidadWhereUniqueInput
    data: XOR<empleado_especialidadUpdateWithoutEspecialidadInput, empleado_especialidadUncheckedUpdateWithoutEspecialidadInput>
  }

  export type empleado_especialidadUpdateManyWithWhereWithoutEspecialidadInput = {
    where: empleado_especialidadScalarWhereInput
    data: XOR<empleado_especialidadUpdateManyMutationInput, empleado_especialidadUncheckedUpdateManyWithoutEspecialidadInput>
  }

  export type actividades_materialesCreateWithoutMaterialesInput = {
    actividad: string
    cantidad: number
    obras: obrasCreateNestedOneWithoutActividades_materialesInput
  }

  export type actividades_materialesUncheckedCreateWithoutMaterialesInput = {
    id?: number
    actividad: string
    cantidad: number
    idObra: number
  }

  export type actividades_materialesCreateOrConnectWithoutMaterialesInput = {
    where: actividades_materialesWhereUniqueInput
    create: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput>
  }

  export type actividades_materialesCreateManyMaterialesInputEnvelope = {
    data: actividades_materialesCreateManyMaterialesInput | actividades_materialesCreateManyMaterialesInput[]
    skipDuplicates?: boolean
  }

  export type compras_detalleCreateWithoutMaterialesInput = {
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
    compras: comprasCreateNestedOneWithoutCompras_detalleInput
  }

  export type compras_detalleUncheckedCreateWithoutMaterialesInput = {
    id?: number
    idCompra: number
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type compras_detalleCreateOrConnectWithoutMaterialesInput = {
    where: compras_detalleWhereUniqueInput
    create: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput>
  }

  export type compras_detalleCreateManyMaterialesInputEnvelope = {
    data: compras_detalleCreateManyMaterialesInput | compras_detalleCreateManyMaterialesInput[]
    skipDuplicates?: boolean
  }

  export type categoriaCreateWithoutMaterialesInput = {
    nombre?: string | null
    estado?: number | null
    medida?: string | null
  }

  export type categoriaUncheckedCreateWithoutMaterialesInput = {
    idcat?: number
    nombre?: string | null
    estado?: number | null
    medida?: string | null
  }

  export type categoriaCreateOrConnectWithoutMaterialesInput = {
    where: categoriaWhereUniqueInput
    create: XOR<categoriaCreateWithoutMaterialesInput, categoriaUncheckedCreateWithoutMaterialesInput>
  }

  export type actividades_materialesUpsertWithWhereUniqueWithoutMaterialesInput = {
    where: actividades_materialesWhereUniqueInput
    update: XOR<actividades_materialesUpdateWithoutMaterialesInput, actividades_materialesUncheckedUpdateWithoutMaterialesInput>
    create: XOR<actividades_materialesCreateWithoutMaterialesInput, actividades_materialesUncheckedCreateWithoutMaterialesInput>
  }

  export type actividades_materialesUpdateWithWhereUniqueWithoutMaterialesInput = {
    where: actividades_materialesWhereUniqueInput
    data: XOR<actividades_materialesUpdateWithoutMaterialesInput, actividades_materialesUncheckedUpdateWithoutMaterialesInput>
  }

  export type actividades_materialesUpdateManyWithWhereWithoutMaterialesInput = {
    where: actividades_materialesScalarWhereInput
    data: XOR<actividades_materialesUpdateManyMutationInput, actividades_materialesUncheckedUpdateManyWithoutMaterialesInput>
  }

  export type actividades_materialesScalarWhereInput = {
    AND?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
    OR?: actividades_materialesScalarWhereInput[]
    NOT?: actividades_materialesScalarWhereInput | actividades_materialesScalarWhereInput[]
    id?: IntFilter<"actividades_materiales"> | number
    actividad?: StringFilter<"actividades_materiales"> | string
    idMat?: IntFilter<"actividades_materiales"> | number
    cantidad?: IntFilter<"actividades_materiales"> | number
    idObra?: IntFilter<"actividades_materiales"> | number
  }

  export type compras_detalleUpsertWithWhereUniqueWithoutMaterialesInput = {
    where: compras_detalleWhereUniqueInput
    update: XOR<compras_detalleUpdateWithoutMaterialesInput, compras_detalleUncheckedUpdateWithoutMaterialesInput>
    create: XOR<compras_detalleCreateWithoutMaterialesInput, compras_detalleUncheckedCreateWithoutMaterialesInput>
  }

  export type compras_detalleUpdateWithWhereUniqueWithoutMaterialesInput = {
    where: compras_detalleWhereUniqueInput
    data: XOR<compras_detalleUpdateWithoutMaterialesInput, compras_detalleUncheckedUpdateWithoutMaterialesInput>
  }

  export type compras_detalleUpdateManyWithWhereWithoutMaterialesInput = {
    where: compras_detalleScalarWhereInput
    data: XOR<compras_detalleUpdateManyMutationInput, compras_detalleUncheckedUpdateManyWithoutMaterialesInput>
  }

  export type categoriaUpsertWithoutMaterialesInput = {
    update: XOR<categoriaUpdateWithoutMaterialesInput, categoriaUncheckedUpdateWithoutMaterialesInput>
    create: XOR<categoriaCreateWithoutMaterialesInput, categoriaUncheckedCreateWithoutMaterialesInput>
    where?: categoriaWhereInput
  }

  export type categoriaUpdateToOneWithWhereWithoutMaterialesInput = {
    where?: categoriaWhereInput
    data: XOR<categoriaUpdateWithoutMaterialesInput, categoriaUncheckedUpdateWithoutMaterialesInput>
  }

  export type categoriaUpdateWithoutMaterialesInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type categoriaUncheckedUpdateWithoutMaterialesInput = {
    idcat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    medida?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type actividades_empleadosCreateWithoutObrasInput = {
    actividad: string
    empleado: empleadoCreateNestedOneWithoutActividades_empleadosInput
  }

  export type actividades_empleadosUncheckedCreateWithoutObrasInput = {
    id?: number
    actividad: string
    idEmp: number
  }

  export type actividades_empleadosCreateOrConnectWithoutObrasInput = {
    where: actividades_empleadosWhereUniqueInput
    create: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput>
  }

  export type actividades_empleadosCreateManyObrasInputEnvelope = {
    data: actividades_empleadosCreateManyObrasInput | actividades_empleadosCreateManyObrasInput[]
    skipDuplicates?: boolean
  }

  export type actividades_materialesCreateWithoutObrasInput = {
    actividad: string
    cantidad: number
    materiales: materialesCreateNestedOneWithoutActividades_materialesInput
  }

  export type actividades_materialesUncheckedCreateWithoutObrasInput = {
    id?: number
    actividad: string
    idMat: number
    cantidad: number
  }

  export type actividades_materialesCreateOrConnectWithoutObrasInput = {
    where: actividades_materialesWhereUniqueInput
    create: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput>
  }

  export type actividades_materialesCreateManyObrasInputEnvelope = {
    data: actividades_materialesCreateManyObrasInput | actividades_materialesCreateManyObrasInput[]
    skipDuplicates?: boolean
  }

  export type detalle_obraCreateWithoutObrasInput = {
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
  }

  export type detalle_obraUncheckedCreateWithoutObrasInput = {
    id?: number
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
  }

  export type detalle_obraCreateOrConnectWithoutObrasInput = {
    where: detalle_obraWhereUniqueInput
    create: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput>
  }

  export type detalle_obraCreateManyObrasInputEnvelope = {
    data: detalle_obraCreateManyObrasInput | detalle_obraCreateManyObrasInput[]
    skipDuplicates?: boolean
  }

  export type empleadoCreateWithoutObrasInput = {
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutObrasInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadUncheckedCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutObrasInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutObrasInput, empleadoUncheckedCreateWithoutObrasInput>
  }

  export type clienteCreateWithoutObrasInput = {
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    direccion?: string | null
    telefono?: string | null
    tipoDoc?: string | null
    cedula?: string | null
    fecha_nac?: string | null
    estado?: number | null
    constrasena?: string | null
    createdAt?: Date | string
  }

  export type clienteUncheckedCreateWithoutObrasInput = {
    idCli?: number
    nombre?: string | null
    apellidos?: string | null
    email?: string | null
    direccion?: string | null
    telefono?: string | null
    tipoDoc?: string | null
    cedula?: string | null
    fecha_nac?: string | null
    estado?: number | null
    constrasena?: string | null
    createdAt?: Date | string
  }

  export type clienteCreateOrConnectWithoutObrasInput = {
    where: clienteWhereUniqueInput
    create: XOR<clienteCreateWithoutObrasInput, clienteUncheckedCreateWithoutObrasInput>
  }

  export type actividades_empleadosUpsertWithWhereUniqueWithoutObrasInput = {
    where: actividades_empleadosWhereUniqueInput
    update: XOR<actividades_empleadosUpdateWithoutObrasInput, actividades_empleadosUncheckedUpdateWithoutObrasInput>
    create: XOR<actividades_empleadosCreateWithoutObrasInput, actividades_empleadosUncheckedCreateWithoutObrasInput>
  }

  export type actividades_empleadosUpdateWithWhereUniqueWithoutObrasInput = {
    where: actividades_empleadosWhereUniqueInput
    data: XOR<actividades_empleadosUpdateWithoutObrasInput, actividades_empleadosUncheckedUpdateWithoutObrasInput>
  }

  export type actividades_empleadosUpdateManyWithWhereWithoutObrasInput = {
    where: actividades_empleadosScalarWhereInput
    data: XOR<actividades_empleadosUpdateManyMutationInput, actividades_empleadosUncheckedUpdateManyWithoutObrasInput>
  }

  export type actividades_materialesUpsertWithWhereUniqueWithoutObrasInput = {
    where: actividades_materialesWhereUniqueInput
    update: XOR<actividades_materialesUpdateWithoutObrasInput, actividades_materialesUncheckedUpdateWithoutObrasInput>
    create: XOR<actividades_materialesCreateWithoutObrasInput, actividades_materialesUncheckedCreateWithoutObrasInput>
  }

  export type actividades_materialesUpdateWithWhereUniqueWithoutObrasInput = {
    where: actividades_materialesWhereUniqueInput
    data: XOR<actividades_materialesUpdateWithoutObrasInput, actividades_materialesUncheckedUpdateWithoutObrasInput>
  }

  export type actividades_materialesUpdateManyWithWhereWithoutObrasInput = {
    where: actividades_materialesScalarWhereInput
    data: XOR<actividades_materialesUpdateManyMutationInput, actividades_materialesUncheckedUpdateManyWithoutObrasInput>
  }

  export type detalle_obraUpsertWithWhereUniqueWithoutObrasInput = {
    where: detalle_obraWhereUniqueInput
    update: XOR<detalle_obraUpdateWithoutObrasInput, detalle_obraUncheckedUpdateWithoutObrasInput>
    create: XOR<detalle_obraCreateWithoutObrasInput, detalle_obraUncheckedCreateWithoutObrasInput>
  }

  export type detalle_obraUpdateWithWhereUniqueWithoutObrasInput = {
    where: detalle_obraWhereUniqueInput
    data: XOR<detalle_obraUpdateWithoutObrasInput, detalle_obraUncheckedUpdateWithoutObrasInput>
  }

  export type detalle_obraUpdateManyWithWhereWithoutObrasInput = {
    where: detalle_obraScalarWhereInput
    data: XOR<detalle_obraUpdateManyMutationInput, detalle_obraUncheckedUpdateManyWithoutObrasInput>
  }

  export type detalle_obraScalarWhereInput = {
    AND?: detalle_obraScalarWhereInput | detalle_obraScalarWhereInput[]
    OR?: detalle_obraScalarWhereInput[]
    NOT?: detalle_obraScalarWhereInput | detalle_obraScalarWhereInput[]
    id?: IntFilter<"detalle_obra"> | number
    actividad?: StringNullableFilter<"detalle_obra"> | string | null
    fechaini?: StringNullableFilter<"detalle_obra"> | string | null
    fechafin?: IntNullableFilter<"detalle_obra"> | number | null
    estado?: StringNullableFilter<"detalle_obra"> | string | null
    idObra?: IntFilter<"detalle_obra"> | number
  }

  export type empleadoUpsertWithoutObrasInput = {
    update: XOR<empleadoUpdateWithoutObrasInput, empleadoUncheckedUpdateWithoutObrasInput>
    create: XOR<empleadoCreateWithoutObrasInput, empleadoUncheckedCreateWithoutObrasInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutObrasInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutObrasInput, empleadoUncheckedUpdateWithoutObrasInput>
  }

  export type empleadoUpdateWithoutObrasInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutObrasInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUncheckedUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type clienteUpsertWithoutObrasInput = {
    update: XOR<clienteUpdateWithoutObrasInput, clienteUncheckedUpdateWithoutObrasInput>
    create: XOR<clienteCreateWithoutObrasInput, clienteUncheckedCreateWithoutObrasInput>
    where?: clienteWhereInput
  }

  export type clienteUpdateToOneWithWhereWithoutObrasInput = {
    where?: clienteWhereInput
    data: XOR<clienteUpdateWithoutObrasInput, clienteUncheckedUpdateWithoutObrasInput>
  }

  export type clienteUpdateWithoutObrasInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type clienteUncheckedUpdateWithoutObrasInput = {
    idCli?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nac?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    constrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolpermisoempleadoCreateWithoutPermisoInput = {
    empleado?: empleadoCreateNestedOneWithoutRolpermisoempleadoInput
    rol: rolCreateNestedOneWithoutRolpermisoempleadoInput
  }

  export type rolpermisoempleadoUncheckedCreateWithoutPermisoInput = {
    id?: number
    idRol: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoCreateOrConnectWithoutPermisoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    create: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput>
  }

  export type rolpermisoempleadoCreateManyPermisoInputEnvelope = {
    data: rolpermisoempleadoCreateManyPermisoInput | rolpermisoempleadoCreateManyPermisoInput[]
    skipDuplicates?: boolean
  }

  export type rolpermisoempleadoUpsertWithWhereUniqueWithoutPermisoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    update: XOR<rolpermisoempleadoUpdateWithoutPermisoInput, rolpermisoempleadoUncheckedUpdateWithoutPermisoInput>
    create: XOR<rolpermisoempleadoCreateWithoutPermisoInput, rolpermisoempleadoUncheckedCreateWithoutPermisoInput>
  }

  export type rolpermisoempleadoUpdateWithWhereUniqueWithoutPermisoInput = {
    where: rolpermisoempleadoWhereUniqueInput
    data: XOR<rolpermisoempleadoUpdateWithoutPermisoInput, rolpermisoempleadoUncheckedUpdateWithoutPermisoInput>
  }

  export type rolpermisoempleadoUpdateManyWithWhereWithoutPermisoInput = {
    where: rolpermisoempleadoScalarWhereInput
    data: XOR<rolpermisoempleadoUpdateManyMutationInput, rolpermisoempleadoUncheckedUpdateManyWithoutPermisoInput>
  }

  export type comprasCreateWithoutProveedorInput = {
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    compras_detalle?: compras_detalleCreateNestedManyWithoutComprasInput
  }

  export type comprasUncheckedCreateWithoutProveedorInput = {
    idCom?: number
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
    compras_detalle?: compras_detalleUncheckedCreateNestedManyWithoutComprasInput
  }

  export type comprasCreateOrConnectWithoutProveedorInput = {
    where: comprasWhereUniqueInput
    create: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput>
  }

  export type comprasCreateManyProveedorInputEnvelope = {
    data: comprasCreateManyProveedorInput | comprasCreateManyProveedorInput[]
    skipDuplicates?: boolean
  }

  export type comprasUpsertWithWhereUniqueWithoutProveedorInput = {
    where: comprasWhereUniqueInput
    update: XOR<comprasUpdateWithoutProveedorInput, comprasUncheckedUpdateWithoutProveedorInput>
    create: XOR<comprasCreateWithoutProveedorInput, comprasUncheckedCreateWithoutProveedorInput>
  }

  export type comprasUpdateWithWhereUniqueWithoutProveedorInput = {
    where: comprasWhereUniqueInput
    data: XOR<comprasUpdateWithoutProveedorInput, comprasUncheckedUpdateWithoutProveedorInput>
  }

  export type comprasUpdateManyWithWhereWithoutProveedorInput = {
    where: comprasScalarWhereInput
    data: XOR<comprasUpdateManyMutationInput, comprasUncheckedUpdateManyWithoutProveedorInput>
  }

  export type comprasScalarWhereInput = {
    AND?: comprasScalarWhereInput | comprasScalarWhereInput[]
    OR?: comprasScalarWhereInput[]
    NOT?: comprasScalarWhereInput | comprasScalarWhereInput[]
    idCom?: IntFilter<"compras"> | number
    fecha?: StringNullableFilter<"compras"> | string | null
    imagen?: StringNullableFilter<"compras"> | string | null
    total_compra?: IntNullableFilter<"compras"> | number | null
    codigoFactura?: StringNullableFilter<"compras"> | string | null
    idProv?: IntFilter<"compras"> | number
  }

  export type rolpermisoempleadoCreateWithoutRolInput = {
    empleado?: empleadoCreateNestedOneWithoutRolpermisoempleadoInput
    permiso: permisoCreateNestedOneWithoutRolpermisoempleadoInput
  }

  export type rolpermisoempleadoUncheckedCreateWithoutRolInput = {
    id?: number
    idPer: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoCreateOrConnectWithoutRolInput = {
    where: rolpermisoempleadoWhereUniqueInput
    create: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput>
  }

  export type rolpermisoempleadoCreateManyRolInputEnvelope = {
    data: rolpermisoempleadoCreateManyRolInput | rolpermisoempleadoCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type rolpermisoempleadoUpsertWithWhereUniqueWithoutRolInput = {
    where: rolpermisoempleadoWhereUniqueInput
    update: XOR<rolpermisoempleadoUpdateWithoutRolInput, rolpermisoempleadoUncheckedUpdateWithoutRolInput>
    create: XOR<rolpermisoempleadoCreateWithoutRolInput, rolpermisoempleadoUncheckedCreateWithoutRolInput>
  }

  export type rolpermisoempleadoUpdateWithWhereUniqueWithoutRolInput = {
    where: rolpermisoempleadoWhereUniqueInput
    data: XOR<rolpermisoempleadoUpdateWithoutRolInput, rolpermisoempleadoUncheckedUpdateWithoutRolInput>
  }

  export type rolpermisoempleadoUpdateManyWithWhereWithoutRolInput = {
    where: rolpermisoempleadoScalarWhereInput
    data: XOR<rolpermisoempleadoUpdateManyMutationInput, rolpermisoempleadoUncheckedUpdateManyWithoutRolInput>
  }

  export type obrasCreateWithoutDetalle_obraInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutObrasInput
    empleado: empleadoCreateNestedOneWithoutObrasInput
    cliente?: clienteCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateWithoutDetalle_obraInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasCreateOrConnectWithoutDetalle_obraInput = {
    where: obrasWhereUniqueInput
    create: XOR<obrasCreateWithoutDetalle_obraInput, obrasUncheckedCreateWithoutDetalle_obraInput>
  }

  export type obrasUpsertWithoutDetalle_obraInput = {
    update: XOR<obrasUpdateWithoutDetalle_obraInput, obrasUncheckedUpdateWithoutDetalle_obraInput>
    create: XOR<obrasCreateWithoutDetalle_obraInput, obrasUncheckedCreateWithoutDetalle_obraInput>
    where?: obrasWhereInput
  }

  export type obrasUpdateToOneWithWhereWithoutDetalle_obraInput = {
    where?: obrasWhereInput
    data: XOR<obrasUpdateWithoutDetalle_obraInput, obrasUncheckedUpdateWithoutDetalle_obraInput>
  }

  export type obrasUpdateWithoutDetalle_obraInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUpdateManyWithoutObrasNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutObrasNestedInput
    cliente?: clienteUpdateOneWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateWithoutDetalle_obraInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type empleadoCreateWithoutRolpermisoempleadoInput = {
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadCreateNestedManyWithoutEmpleadoInput
    obras?: obrasCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutRolpermisoempleadoInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutEmpleadoInput
    empleado_especialidad?: empleado_especialidadUncheckedCreateNestedManyWithoutEmpleadoInput
    obras?: obrasUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutRolpermisoempleadoInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutRolpermisoempleadoInput, empleadoUncheckedCreateWithoutRolpermisoempleadoInput>
  }

  export type permisoCreateWithoutRolpermisoempleadoInput = {
    permiso?: string | null
    estado?: number | null
  }

  export type permisoUncheckedCreateWithoutRolpermisoempleadoInput = {
    idPer?: number
    permiso?: string | null
    estado?: number | null
  }

  export type permisoCreateOrConnectWithoutRolpermisoempleadoInput = {
    where: permisoWhereUniqueInput
    create: XOR<permisoCreateWithoutRolpermisoempleadoInput, permisoUncheckedCreateWithoutRolpermisoempleadoInput>
  }

  export type rolCreateWithoutRolpermisoempleadoInput = {
    nombre?: string | null
    estado?: number | null
  }

  export type rolUncheckedCreateWithoutRolpermisoempleadoInput = {
    idRol?: number
    nombre?: string | null
    estado?: number | null
  }

  export type rolCreateOrConnectWithoutRolpermisoempleadoInput = {
    where: rolWhereUniqueInput
    create: XOR<rolCreateWithoutRolpermisoempleadoInput, rolUncheckedCreateWithoutRolpermisoempleadoInput>
  }

  export type empleadoUpsertWithoutRolpermisoempleadoInput = {
    update: XOR<empleadoUpdateWithoutRolpermisoempleadoInput, empleadoUncheckedUpdateWithoutRolpermisoempleadoInput>
    create: XOR<empleadoCreateWithoutRolpermisoempleadoInput, empleadoUncheckedCreateWithoutRolpermisoempleadoInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutRolpermisoempleadoInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutRolpermisoempleadoInput, empleadoUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type empleadoUpdateWithoutRolpermisoempleadoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutRolpermisoempleadoInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutEmpleadoNestedInput
    empleado_especialidad?: empleado_especialidadUncheckedUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type permisoUpsertWithoutRolpermisoempleadoInput = {
    update: XOR<permisoUpdateWithoutRolpermisoempleadoInput, permisoUncheckedUpdateWithoutRolpermisoempleadoInput>
    create: XOR<permisoCreateWithoutRolpermisoempleadoInput, permisoUncheckedCreateWithoutRolpermisoempleadoInput>
    where?: permisoWhereInput
  }

  export type permisoUpdateToOneWithWhereWithoutRolpermisoempleadoInput = {
    where?: permisoWhereInput
    data: XOR<permisoUpdateWithoutRolpermisoempleadoInput, permisoUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type permisoUpdateWithoutRolpermisoempleadoInput = {
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type permisoUncheckedUpdateWithoutRolpermisoempleadoInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    permiso?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolUpsertWithoutRolpermisoempleadoInput = {
    update: XOR<rolUpdateWithoutRolpermisoempleadoInput, rolUncheckedUpdateWithoutRolpermisoempleadoInput>
    create: XOR<rolCreateWithoutRolpermisoempleadoInput, rolUncheckedCreateWithoutRolpermisoempleadoInput>
    where?: rolWhereInput
  }

  export type rolUpdateToOneWithWhereWithoutRolpermisoempleadoInput = {
    where?: rolWhereInput
    data: XOR<rolUpdateWithoutRolpermisoempleadoInput, rolUncheckedUpdateWithoutRolpermisoempleadoInput>
  }

  export type rolUpdateWithoutRolpermisoempleadoInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolUncheckedUpdateWithoutRolpermisoempleadoInput = {
    idRol?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type empleadoCreateWithoutActividades_empleadosInput = {
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    empleado_especialidad?: empleado_especialidadCreateNestedManyWithoutEmpleadoInput
    obras?: obrasCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoUncheckedCreateWithoutActividades_empleadosInput = {
    idEmp?: number
    nombre?: string | null
    direccion?: string | null
    estado?: number | null
    email?: string | null
    telefono?: string | null
    cedula?: string | null
    tipoDoc?: string | null
    apellidos?: string | null
    contrasena?: string | null
    createdAt?: Date | string
    empleado_especialidad?: empleado_especialidadUncheckedCreateNestedManyWithoutEmpleadoInput
    obras?: obrasUncheckedCreateNestedManyWithoutEmpleadoInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedCreateNestedManyWithoutEmpleadoInput
  }

  export type empleadoCreateOrConnectWithoutActividades_empleadosInput = {
    where: empleadoWhereUniqueInput
    create: XOR<empleadoCreateWithoutActividades_empleadosInput, empleadoUncheckedCreateWithoutActividades_empleadosInput>
  }

  export type obrasCreateWithoutActividades_empleadosInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_materiales?: actividades_materialesCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraCreateNestedManyWithoutObrasInput
    empleado: empleadoCreateNestedOneWithoutObrasInput
    cliente?: clienteCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateWithoutActividades_empleadosInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
    actividades_materiales?: actividades_materialesUncheckedCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasCreateOrConnectWithoutActividades_empleadosInput = {
    where: obrasWhereUniqueInput
    create: XOR<obrasCreateWithoutActividades_empleadosInput, obrasUncheckedCreateWithoutActividades_empleadosInput>
  }

  export type empleadoUpsertWithoutActividades_empleadosInput = {
    update: XOR<empleadoUpdateWithoutActividades_empleadosInput, empleadoUncheckedUpdateWithoutActividades_empleadosInput>
    create: XOR<empleadoCreateWithoutActividades_empleadosInput, empleadoUncheckedCreateWithoutActividades_empleadosInput>
    where?: empleadoWhereInput
  }

  export type empleadoUpdateToOneWithWhereWithoutActividades_empleadosInput = {
    where?: empleadoWhereInput
    data: XOR<empleadoUpdateWithoutActividades_empleadosInput, empleadoUncheckedUpdateWithoutActividades_empleadosInput>
  }

  export type empleadoUpdateWithoutActividades_empleadosInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado_especialidad?: empleado_especialidadUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUpdateManyWithoutEmpleadoNestedInput
  }

  export type empleadoUncheckedUpdateWithoutActividades_empleadosInput = {
    idEmp?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    tipoDoc?: NullableStringFieldUpdateOperationsInput | string | null
    apellidos?: NullableStringFieldUpdateOperationsInput | string | null
    contrasena?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    empleado_especialidad?: empleado_especialidadUncheckedUpdateManyWithoutEmpleadoNestedInput
    obras?: obrasUncheckedUpdateManyWithoutEmpleadoNestedInput
    rolpermisoempleado?: rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoNestedInput
  }

  export type obrasUpsertWithoutActividades_empleadosInput = {
    update: XOR<obrasUpdateWithoutActividades_empleadosInput, obrasUncheckedUpdateWithoutActividades_empleadosInput>
    create: XOR<obrasCreateWithoutActividades_empleadosInput, obrasUncheckedCreateWithoutActividades_empleadosInput>
    where?: obrasWhereInput
  }

  export type obrasUpdateToOneWithWhereWithoutActividades_empleadosInput = {
    where?: obrasWhereInput
    data: XOR<obrasUpdateWithoutActividades_empleadosInput, obrasUncheckedUpdateWithoutActividades_empleadosInput>
  }

  export type obrasUpdateWithoutActividades_empleadosInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_materiales?: actividades_materialesUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUpdateManyWithoutObrasNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutObrasNestedInput
    cliente?: clienteUpdateOneWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateWithoutActividades_empleadosInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type materialesCreateWithoutActividades_materialesInput = {
    nombre?: string | null
    estado?: number | null
    cantidad: number
    compras_detalle?: compras_detalleCreateNestedManyWithoutMaterialesInput
    categoria?: categoriaCreateNestedOneWithoutMaterialesInput
  }

  export type materialesUncheckedCreateWithoutActividades_materialesInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    idCategoria?: number | null
    cantidad: number
    compras_detalle?: compras_detalleUncheckedCreateNestedManyWithoutMaterialesInput
  }

  export type materialesCreateOrConnectWithoutActividades_materialesInput = {
    where: materialesWhereUniqueInput
    create: XOR<materialesCreateWithoutActividades_materialesInput, materialesUncheckedCreateWithoutActividades_materialesInput>
  }

  export type obrasCreateWithoutActividades_materialesInput = {
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    actividades_empleados?: actividades_empleadosCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraCreateNestedManyWithoutObrasInput
    empleado: empleadoCreateNestedOneWithoutObrasInput
    cliente?: clienteCreateNestedOneWithoutObrasInput
  }

  export type obrasUncheckedCreateWithoutActividades_materialesInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
    actividades_empleados?: actividades_empleadosUncheckedCreateNestedManyWithoutObrasInput
    detalle_obra?: detalle_obraUncheckedCreateNestedManyWithoutObrasInput
  }

  export type obrasCreateOrConnectWithoutActividades_materialesInput = {
    where: obrasWhereUniqueInput
    create: XOR<obrasCreateWithoutActividades_materialesInput, obrasUncheckedCreateWithoutActividades_materialesInput>
  }

  export type materialesUpsertWithoutActividades_materialesInput = {
    update: XOR<materialesUpdateWithoutActividades_materialesInput, materialesUncheckedUpdateWithoutActividades_materialesInput>
    create: XOR<materialesCreateWithoutActividades_materialesInput, materialesUncheckedCreateWithoutActividades_materialesInput>
    where?: materialesWhereInput
  }

  export type materialesUpdateToOneWithWhereWithoutActividades_materialesInput = {
    where?: materialesWhereInput
    data: XOR<materialesUpdateWithoutActividades_materialesInput, materialesUncheckedUpdateWithoutActividades_materialesInput>
  }

  export type materialesUpdateWithoutActividades_materialesInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    compras_detalle?: compras_detalleUpdateManyWithoutMaterialesNestedInput
    categoria?: categoriaUpdateOneWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateWithoutActividades_materialesInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    idCategoria?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    compras_detalle?: compras_detalleUncheckedUpdateManyWithoutMaterialesNestedInput
  }

  export type obrasUpsertWithoutActividades_materialesInput = {
    update: XOR<obrasUpdateWithoutActividades_materialesInput, obrasUncheckedUpdateWithoutActividades_materialesInput>
    create: XOR<obrasCreateWithoutActividades_materialesInput, obrasUncheckedCreateWithoutActividades_materialesInput>
    where?: obrasWhereInput
  }

  export type obrasUpdateToOneWithWhereWithoutActividades_materialesInput = {
    where?: obrasWhereInput
    data: XOR<obrasUpdateWithoutActividades_materialesInput, obrasUncheckedUpdateWithoutActividades_materialesInput>
  }

  export type obrasUpdateWithoutActividades_materialesInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUpdateManyWithoutObrasNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutObrasNestedInput
    cliente?: clienteUpdateOneWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateWithoutActividades_materialesInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type materialesCreateManyCategoriaInput = {
    idMat?: number
    nombre?: string | null
    estado?: number | null
    cantidad: number
  }

  export type materialesUpdateWithoutCategoriaInput = {
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUpdateManyWithoutMaterialesNestedInput
    compras_detalle?: compras_detalleUpdateManyWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateWithoutCategoriaInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutMaterialesNestedInput
    compras_detalle?: compras_detalleUncheckedUpdateManyWithoutMaterialesNestedInput
  }

  export type materialesUncheckedUpdateManyWithoutCategoriaInput = {
    idMat?: IntFieldUpdateOperationsInput | number
    nombre?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: FloatFieldUpdateOperationsInput | number
  }

  export type obrasCreateManyClienteInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
    idEmp: number
  }

  export type obrasUpdateWithoutClienteInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUpdateManyWithoutObrasNestedInput
    empleado?: empleadoUpdateOneRequiredWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateWithoutClienteInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateManyWithoutClienteInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type compras_detalleCreateManyComprasInput = {
    id?: number
    idMat?: number | null
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type compras_detalleUpdateWithoutComprasInput = {
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
    materiales?: materialesUpdateOneWithoutCompras_detalleNestedInput
  }

  export type compras_detalleUncheckedUpdateWithoutComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idMat?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type compras_detalleUncheckedUpdateManyWithoutComprasInput = {
    id?: IntFieldUpdateOperationsInput | number
    idMat?: NullableIntFieldUpdateOperationsInput | number | null
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type actividades_empleadosCreateManyEmpleadoInput = {
    id?: number
    actividad: string
    idObra: number
  }

  export type empleado_especialidadCreateManyEmpleadoInput = {
    id?: number
    idEsp: number
  }

  export type obrasCreateManyEmpleadoInput = {
    idObra?: number
    descripcion?: string | null
    fechaini?: string | null
    fechafin?: string | null
    area?: string | null
    idCliente?: number | null
    estado?: string | null
    precio?: number | null
    createdAt?: Date | string
  }

  export type rolpermisoempleadoCreateManyEmpleadoInput = {
    id?: number
    idRol: number
    idPer: number
  }

  export type actividades_empleadosUpdateWithoutEmpleadoInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    obras?: obrasUpdateOneRequiredWithoutActividades_empleadosNestedInput
  }

  export type actividades_empleadosUncheckedUpdateWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_empleadosUncheckedUpdateManyWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type empleado_especialidadUpdateWithoutEmpleadoInput = {
    especialidad?: especialidadUpdateOneRequiredWithoutEmpleado_especialidadNestedInput
  }

  export type empleado_especialidadUncheckedUpdateWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEsp?: IntFieldUpdateOperationsInput | number
  }

  export type empleado_especialidadUncheckedUpdateManyWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEsp?: IntFieldUpdateOperationsInput | number
  }

  export type obrasUpdateWithoutEmpleadoInput = {
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUpdateManyWithoutObrasNestedInput
    cliente?: clienteUpdateOneWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateWithoutEmpleadoInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actividades_empleados?: actividades_empleadosUncheckedUpdateManyWithoutObrasNestedInput
    actividades_materiales?: actividades_materialesUncheckedUpdateManyWithoutObrasNestedInput
    detalle_obra?: detalle_obraUncheckedUpdateManyWithoutObrasNestedInput
  }

  export type obrasUncheckedUpdateManyWithoutEmpleadoInput = {
    idObra?: IntFieldUpdateOperationsInput | number
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableStringFieldUpdateOperationsInput | string | null
    area?: NullableStringFieldUpdateOperationsInput | string | null
    idCliente?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolpermisoempleadoUpdateWithoutEmpleadoInput = {
    permiso?: permisoUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
    rol?: rolUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
  }

  export type rolpermisoempleadoUncheckedUpdateWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutEmpleadoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
  }

  export type empleado_especialidadCreateManyEspecialidadInput = {
    id?: number
    idEmp: number
  }

  export type empleado_especialidadUpdateWithoutEspecialidadInput = {
    empleado?: empleadoUpdateOneRequiredWithoutEmpleado_especialidadNestedInput
  }

  export type empleado_especialidadUncheckedUpdateWithoutEspecialidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type empleado_especialidadUncheckedUpdateManyWithoutEspecialidadInput = {
    id?: IntFieldUpdateOperationsInput | number
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesCreateManyMaterialesInput = {
    id?: number
    actividad: string
    cantidad: number
    idObra: number
  }

  export type compras_detalleCreateManyMaterialesInput = {
    id?: number
    idCompra: number
    cantidad?: number | null
    precio?: number | null
    subtotal?: number | null
  }

  export type actividades_materialesUpdateWithoutMaterialesInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    obras?: obrasUpdateOneRequiredWithoutActividades_materialesNestedInput
  }

  export type actividades_materialesUncheckedUpdateWithoutMaterialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesUncheckedUpdateManyWithoutMaterialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    idObra?: IntFieldUpdateOperationsInput | number
  }

  export type compras_detalleUpdateWithoutMaterialesInput = {
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
    compras?: comprasUpdateOneRequiredWithoutCompras_detalleNestedInput
  }

  export type compras_detalleUncheckedUpdateWithoutMaterialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCompra?: IntFieldUpdateOperationsInput | number
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type compras_detalleUncheckedUpdateManyWithoutMaterialesInput = {
    id?: IntFieldUpdateOperationsInput | number
    idCompra?: IntFieldUpdateOperationsInput | number
    cantidad?: NullableIntFieldUpdateOperationsInput | number | null
    precio?: NullableIntFieldUpdateOperationsInput | number | null
    subtotal?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type actividades_empleadosCreateManyObrasInput = {
    id?: number
    actividad: string
    idEmp: number
  }

  export type actividades_materialesCreateManyObrasInput = {
    id?: number
    actividad: string
    idMat: number
    cantidad: number
  }

  export type detalle_obraCreateManyObrasInput = {
    id?: number
    actividad?: string | null
    fechaini?: string | null
    fechafin?: number | null
    estado?: string | null
  }

  export type actividades_empleadosUpdateWithoutObrasInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    empleado?: empleadoUpdateOneRequiredWithoutActividades_empleadosNestedInput
  }

  export type actividades_empleadosUncheckedUpdateWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_empleadosUncheckedUpdateManyWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idEmp?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesUpdateWithoutObrasInput = {
    actividad?: StringFieldUpdateOperationsInput | string
    cantidad?: IntFieldUpdateOperationsInput | number
    materiales?: materialesUpdateOneRequiredWithoutActividades_materialesNestedInput
  }

  export type actividades_materialesUncheckedUpdateWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idMat?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type actividades_materialesUncheckedUpdateManyWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: StringFieldUpdateOperationsInput | string
    idMat?: IntFieldUpdateOperationsInput | number
    cantidad?: IntFieldUpdateOperationsInput | number
  }

  export type detalle_obraUpdateWithoutObrasInput = {
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detalle_obraUncheckedUpdateWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type detalle_obraUncheckedUpdateManyWithoutObrasInput = {
    id?: IntFieldUpdateOperationsInput | number
    actividad?: NullableStringFieldUpdateOperationsInput | string | null
    fechaini?: NullableStringFieldUpdateOperationsInput | string | null
    fechafin?: NullableIntFieldUpdateOperationsInput | number | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolpermisoempleadoCreateManyPermisoInput = {
    id?: number
    idRol: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoUpdateWithoutPermisoInput = {
    empleado?: empleadoUpdateOneWithoutRolpermisoempleadoNestedInput
    rol?: rolUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
  }

  export type rolpermisoempleadoUncheckedUpdateWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutPermisoInput = {
    id?: IntFieldUpdateOperationsInput | number
    idRol?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type comprasCreateManyProveedorInput = {
    idCom?: number
    fecha?: string | null
    imagen?: string | null
    total_compra?: number | null
    codigoFactura?: string | null
  }

  export type comprasUpdateWithoutProveedorInput = {
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    compras_detalle?: compras_detalleUpdateManyWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateWithoutProveedorInput = {
    idCom?: IntFieldUpdateOperationsInput | number
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
    compras_detalle?: compras_detalleUncheckedUpdateManyWithoutComprasNestedInput
  }

  export type comprasUncheckedUpdateManyWithoutProveedorInput = {
    idCom?: IntFieldUpdateOperationsInput | number
    fecha?: NullableStringFieldUpdateOperationsInput | string | null
    imagen?: NullableStringFieldUpdateOperationsInput | string | null
    total_compra?: NullableIntFieldUpdateOperationsInput | number | null
    codigoFactura?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rolpermisoempleadoCreateManyRolInput = {
    id?: number
    idPer: number
    idEmp?: number | null
  }

  export type rolpermisoempleadoUpdateWithoutRolInput = {
    empleado?: empleadoUpdateOneWithoutRolpermisoempleadoNestedInput
    permiso?: permisoUpdateOneRequiredWithoutRolpermisoempleadoNestedInput
  }

  export type rolpermisoempleadoUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type rolpermisoempleadoUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idEmp?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CategoriaCountOutputTypeDefaultArgs instead
     */
    export type CategoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClienteCountOutputTypeDefaultArgs instead
     */
    export type ClienteCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClienteCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComprasCountOutputTypeDefaultArgs instead
     */
    export type ComprasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComprasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadoCountOutputTypeDefaultArgs instead
     */
    export type EmpleadoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EspecialidadCountOutputTypeDefaultArgs instead
     */
    export type EspecialidadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EspecialidadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaterialesCountOutputTypeDefaultArgs instead
     */
    export type MaterialesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaterialesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ObrasCountOutputTypeDefaultArgs instead
     */
    export type ObrasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ObrasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermisoCountOutputTypeDefaultArgs instead
     */
    export type PermisoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermisoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProveedorCountOutputTypeDefaultArgs instead
     */
    export type ProveedorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProveedorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolCountOutputTypeDefaultArgs instead
     */
    export type RolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use categoriaDefaultArgs instead
     */
    export type categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = categoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use clienteDefaultArgs instead
     */
    export type clienteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = clienteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use comprasDefaultArgs instead
     */
    export type comprasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = comprasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use compras_detalleDefaultArgs instead
     */
    export type compras_detalleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = compras_detalleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use empleadoDefaultArgs instead
     */
    export type empleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = empleadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use empleado_especialidadDefaultArgs instead
     */
    export type empleado_especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = empleado_especialidadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use especialidadDefaultArgs instead
     */
    export type especialidadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = especialidadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use materialesDefaultArgs instead
     */
    export type materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = materialesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use obrasDefaultArgs instead
     */
    export type obrasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = obrasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use permisoDefaultArgs instead
     */
    export type permisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = permisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use proveedorDefaultArgs instead
     */
    export type proveedorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = proveedorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolDefaultArgs instead
     */
    export type rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use detalle_obraDefaultArgs instead
     */
    export type detalle_obraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = detalle_obraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use rolpermisoempleadoDefaultArgs instead
     */
    export type rolpermisoempleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = rolpermisoempleadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use codigosDefaultArgs instead
     */
    export type codigosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = codigosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use actividades_empleadosDefaultArgs instead
     */
    export type actividades_empleadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = actividades_empleadosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use actividades_materialesDefaultArgs instead
     */
    export type actividades_materialesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = actividades_materialesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}